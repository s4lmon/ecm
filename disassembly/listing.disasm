Disassembly Listing for final
Generated From:
/Users/hasan/Box Sync/me4/ecm/dist/default/production/ecm.production.elf
Dec 7, 2018 5:20:16 PM

---  /Users/hasan/Box Sync/me4/ecm/rfid.c  --------------------------------------------------------------
1:             #include "rfid.h"
2:             
3:             void init_RFID(void) {
4:                 TRISC = TRISC | 0b11000000; //set data direction registers to the TRGIF tag
149C  5094     MOVF TRISC, W, ACCESS
149E  09C0     IORLW 0xC0
14A0  6E94     MOVWF TRISC, ACCESS
5:                 SPBRG = 204; //set baud rate to 9600
14A2  0ECC     MOVLW 0xCC
14A4  6EAF     MOVWF SPBRG, ACCESS
6:                 SPBRGH = 0;
14A6  0E00     MOVLW 0x0
14A8  6EB0     MOVWF SPBRGH, ACCESS
7:                 BAUDCONbits.BRG16 = 1; //set baud rate scaling to 16 bit mode
14AA  86AA     BSF BAUDCON, 3, ACCESS
8:                 TXSTAbits.BRGH = 1; //high baud rate select bit
14AC  84AC     BSF TXSTA, 2, ACCESS
9:                 RCSTAbits.CREN = 1; //continous receive mode
14AE  88AB     BSF RCSTA, 4, ACCESS
10:                RCSTAbits.SPEN = 1; //enable serial port, other settings default
14B0  8EAB     BSF RCSTA, 7, ACCESS
11:                TXSTAbits.TXEN = 1; //enable transmitter, other settings default
14B2  8AAC     BSF TXSTA, 5, ACCESS
12:            }
14B4  0012     RETURN 0
13:            
14:            void interrupt_EUSART(void) { //this is not EUSART, needs moving
15:                RCREG;
14CC  50AE     MOVF RCREG, W, ACCESS
16:                RCREG;
14CE  50AE     MOVF RCREG, W, ACCESS
17:                RCREG; //Calling RCREG to clear any previous data
14D0  50AE     MOVF RCREG, W, ACCESS
18:                PIE1bits.RCIE = 1; //Enable EUSART interrupt
14D2  8A9D     BSF PIE1, 5, ACCESS
19:                INTCONbits.GIEL = 1; //enable peripheral interrupts
14D4  8CF2     BSF INTCON, 6, ACCESS
20:                INTCONbits.GIEH = 1; //enable global interrupts
14D6  8EF2     BSF INTCON, 7, ACCESS
21:                INTCON3bits.INT2IE = 1;
14D8  88F0     BSF INTCON3, 4, ACCESS
22:                INTCONbits.INT0IE = 1; //for button
14DA  88F2     BSF INTCON, 4, ACCESS
23:                INTCON3bits.INT2IE = 1; //for encoder
14DC  88F0     BSF INTCON3, 4, ACCESS
24:            }
14DE  0012     RETURN 0
25:            //this functions inputs the address of the RFID string array. Values in the LCD displaying ir readings are cleared and the RFID string is sent to the LCD
26:            
27:            void print_RFID(char *pa, char *dis) {
28:            
29:                LCD_clear(); //Remove the current data displayed in the LCD
1178  EC26     CALL 0x144C, 0
117A  F00A     NOP
30:                LCD_line(1);
117C  0E01     MOVLW 0x1
117E  ECC7     CALL 0x138E, 0
1180  F009     NOP
31:                while (*pa != 0x03) { //Finds the address at the last RFID character
1182  D002     BRA 0x1188
32:                    pa++;
1184  4A0B     INFSNZ pa, F, ACCESS
1186  2A0C     INCF counter, F, ACCESS
33:                }
1188  C00B     MOVFF pa, FSR2
118A  FFD9     NOP
118C  C00C     MOVFF counter, FSR2H
118E  FFDA     NOP
1190  0E03     MOVLW 0x3
1192  18DE     XORWF POSTINC2, W, ACCESS
1194  B4D8     BTFSC STATUS, 2, ACCESS
1196  D012     BRA 0x11BC
1198  D7F5     BRA 0x1184
34:            
35:                //Send ASCII characters read from the RFID string to the LCD
36:                while ((dis + 1) < (pa - 2)) { //dis is the address at the first value of the rfid string array. Starting at dis + 1 and finishing at pa - 2 removes undesired ASCII characters read by the RFID.
37:            
38:                    LCD_send(*(dis + 1), 1);
119A  0E01     MOVLW 0x1
119C  6E08     MOVWF type, ACCESS
119E  EE20     LFSR 2, 0x1
11A0  F001     NOP
11A2  500D     MOVF dividend, W, ACCESS
11A4  26D9     ADDWF FSR2, F, ACCESS
11A6  500E     MOVF divisor, W, ACCESS
11A8  22DA     ADDWFC FSR2H, F, ACCESS
11AA  50DF     MOVF INDF2, W, ACCESS
11AC  ECDF     CALL 0x13BE, 0
11AE  F009     NOP
39:                    __delay_us(50);
11B0  0E21     MOVLW 0x21
11B2  2EE8     DECFSZ WREG, F, ACCESS
11B4  D7FE     BRA 0x11B2
11B6  F000     NOP
40:            
41:                    dis++;
11B8  4A0D     INFSNZ dividend, F, ACCESS
11BA  2A0E     INCF divisor, F, ACCESS
42:                }
11BC  0EFE     MOVLW 0xFE
11BE  6E0F     MOVWF divisor, ACCESS
11C0  0EFF     MOVLW 0xFF
11C2  6E10     MOVWF counter, ACCESS
11C4  C00B     MOVFF pa, sign
11C6  F011     NOP
11C8  C00C     MOVFF counter, quotient
11CA  F012     NOP
11CC  500F     MOVF divisor, W, ACCESS
11CE  2611     ADDWF sign, F, ACCESS
11D0  5010     MOVF counter, W, ACCESS
11D2  2212     ADDWFC quotient, F, ACCESS
11D4  0E01     MOVLW 0x1
11D6  240D     ADDWF dividend, W, ACCESS
11D8  6E13     MOVWF 0x13, ACCESS
11DA  0E00     MOVLW 0x0
11DC  200E     ADDWFC divisor, W, ACCESS
11DE  6E14     MOVWF f, ACCESS
11E0  5011     MOVF sign, W, ACCESS
11E2  5C13     SUBWF 0x13, W, ACCESS
11E4  5012     MOVF quotient, W, ACCESS
11E6  5814     SUBWFB f, W, ACCESS
11E8  A0D8     BTFSS STATUS, 0, ACCESS
11EA  D7D7     BRA 0x119A
43:                LCD_line(2); // Set next line for the checksum display function
11EC  0E02     MOVLW 0x2
11EE  ECC7     CALL 0x138E, 0
11F0  F009     NOP
44:            }
11F2  0012     RETURN 0
45:            
46:            
47:            // This function calls the stored RFID string initial value address. The stores RFID string has 12 valuable characters in ASCII format. These are transformed into hexadecimal and stored in the array_check array. low and high bits are combined to form 16 bit integers in the bit_16 array, where the first 5 values are XORed and compared to the 6th value. If satisfied, checksum is correct.
48:            
49:            void check_sum(char *str, char *arr_check, int *bit16, int btc) {
50:            
51:                //Conversion of the string from ASCII to Hexadecimal
52:                int i = 0;
53:                while (i < 12) { // store the 12 valuable characters of the RFID called with the *str address into the array_check array
54:                    if ((*(str + 1) >> 6) == 1) { //If the (str + 1)th character in the RFID string is an ASCII letter, subtract 55 and move to the next character
55:                        *(arr_check) = *(str + 1) - 55;
56:                        str++;
57:                        arr_check++;
58:                        i++;
59:                    } else { //else if it is an ASCII number, subtract 48 and move to the next character
60:                        *(arr_check) = *(str + 1) - 48;
61:                        str++;
62:                        arr_check++;
63:                        i++;
64:                    }
65:                }
66:            
67:                for (char j = 0; j < 6; j++) { //bit_16(count) is written with overlaid low and high bits from the array_check array, compressing a 12 dimensional array into a 6 dimensional array 
68:                    *bit16 = (*(arr_check + 2 * j - 12) << 8) | *(arr_check + 2 * j + 1 - 12); //previous arr_check stopped at 12th position, thus - 12 is necessary to start at the first position of array_check
69:                    bit16++; //move to the next address in the bit_16 array
70:                }
71:            
72:                int xor_value = ((*(bit16 - 6))^(*(bit16 - 5))^(*(bit16 - 4))^(*(bit16 - 3))^(*(bit16 - 2))); // calculate the XOR value of the first 5 entries of the bit_16 array (starts at -6 instead of -5 because the bit16 address is increased in the last iteration above).
73:            
74:                char buf_cs[16];
75:                if (xor_value == *(bit16 - 1)) { //check if the calculated XOR value is identical to the RFID string checksum value and display condition in the LCD display
76:                    sprintf(buf_cs, "CS CORRECT %d", btc); //Also displaying the value of back trace counter to see the number of steps
77:                    LCD_string(buf_cs);
78:                } else {
79:                    sprintf(buf_cs, "CS INCORRECT %d", btc);
80:                    LCD_string(buf_cs);
81:                }
82:            
83:            }
84:            
85:            
86:            
87:            
88:            
---  /Users/hasan/Box Sync/me4/ecm/motor.c  -------------------------------------------------------------
1:             #include "motor.h"
2:             #define POWER 90
3:             #define POWER2 50
4:             #define POWER3 20
5:             #define DELAYTIME 300
6:             
7:             /*
8:              * To initialise motor PWM
9:              */
10:            void initPWM(void) {
11:                TRISB = 0; //setting port as output TODO remove 
142E  0E00     MOVLW 0x0
1430  6E93     MOVWF TRISB, ACCESS
12:            
13:                PTCON0 = 0b00000000;
1432  0E00     MOVLW 0x0
1434  6E7F     MOVWF PTCON0, ACCESS
14:                PTCON1 = 0b10000000;
1436  0E80     MOVLW 0x80
1438  6E7E     MOVWF PTCON1, ACCESS
15:            
16:                PWMCON0 = 0b01111111;
143A  0E7F     MOVLW 0x7F
143C  6E6F     MOVWF PWMCON0, ACCESS
17:                PWMCON1 = 0x00;
143E  0E00     MOVLW 0x0
1440  6E6E     MOVWF PWMCON1, ACCESS
18:            
19:                /*base period low and high bytes*/
20:                PTPERL = 0b11000111;
1442  0EC7     MOVLW 0xC7
1444  6E7B     MOVWF PTPERL, ACCESS
21:                PTPERH = 0b0000;
1446  0E00     MOVLW 0x0
1448  6E7A     MOVWF PTPERH, ACCESS
22:            }
144A  0012     RETURN 0
23:            
24:            void setMotorPWM(struct Motor *m) {
25:                int PWMduty; //tmp variable to store PWM duty cycle
26:                if (m->direction) { //if forward
0A0E  EE20     LFSR 2, 0x1
0A10  F001     NOP
0A12  5014     MOVF f, W, ACCESS
0A14  26D9     ADDWF FSR2, F, ACCESS
0A16  5015     MOVF 0x15, W, ACCESS
0A18  22DA     ADDWFC FSR2H, F, ACCESS
0A1A  50DF     MOVF INDF2, W, ACCESS
0A1C  B4D8     BTFSC STATUS, 2, ACCESS
0A1E  D034     BRA 0xA88
27:                    // low time increases with power
28:                    PWMduty = m->period - ((int) (m->power)*(m->period)) / 100;
0A20  EE20     LFSR 2, 0x7
0A22  F007     NOP
0A24  5014     MOVF f, W, ACCESS
0A26  26D9     ADDWF FSR2, F, ACCESS
0A28  5015     MOVF 0x15, W, ACCESS
0A2A  22DA     ADDWFC FSR2H, F, ACCESS
0A2C  CFDE     MOVFF POSTINC2, 0x16
0A2E  F016     NOP
0A30  CFDD     MOVFF POSTDEC2, 0x17
0A32  F017     NOP
0A34  C014     MOVFF f, FSR2
0A36  FFD9     NOP
0A38  C015     MOVFF 0x15, FSR2H
0A3A  FFDA     NOP
0A3C  50DF     MOVF INDF2, W, ACCESS
0A3E  6E18     MOVWF 0x18, ACCESS
0A40  5018     MOVF 0x18, W, ACCESS
0A42  6E06     MOVWF Values, ACCESS
0A44  6A07     CLRF number, ACCESS
0A46  EE20     LFSR 2, 0x7
0A48  F007     NOP
0A4A  5014     MOVF f, W, ACCESS
0A4C  26D9     ADDWF FSR2, F, ACCESS
0A4E  5015     MOVF 0x15, W, ACCESS
0A50  22DA     ADDWFC FSR2H, F, ACCESS
0A52  CFDE     MOVFF POSTINC2, type
0A54  F008     NOP
0A56  CFDD     MOVFF POSTDEC2, Byte
0A58  F009     NOP
0A5A  ECF5     CALL 0x13EA, 0
0A5C  F009     NOP
0A5E  C006     MOVFF Values, counter
0A60  F00C     NOP
0A62  C007     MOVFF number, dividend
0A64  F00D     NOP
0A66  0E00     MOVLW 0x0
0A68  6E0F     MOVWF divisor, ACCESS
0A6A  0E64     MOVLW 0x64
0A6C  6E0E     MOVWF divisor, ACCESS
0A6E  EC7A     CALL 0x10F4, 0
0A70  F008     NOP
0A72  1E0C     COMF counter, F, ACCESS
0A74  1E0D     COMF dividend, F, ACCESS
0A76  4A0C     INFSNZ counter, F, ACCESS
0A78  2A0D     INCF dividend, F, ACCESS
0A7A  5016     MOVF 0x16, W, ACCESS
0A7C  240C     ADDWF counter, W, ACCESS
0A7E  6E19     MOVWF prec, ACCESS
0A80  5017     MOVF 0x17, W, ACCESS
0A82  200D     ADDWFC dividend, W, ACCESS
0A84  6E1A     MOVWF ap, ACCESS
29:                } else { //if reverse
0A86  D023     BRA 0xACE
30:                    // high time increases with power
31:                    PWMduty = ((int) (m->power)*(m->period)) / 100;
0A88  C014     MOVFF f, FSR2
0A8A  FFD9     NOP
0A8C  C015     MOVFF 0x15, FSR2H
0A8E  FFDA     NOP
0A90  50DF     MOVF INDF2, W, ACCESS
0A92  6E16     MOVWF 0x16, ACCESS
0A94  5016     MOVF 0x16, W, ACCESS
0A96  6E06     MOVWF Values, ACCESS
0A98  6A07     CLRF number, ACCESS
0A9A  EE20     LFSR 2, 0x7
0A9C  F007     NOP
0A9E  5014     MOVF f, W, ACCESS
0AA0  26D9     ADDWF FSR2, F, ACCESS
0AA2  5015     MOVF 0x15, W, ACCESS
0AA4  22DA     ADDWFC FSR2H, F, ACCESS
0AA6  CFDE     MOVFF POSTINC2, type
0AA8  F008     NOP
0AAA  CFDD     MOVFF POSTDEC2, Byte
0AAC  F009     NOP
0AAE  ECF5     CALL 0x13EA, 0
0AB0  F009     NOP
0AB2  C006     MOVFF Values, counter
0AB4  F00C     NOP
0AB6  C007     MOVFF number, dividend
0AB8  F00D     NOP
0ABA  0E00     MOVLW 0x0
0ABC  6E0F     MOVWF divisor, ACCESS
0ABE  0E64     MOVLW 0x64
0AC0  6E0E     MOVWF divisor, ACCESS
0AC2  EC7A     CALL 0x10F4, 0
0AC4  F008     NOP
0AC6  C00C     MOVFF counter, prec
0AC8  F019     NOP
0ACA  C00D     MOVFF dividend, ap
0ACC  F01A     NOP
32:                }
33:                PWMduty = (PWMduty << 2); // two LSBs are reserved for other things
0ACE  C019     MOVFF prec, 0x16
0AD0  F016     NOP
0AD2  C01A     MOVFF ap, 0x17
0AD4  F017     NOP
0AD6  90D8     BCF STATUS, 0, ACCESS
0AD8  3616     RLCF 0x16, F, ACCESS
0ADA  3617     RLCF 0x17, F, ACCESS
0ADC  90D8     BCF STATUS, 0, ACCESS
0ADE  3616     RLCF 0x16, F, ACCESS
0AE0  3617     RLCF 0x17, F, ACCESS
0AE2  C016     MOVFF 0x16, prec
0AE4  F019     NOP
0AE6  C017     MOVFF 0x17, ap
0AE8  F01A     NOP
34:                *(m->duty_low) = PWMduty & 0xFF; //set low duty cycle byte
0AEA  EE20     LFSR 2, 0x2
0AEC  F002     NOP
0AEE  5014     MOVF f, W, ACCESS
0AF0  26D9     ADDWF FSR2, F, ACCESS
0AF2  5015     MOVF 0x15, W, ACCESS
0AF4  22DA     ADDWFC FSR2H, F, ACCESS
0AF6  CFDE     MOVFF POSTINC2, 0x16
0AF8  F016     NOP
0AFA  CFDD     MOVFF POSTDEC2, 0x17
0AFC  F017     NOP
0AFE  C016     MOVFF 0x16, FSR2
0B00  FFD9     NOP
0B02  C017     MOVFF 0x17, FSR2H
0B04  FFDA     NOP
0B06  C019     MOVFF prec, INDF2
0B08  FFDF     NOP
35:                *(m->duty_high) = (PWMduty >> 8) & 0x3F; //set high duty cycle byte
0B0A  EE20     LFSR 2, 0x4
0B0C  F004     NOP
0B0E  5014     MOVF f, W, ACCESS
0B10  26D9     ADDWF FSR2, F, ACCESS
0B12  5015     MOVF 0x15, W, ACCESS
0B14  22DA     ADDWFC FSR2H, F, ACCESS
0B16  CFDE     MOVFF POSTINC2, 0x16
0B18  F016     NOP
0B1A  CFDD     MOVFF POSTDEC2, 0x17
0B1C  F017     NOP
0B1E  C016     MOVFF 0x16, FSR2
0B20  FFD9     NOP
0B22  C017     MOVFF 0x17, FSR2H
0B24  FFDA     NOP
0B26  501A     MOVF ap, W, ACCESS
0B28  0B3F     ANDLW 0x3F
0B2A  6EDF     MOVWF INDF2, ACCESS
36:            
37:                if (m->direction) { // if direction is high,
0B2C  EE20     LFSR 2, 0x1
0B2E  F001     NOP
0B30  5014     MOVF f, W, ACCESS
0B32  26D9     ADDWF FSR2, F, ACCESS
0B34  5015     MOVF 0x15, W, ACCESS
0B36  22DA     ADDWFC FSR2H, F, ACCESS
0B38  50DF     MOVF INDF2, W, ACCESS
0B3A  B4D8     BTFSC STATUS, 2, ACCESS
0B3C  D014     BRA 0xB66
38:                    LATB = LATB | (1 << (m->dir_pin)); // set dir_pin bit in LATB to high
0B3E  EE20     LFSR 2, 0x6
0B40  F006     NOP
0B42  5014     MOVF f, W, ACCESS
0B44  26D9     ADDWF FSR2, F, ACCESS
0B46  5015     MOVF 0x15, W, ACCESS
0B48  22DA     ADDWFC FSR2H, F, ACCESS
0B4A  50DF     MOVF INDF2, W, ACCESS
0B4C  6E16     MOVWF 0x16, ACCESS
0B4E  0E01     MOVLW 0x1
0B50  6E17     MOVWF 0x17, ACCESS
0B52  2A16     INCF 0x16, F, ACCESS
0B54  D002     BRA 0xB5A
0B56  90D8     BCF STATUS, 0, ACCESS
0B58  3617     RLCF 0x17, F, ACCESS
0B5A  2E16     DECFSZ 0x16, F, ACCESS
0B5C  D7FC     BRA 0xB56
0B5E  5017     MOVF 0x17, W, ACCESS
0B60  108A     IORWF LATB, W, ACCESS
0B62  6E8A     MOVWF LATB, ACCESS
39:                } else { // if direction is low,
0B64  0012     RETURN 0
40:                    LATB = LATB & (~(1 << (m->dir_pin))); // set dir_pin bit in LATB to low
0B66  EE20     LFSR 2, 0x6
0B68  F006     NOP
0B6A  5014     MOVF f, W, ACCESS
0B6C  26D9     ADDWF FSR2, F, ACCESS
0B6E  5015     MOVF 0x15, W, ACCESS
0B70  22DA     ADDWFC FSR2H, F, ACCESS
0B72  50DF     MOVF INDF2, W, ACCESS
0B74  6E16     MOVWF 0x16, ACCESS
0B76  0E01     MOVLW 0x1
0B78  6E17     MOVWF 0x17, ACCESS
0B7A  2A16     INCF 0x16, F, ACCESS
0B7C  D002     BRA 0xB82
0B7E  90D8     BCF STATUS, 0, ACCESS
0B80  3617     RLCF 0x17, F, ACCESS
0B82  2E16     DECFSZ 0x16, F, ACCESS
0B84  D7FC     BRA 0xB7E
0B86  5017     MOVF 0x17, W, ACCESS
0B88  0AFF     XORLW 0xFF
0B8A  148A     ANDWF LATB, W, ACCESS
0B8C  6E8A     MOVWF LATB, ACCESS
0B8E  0012     RETURN 0
41:                }
42:            }
43:            
44:            //Control which motor turns on and which direction it rotates
45:            
46:            void accelerate(struct Motor *m) {
47:                for (m->power; (m->power) <= POWER; m->power++) { //increase motor power until 100
48:                    setMotorPWM(m); //pass pointer to setMotorSpeed function (not &m here)
49:                    __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
50:                }
51:            }
52:            
53:            void accelerate2(struct Motor *m) {
54:                for (m->power; (m->power) <= POWER2; m->power++) { //increase motor power until 100
55:                    setMotorPWM(m); //pass pointer to setMotorSpeed function (not &m here)
56:                    __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
57:                }
58:            }
59:            
60:            void decelerate(struct Motor *m) {
61:                for (m->power; (m->power) > 0; m->power--) { //increase motor power until 100
62:                    setMotorPWM(m); //pass pointer to setMotorSpeed function (not &m here)
63:                    __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
64:                }
65:            }
66:            
67:            // high level functions to control left and right motor
68:            // use setMotorPWM to perform low level update
69:            // bring the robot base to a stop
70:            
71:            void stop(struct Motor *mL, struct Motor *mR) {
72:                // While either motor is more than zero
73:                // ----------------------------------------------------------------------
74:                while (((mR->power) > 0) || ((mL->power) > 0)) {
126C  D01F     BRA 0x12AC
75:                    // Check to see if either motor is zero, and decrement respectively
76:                    // ------------------------------------------------------------------
77:                    //        if ((mR->power) > 0)  // If right still more than zero
78:                    //        {
79:                    //            (mR->power)--;      
80:                    //        }
81:                    //        if ((mL->power) > 0)  // If left still more than zero
82:                    //        {
83:                    //            (mL->power)--;
84:                    //        }   
85:                    mL->power = 0;
126E  C01B     MOVFF mL, FSR2
1270  FFD9     NOP
1272  C01C     MOVFF flag, FSR2H
1274  FFDA     NOP
1276  0E00     MOVLW 0x0
1278  6EDF     MOVWF INDF2, ACCESS
86:                    mR->power = 0;
127A  C01D     MOVFF val, FSR2
127C  FFD9     NOP
127E  C01E     MOVFF 0x1E, FSR2H
1280  FFDA     NOP
1282  0E00     MOVLW 0x0
1284  6EDF     MOVWF INDF2, ACCESS
87:                    // Update PWM for each
88:                    // ------------------------------------------------------------------
89:                    setMotorPWM(mL);
1286  C01B     MOVFF mL, f
1288  F014     NOP
128A  C01C     MOVFF flag, 0x15
128C  F015     NOP
128E  EC07     CALL 0xA0E, 0
1290  F005     NOP
90:                    setMotorPWM(mR);
1292  C01D     MOVFF val, f
1294  F014     NOP
1296  C01E     MOVFF 0x1E, 0x15
1298  F015     NOP
129A  EC07     CALL 0xA0E, 0
129C  F005     NOP
91:                    __delay_ms(1);
129E  0E03     MOVLW 0x3
12A0  6E1F     MOVWF c, ACCESS
12A2  0E98     MOVLW 0x98
12A4  2EE8     DECFSZ WREG, F, ACCESS
12A6  D7FE     BRA 0x12A4
12A8  2E1F     DECFSZ c, F, ACCESS
12AA  D7FC     BRA 0x12A4
92:                }
12AC  C01D     MOVFF val, FSR2
12AE  FFD9     NOP
12B0  C01E     MOVFF 0x1E, FSR2H
12B2  FFDA     NOP
12B4  50DF     MOVF INDF2, W, ACCESS
12B6  A4D8     BTFSS STATUS, 2, ACCESS
12B8  D7DA     BRA 0x126E
12BA  C01B     MOVFF mL, FSR2
12BC  FFD9     NOP
12BE  C01C     MOVFF flag, FSR2H
12C0  FFDA     NOP
12C2  50DF     MOVF INDF2, W, ACCESS
12C4  B4D8     BTFSC STATUS, 2, ACCESS
12C6  0012     RETURN 0
12C8  D7D2     BRA 0x126E
93:            }
94:            
95:            void turnLeft(struct Motor *mL, struct Motor *mR) {
96:                //setMotorStop(mL);
97:                //setMotorStop(mR);
98:                mL->direction = 0;
0F32  EE20     LFSR 2, 0x1
0F34  F001     NOP
0F36  501B     MOVF mL, W, ACCESS
0F38  26D9     ADDWF FSR2, F, ACCESS
0F3A  501C     MOVF flag, W, ACCESS
0F3C  22DA     ADDWFC FSR2H, F, ACCESS
0F3E  0E00     MOVLW 0x0
0F40  6EDF     MOVWF INDF2, ACCESS
99:                mR->direction = 1;
0F42  EE20     LFSR 2, 0x1
0F44  F001     NOP
0F46  501D     MOVF val, W, ACCESS
0F48  26D9     ADDWF FSR2, F, ACCESS
0F4A  501E     MOVF 0x1E, W, ACCESS
0F4C  22DA     ADDWFC FSR2H, F, ACCESS
0F4E  0E01     MOVLW 0x1
0F50  6EDF     MOVWF INDF2, ACCESS
100:               while (mL->power < POWER2 || mR->power < POWER2) {
0F52  D02B     BRA 0xFAA
101:                   if (mL->power < POWER2) {
0F54  C01B     MOVFF mL, FSR2
0F56  FFD9     NOP
0F58  C01C     MOVFF flag, FSR2H
0F5A  FFDA     NOP
0F5C  0E32     MOVLW 0x32
0F5E  60DF     CPFSLT INDF2, ACCESS
0F60  D005     BRA 0xF6C
102:                       mL->power++;
0F62  C01B     MOVFF mL, FSR2
0F64  FFD9     NOP
0F66  C01C     MOVFF flag, FSR2H
0F68  FFDA     NOP
0F6A  2ADF     INCF INDF2, F, ACCESS
103:                   }
104:                   if (mR->power < POWER2) {
0F6C  C01D     MOVFF val, FSR2
0F6E  FFD9     NOP
0F70  C01E     MOVFF 0x1E, FSR2H
0F72  FFDA     NOP
0F74  0E32     MOVLW 0x32
0F76  60DF     CPFSLT INDF2, ACCESS
0F78  D005     BRA 0xF84
105:                       mR->power++;
0F7A  C01D     MOVFF val, FSR2
0F7C  FFD9     NOP
0F7E  C01E     MOVFF 0x1E, FSR2H
0F80  FFDA     NOP
0F82  2ADF     INCF INDF2, F, ACCESS
106:                   }
107:                   setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
0F84  C01B     MOVFF mL, f
0F86  F014     NOP
0F88  C01C     MOVFF flag, 0x15
0F8A  F015     NOP
0F8C  EC07     CALL 0xA0E, 0
0F8E  F005     NOP
108:                   setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
0F90  C01D     MOVFF val, f
0F92  F014     NOP
0F94  C01E     MOVFF 0x1E, 0x15
0F96  F015     NOP
0F98  EC07     CALL 0xA0E, 0
0F9A  F005     NOP
109:                   __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
0F9C  0E0D     MOVLW 0xD
0F9E  6E1F     MOVWF c, ACCESS
0FA0  0EFC     MOVLW 0xFC
0FA2  2EE8     DECFSZ WREG, F, ACCESS
0FA4  D7FE     BRA 0xFA2
0FA6  2E1F     DECFSZ c, F, ACCESS
0FA8  D7FC     BRA 0xFA2
110:               }
0FAA  C01B     MOVFF mL, FSR2
0FAC  FFD9     NOP
0FAE  C01C     MOVFF flag, FSR2H
0FB0  FFDA     NOP
0FB2  0E31     MOVLW 0x31
0FB4  64DF     CPFSGT INDF2, ACCESS
0FB6  D7CE     BRA 0xF54
0FB8  C01D     MOVFF val, FSR2
0FBA  FFD9     NOP
0FBC  C01E     MOVFF 0x1E, FSR2H
0FBE  FFDA     NOP
0FC0  0E31     MOVLW 0x31
0FC2  64DF     CPFSGT INDF2, ACCESS
0FC4  D7C7     BRA 0xF54
0FC6  0012     RETURN 0
111:           
112:           }
113:           
114:           void turnRight(struct Motor *mL, struct Motor *mR) {
115:               //setMotorStop(mL);
116:               //setMotorStop(mR);
117:               mL->direction = 1;
0E9C  EE20     LFSR 2, 0x1
0E9E  F001     NOP
0EA0  501B     MOVF mL, W, ACCESS
0EA2  26D9     ADDWF FSR2, F, ACCESS
0EA4  501C     MOVF flag, W, ACCESS
0EA6  22DA     ADDWFC FSR2H, F, ACCESS
0EA8  0E01     MOVLW 0x1
0EAA  6EDF     MOVWF INDF2, ACCESS
118:               mR->direction = 0;
0EAC  EE20     LFSR 2, 0x1
0EAE  F001     NOP
0EB0  501D     MOVF val, W, ACCESS
0EB2  26D9     ADDWF FSR2, F, ACCESS
0EB4  501E     MOVF 0x1E, W, ACCESS
0EB6  22DA     ADDWFC FSR2H, F, ACCESS
0EB8  0E00     MOVLW 0x0
0EBA  6EDF     MOVWF INDF2, ACCESS
119:               while (mL->power < POWER2 || mR->power < POWER2) {
0EBC  D02B     BRA 0xF14
120:                   if (mL->power < POWER2) {
0EBE  C01B     MOVFF mL, FSR2
0EC0  FFD9     NOP
0EC2  C01C     MOVFF flag, FSR2H
0EC4  FFDA     NOP
0EC6  0E32     MOVLW 0x32
0EC8  60DF     CPFSLT INDF2, ACCESS
0ECA  D005     BRA 0xED6
121:                       mL->power++;
0ECC  C01B     MOVFF mL, FSR2
0ECE  FFD9     NOP
0ED0  C01C     MOVFF flag, FSR2H
0ED2  FFDA     NOP
0ED4  2ADF     INCF INDF2, F, ACCESS
122:                   }
123:                   if (mR->power < POWER2) {
0ED6  C01D     MOVFF val, FSR2
0ED8  FFD9     NOP
0EDA  C01E     MOVFF 0x1E, FSR2H
0EDC  FFDA     NOP
0EDE  0E32     MOVLW 0x32
0EE0  60DF     CPFSLT INDF2, ACCESS
0EE2  D005     BRA 0xEEE
124:                       mR->power++;
0EE4  C01D     MOVFF val, FSR2
0EE6  FFD9     NOP
0EE8  C01E     MOVFF 0x1E, FSR2H
0EEA  FFDA     NOP
0EEC  2ADF     INCF INDF2, F, ACCESS
125:                   }
126:                   setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
0EEE  C01B     MOVFF mL, f
0EF0  F014     NOP
0EF2  C01C     MOVFF flag, 0x15
0EF4  F015     NOP
0EF6  EC07     CALL 0xA0E, 0
0EF8  F005     NOP
127:                   setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
0EFA  C01D     MOVFF val, f
0EFC  F014     NOP
0EFE  C01E     MOVFF 0x1E, 0x15
0F00  F015     NOP
0F02  EC07     CALL 0xA0E, 0
0F04  F005     NOP
128:                   __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
0F06  0E0D     MOVLW 0xD
0F08  6E1F     MOVWF c, ACCESS
0F0A  0EFC     MOVLW 0xFC
0F0C  2EE8     DECFSZ WREG, F, ACCESS
0F0E  D7FE     BRA 0xF0C
0F10  2E1F     DECFSZ c, F, ACCESS
0F12  D7FC     BRA 0xF0C
129:               }
0F14  C01B     MOVFF mL, FSR2
0F16  FFD9     NOP
0F18  C01C     MOVFF flag, FSR2H
0F1A  FFDA     NOP
0F1C  0E31     MOVLW 0x31
0F1E  64DF     CPFSGT INDF2, ACCESS
0F20  D7CE     BRA 0xEBE
0F22  C01D     MOVFF val, FSR2
0F24  FFD9     NOP
0F26  C01E     MOVFF 0x1E, FSR2H
0F28  FFDA     NOP
0F2A  0E31     MOVLW 0x31
0F2C  64DF     CPFSGT INDF2, ACCESS
0F2E  D7C7     BRA 0xEBE
0F30  0012     RETURN 0
130:           }
131:           
132:           //void turnRightSlow(struct Motor *mL, struct Motor *mR) {
133:           //    //setMotorStop(mL);
134:           //    //setMotorStop(mR);
135:           //    mL->direction = 1;
136:           //    mR->direction = 0;
137:           //    while (mL->power < POWER3 || mR->power < POWER3) {
138:           //        if (mL->power < POWER3) {
139:           //            mL->power++;
140:           //        }
141:           //        if (mR->power < POWER3
142:           //                ) {
143:           //            mR->power++;
144:           //        }
145:           //        setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
146:           //        setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
147:           //        __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
148:           //    }
149:           //}
150:           // both motors forward and up to full power
151:           
152:           void forwards(struct Motor *mL, struct Motor *mR) {
153:               mL->direction = 0;
0FC8  EE20     LFSR 2, 0x1
0FCA  F001     NOP
0FCC  501B     MOVF mL, W, ACCESS
0FCE  26D9     ADDWF FSR2, F, ACCESS
0FD0  501C     MOVF flag, W, ACCESS
0FD2  22DA     ADDWFC FSR2H, F, ACCESS
0FD4  0E00     MOVLW 0x0
0FD6  6EDF     MOVWF INDF2, ACCESS
154:               mR->direction = 0;
0FD8  EE20     LFSR 2, 0x1
0FDA  F001     NOP
0FDC  501D     MOVF val, W, ACCESS
0FDE  26D9     ADDWF FSR2, F, ACCESS
0FE0  501E     MOVF 0x1E, W, ACCESS
0FE2  22DA     ADDWFC FSR2H, F, ACCESS
0FE4  0E00     MOVLW 0x0
0FE6  6EDF     MOVWF INDF2, ACCESS
155:               while (mL->power < POWER || mR->power < POWER) {
0FE8  D02B     BRA 0x1040
156:                   if (mL->power < POWER) {
0FEA  C01B     MOVFF mL, FSR2
0FEC  FFD9     NOP
0FEE  C01C     MOVFF flag, FSR2H
0FF0  FFDA     NOP
0FF2  0E5A     MOVLW 0x5A
0FF4  60DF     CPFSLT INDF2, ACCESS
0FF6  D005     BRA 0x1002
157:                       mL->power++;
0FF8  C01B     MOVFF mL, FSR2
0FFA  FFD9     NOP
0FFC  C01C     MOVFF flag, FSR2H
0FFE  FFDA     NOP
1000  2ADF     INCF INDF2, F, ACCESS
158:                   }
159:                   if (mR->power < POWER) {
1002  C01D     MOVFF val, FSR2
1004  FFD9     NOP
1006  C01E     MOVFF 0x1E, FSR2H
1008  FFDA     NOP
100A  0E5A     MOVLW 0x5A
100C  60DF     CPFSLT INDF2, ACCESS
100E  D005     BRA 0x101A
160:                       mR->power++;
1010  C01D     MOVFF val, FSR2
1012  FFD9     NOP
1014  C01E     MOVFF 0x1E, FSR2H
1016  FFDA     NOP
1018  2ADF     INCF INDF2, F, ACCESS
161:                   }
162:                   setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
101A  C01B     MOVFF mL, f
101C  F014     NOP
101E  C01C     MOVFF flag, 0x15
1020  F015     NOP
1022  EC07     CALL 0xA0E, 0
1024  F005     NOP
163:                   setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
1026  C01D     MOVFF val, f
1028  F014     NOP
102A  C01E     MOVFF 0x1E, 0x15
102C  F015     NOP
102E  EC07     CALL 0xA0E, 0
1030  F005     NOP
164:                   __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
1032  0E0D     MOVLW 0xD
1034  6E1F     MOVWF c, ACCESS
1036  0EFC     MOVLW 0xFC
1038  2EE8     DECFSZ WREG, F, ACCESS
103A  D7FE     BRA 0x1038
103C  2E1F     DECFSZ c, F, ACCESS
103E  D7FC     BRA 0x1038
165:                   //    }
166:                   //        mR->direction = 0;
167:                   //        while (mL->power < POWER2 || mR->power < POWER2) {
168:                   //            if (mL->power < POWER2) {
169:                   //                mL->power++;
170:                   //            }
171:                   //            if (mR->power < POWER2) {
172:                   //                mR->power++;
173:                   //            }
174:                   //            setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
175:                   //            setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
176:                   //            __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
177:                   //        }
178:               }
1040  C01B     MOVFF mL, FSR2
1042  FFD9     NOP
1044  C01C     MOVFF flag, FSR2H
1046  FFDA     NOP
1048  0E59     MOVLW 0x59
104A  64DF     CPFSGT INDF2, ACCESS
104C  D7CE     BRA 0xFEA
104E  C01D     MOVFF val, FSR2
1050  FFD9     NOP
1052  C01E     MOVFF 0x1E, FSR2H
1054  FFDA     NOP
1056  0E59     MOVLW 0x59
1058  64DF     CPFSGT INDF2, ACCESS
105A  D7C7     BRA 0xFEA
105C  0012     RETURN 0
179:           }
180:           
181:           void backwards(struct Motor *mL, struct Motor *mR) {
182:               mL->direction = 1;
105E  EE20     LFSR 2, 0x1
1060  F001     NOP
1062  501B     MOVF mL, W, ACCESS
1064  26D9     ADDWF FSR2, F, ACCESS
1066  501C     MOVF flag, W, ACCESS
1068  22DA     ADDWFC FSR2H, F, ACCESS
106A  0E01     MOVLW 0x1
106C  6EDF     MOVWF INDF2, ACCESS
183:               mR->direction = 1;
106E  EE20     LFSR 2, 0x1
1070  F001     NOP
1072  501D     MOVF val, W, ACCESS
1074  26D9     ADDWF FSR2, F, ACCESS
1076  501E     MOVF 0x1E, W, ACCESS
1078  22DA     ADDWFC FSR2H, F, ACCESS
107A  0E01     MOVLW 0x1
107C  6EDF     MOVWF INDF2, ACCESS
184:               while (mL->power < POWER || mR->power < POWER) {
107E  D02B     BRA 0x10D6
185:                   if (mL->power < POWER) {
1080  C01B     MOVFF mL, FSR2
1082  FFD9     NOP
1084  C01C     MOVFF flag, FSR2H
1086  FFDA     NOP
1088  0E5A     MOVLW 0x5A
108A  60DF     CPFSLT INDF2, ACCESS
108C  D005     BRA 0x1098
186:                       mL->power++;
108E  C01B     MOVFF mL, FSR2
1090  FFD9     NOP
1092  C01C     MOVFF flag, FSR2H
1094  FFDA     NOP
1096  2ADF     INCF INDF2, F, ACCESS
187:                   }
188:                   if (mR->power < POWER) {
1098  C01D     MOVFF val, FSR2
109A  FFD9     NOP
109C  C01E     MOVFF 0x1E, FSR2H
109E  FFDA     NOP
10A0  0E5A     MOVLW 0x5A
10A2  60DF     CPFSLT INDF2, ACCESS
10A4  D005     BRA 0x10B0
189:                       mR->power++;
10A6  C01D     MOVFF val, FSR2
10A8  FFD9     NOP
10AA  C01E     MOVFF 0x1E, FSR2H
10AC  FFDA     NOP
10AE  2ADF     INCF INDF2, F, ACCESS
190:                   }
191:                   setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
10B0  C01B     MOVFF mL, f
10B2  F014     NOP
10B4  C01C     MOVFF flag, 0x15
10B6  F015     NOP
10B8  EC07     CALL 0xA0E, 0
10BA  F005     NOP
192:                   setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
10BC  C01D     MOVFF val, f
10BE  F014     NOP
10C0  C01E     MOVFF 0x1E, 0x15
10C2  F015     NOP
10C4  EC07     CALL 0xA0E, 0
10C6  F005     NOP
193:                   __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
10C8  0E0D     MOVLW 0xD
10CA  6E1F     MOVWF c, ACCESS
10CC  0EFC     MOVLW 0xFC
10CE  2EE8     DECFSZ WREG, F, ACCESS
10D0  D7FE     BRA 0x10CE
10D2  2E1F     DECFSZ c, F, ACCESS
10D4  D7FC     BRA 0x10CE
194:           
195:               }
10D6  C01B     MOVFF mL, FSR2
10D8  FFD9     NOP
10DA  C01C     MOVFF flag, FSR2H
10DC  FFDA     NOP
10DE  0E59     MOVLW 0x59
10E0  64DF     CPFSGT INDF2, ACCESS
10E2  D7CE     BRA 0x1080
10E4  C01D     MOVFF val, FSR2
10E6  FFD9     NOP
10E8  C01E     MOVFF 0x1E, FSR2H
10EA  FFDA     NOP
10EC  0E59     MOVLW 0x59
10EE  64DF     CPFSGT INDF2, ACCESS
10F0  D7C7     BRA 0x1080
10F2  0012     RETURN 0
196:           }
197:           
198:           void smoothRight(struct Motor *mL, struct Motor *mR) {
199:               
200:                   mL->direction = 0;
201:                   mR->direction = 1;
202:                   while (mL->power < POWER2 || mR->power < POWER3) {
203:                       if (mL->power < POWER2) {
204:                           mL->power++;
205:                       }
206:                       if (mR->power < POWER3) {
207:                           mR->power++;
208:                       }
209:                       setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
210:                       setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
211:                       __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
212:                   }
213:               
214:           }
215:           
216:           void smoothLeft(struct Motor *mL, struct Motor *mR) {
217:               
218:                   mL->direction = 1;
219:                   mR->direction = 0;
220:                   while (mL->power < POWER3 || mR->power < POWER2) {
221:                       if (mL->power < POWER3) {
222:                           mL->power++;
223:                       }
224:                       if (mR->power < POWER2) {
225:                           mR->power++;
226:                       }
227:                       setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
228:                       setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
229:                       __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
230:                   }
231:               
232:           }
233:           
---  /Users/hasan/Box Sync/me4/ecm/main.c  --------------------------------------------------------------
1:             #pragma config OSC = IRCIO, LVP = OFF, MCLRE = OFF
2:             #include <stdio.h>
3:             #include <stdlib.h>
4:             #include <xc.h>
5:             #define _XTAL_FREQ 8000000
6:             #define PWMPERIOD 199
7:             #define TIME 100
8:             #define DELAY 400
9:             #include "lcd.h"
10:            #include "ir.h"
11:            #include "motor.h"
12:            #include "rfid.h"
13:            #include "reverse.h"
14:            
15:            
16:            volatile char card_read; //value will change during the code at any time therefore it must be a volatile character 
17:            char string_rfid[17]; //global variable because it is used in the RFID interrupt and called in the main loop 
18:            //
19:            volatile char count_encoder = 0;
20:            
21:            void __interrupt(high_priority) InterruptHandlerHigh() {
0008  824D     BSF btemp, 1, ACCESS
000A  CFD9     MOVFF FSR2, __pcstackCOMRAM
000C  F001     NOP
000E  CFDA     MOVFF FSR2H, 0x2
0010  F002     NOP
0012  CFF3     MOVFF PROD, 0x3
0014  F003     NOP
0016  CFF4     MOVFF PRODH, 0x4
0018  F004     NOP
22:            
23:                //RFID tag
24:                static char count = 0;
25:                char rx_char;
26:            
27:                if (PIR1bits.RCIF) { //if a character is read from the rfid tag
001A  AA9E     BTFSS PIR1, 5, ACCESS
001C  D01A     BRA 0x52
28:                    rx_char = RCREG;
001E  CFAE     MOVFF RCREG, rx_char
0020  F005     NOP
29:                    if (rx_char == 0x02) { //if it is the first character of the message
0022  0E02     MOVLW 0x2
0024  1805     XORWF rx_char, W, ACCESS
0026  A4D8     BTFSS STATUS, 2, ACCESS
0028  D002     BRA 0x2E
30:                        count = 0;
002A  0E00     MOVLW 0x0
002C  6E39     MOVWF __pbssCOMRAM, ACCESS
31:                    }
32:                    if (rx_char == 0x03) { //when all the message is read
002E  0E03     MOVLW 0x3
0030  1805     XORWF rx_char, W, ACCESS
0032  A4D8     BTFSS STATUS, 2, ACCESS
0034  D003     BRA 0x3C
33:                        card_read = 1; //enter RFID reading and checksum functions
0036  0E01     MOVLW 0x1
0038  0100     MOVLB 0x0
003A  6FF8     MOVWF card_read, BANKED
34:                    }
35:                    string_rfid[count] = rx_char; //store the character read by the RFID tag into a character string
003C  5039     MOVF __pbssCOMRAM, W, ACCESS
003E  0D01     MULLW 0x1
0040  0E3C     MOVLW 0x3C
0042  24F3     ADDWF PROD, W, ACCESS
0044  6ED9     MOVWF FSR2, ACCESS
0046  0E00     MOVLW 0x0
0048  20F4     ADDWFC PRODH, W, ACCESS
004A  6EDA     MOVWF FSR2H, ACCESS
004C  C005     MOVFF rx_char, INDF2
004E  FFDF     NOP
36:                    count++;
0050  2A39     INCF __pbssCOMRAM, F, ACCESS
37:                }
38:            
39:                //    if (INTCONbits.INT0IF) {
40:                //        count_encoder++; // Increment the encoder counter
41:                //
42:                //        INTCONbits.INT0IF = 0; // Clear the encoder flag
43:                //    }
44:            
45:                if (INTCONbits.INT0IF) { //external interrupt flag
0052  A2F2     BTFSS INTCON, 1, ACCESS
0054  D007     BRA 0x64
46:            
47:                    if (PORTCbits.RC3 == 1) {
0056  B682     BTFSC PORTC, 3, ACCESS
48:                        if (PORTCbits.RC3 == 1) {
0058  A682     BTFSS PORTC, 3, ACCESS
005A  D003     BRA 0x62
49:            
50:            
51:                            card_read = 0; //re-start the searching routine
005C  0E00     MOVLW 0x0
005E  0100     MOVLB 0x0
0060  6FF8     MOVWF card_read, BANKED
52:            
53:                        }
54:                    }
55:            
56:                    INTCONbits.INT0IF = 0; //clear the interrupt flag
0062  92F2     BCF INTCON, 1, ACCESS
57:                }
58:            
59:            }
0064  C004     MOVFF 0x4, PRODH
0066  FFF4     NOP
0068  C003     MOVFF 0x3, PROD
006A  FFF3     NOP
006C  C002     MOVFF 0x2, FSR2H
006E  FFDA     NOP
0070  C001     MOVFF __pcstackCOMRAM, FSR2
0072  FFD9     NOP
0074  924D     BCF btemp, 1, ACCESS
0076  0011     RETFIE 1
60:            
61:            void main(void) {
62:            
63:            
64:                char counter = 0;
0344  0E00     MOVLW 0x0
0346  0100     MOVLB 0x0
0348  6FDD     MOVWF counter, BANKED
65:                int forwardsDirection[50];
66:                //        int forwardsTime[50];
67:                //        struct Direction There;
68:                ANSEL0 = 0; //Override start up analogue mode to digital instead
034A  0E00     MOVLW 0x0
034C  6EB8     MOVWF ANSEL0, ACCESS
69:                ANSEL1 = 0;
034E  0E00     MOVLW 0x0
0350  6EB9     MOVWF ANSEL1, ACCESS
70:                OSCCON = 0x72;
0352  0E72     MOVLW 0x72
0354  6ED3     MOVWF OSCCON, ACCESS
71:                while (!OSCCONbits.IOFS);
0356  A4D3     BTFSS OSCCON, 2, ACCESS
0358  D7FE     BRA 0x356
72:            
73:                LCD_init();
035A  EC82     CALL 0xD04, 0
035C  F006     NOP
74:            
75:                init_TIMER5();
035E  EC41     CALL 0x1482, 0
0360  F00A     NOP
76:                initPWM();
0362  EC17     CALL 0x142E, 0
0364  F00A     NOP
77:                init_capture();
0366  EC34     CALL 0x1468, 0
0368  F00A     NOP
78:                init_RFID();
036A  EC4E     CALL 0x149C, 0
036C  F00A     NOP
79:            
80:            
81:            
82:                interrupt_EUSART();
036E  EC66     CALL 0x14CC, 0
0370  F00A     NOP
83:                struct Sensor_ir Values;
84:                struct Motor mL, mR;
85:                int PWMcycle = 199;
0372  0E00     MOVLW 0x0
0374  0100     MOVLB 0x0
0376  6FD5     MOVWF 0xD5, BANKED
0378  0EC7     MOVLW 0xC7
037A  6FD4     MOVWF PWMcycle, BANKED
86:                mL.power = 0; //zero power to start
037C  0E00     MOVLW 0x0
037E  6FE6     MOVWF mL, BANKED
87:                mL.direction = 1; //set default motor direction, forward
0380  0E01     MOVLW 0x1
0382  6FE7     MOVWF 0xE7, BANKED
88:                mL.duty_low = (unsigned char *) (&PDC0L); //store address of PWM duty low byte
0384  0E79     MOVLW 0x79
0386  6FE8     MOVWF 0xE8, BANKED
0388  0E0F     MOVLW 0xF
038A  6FE9     MOVWF 0xE9, BANKED
89:                mL.duty_high = (unsigned char *) (&PDC0H); //store address of PWM duty high byte
038C  0E78     MOVLW 0x78
038E  6FEA     MOVWF 0xEA, BANKED
0390  0E0F     MOVLW 0xF
0392  6FEB     MOVWF 0xEB, BANKED
90:                mL.dir_pin = 0; //pin RB0/PWM0 controls direction
0394  0E00     MOVLW 0x0
0396  6FEC     MOVWF 0xEC, BANKED
91:                mL.period = PWMcycle; //store PWMperiod for motor
0398  C0D4     MOVFF PWMcycle, 0xED
039A  F0ED     NOP
039C  C0D5     MOVFF 0xD5, 0xEE
039E  F0EE     NOP
92:            
93:                //same for motorR but different PWM registers and direction pin
94:                mR.power = 0;
03A0  0E00     MOVLW 0x0
03A2  6FEF     MOVWF mR, BANKED
95:                mR.direction = 1;
03A4  0E01     MOVLW 0x1
03A6  6FF0     MOVWF 0xF0, BANKED
96:                mR.duty_low = (unsigned char *) (&PDC1L);
03A8  0E77     MOVLW 0x77
03AA  6FF1     MOVWF 0xF1, BANKED
03AC  0E0F     MOVLW 0xF
03AE  6FF2     MOVWF 0xF2, BANKED
97:                mR.duty_high = (unsigned char *) (&PDC1H);
03B0  0E76     MOVLW 0x76
03B2  6FF3     MOVWF 0xF3, BANKED
03B4  0E0F     MOVLW 0xF
03B6  6FF4     MOVWF 0xF4, BANKED
98:                mR.dir_pin = 2; //pin RB2/PWM0 controls direction
03B8  0E02     MOVLW 0x2
03BA  6FF5     MOVWF 0xF5, BANKED
99:                mR.period = PWMcycle;
03BC  C0D4     MOVFF PWMcycle, 0xF6
03BE  F0F6     NOP
03C0  C0D5     MOVFF 0xD5, 0xF7
03C2  F0F7     NOP
100:           
101:               forwards(&mL, &mR);
03C4  0EE6     MOVLW 0xE6
03C6  6E1B     MOVWF mL, ACCESS
03C8  0E00     MOVLW 0x0
03CA  6E1C     MOVWF flag, ACCESS
03CC  0EEF     MOVLW 0xEF
03CE  6E1D     MOVWF val, ACCESS
03D0  0E00     MOVLW 0x0
03D2  6E1E     MOVWF 0x1E, ACCESS
03D4  ECE4     CALL 0xFC8, 0
03D6  F007     NOP
102:               stop(&mL, &mR);
03D8  0EE6     MOVLW 0xE6
03DA  6E1B     MOVWF mL, ACCESS
03DC  0E00     MOVLW 0x0
03DE  6E1C     MOVWF flag, ACCESS
03E0  0EEF     MOVLW 0xEF
03E2  6E1D     MOVWF val, ACCESS
03E4  0E00     MOVLW 0x0
03E6  6E1E     MOVWF 0x1E, ACCESS
03E8  EC36     CALL 0x126C, 0
03EA  F009     NOP
103:               stop(&mL, &mR);
03EC  0EE6     MOVLW 0xE6
03EE  6E1B     MOVWF mL, ACCESS
03F0  0E00     MOVLW 0x0
03F2  6E1C     MOVWF flag, ACCESS
03F4  0EEF     MOVLW 0xEF
03F6  6E1D     MOVWF val, ACCESS
03F8  0E00     MOVLW 0x0
03FA  6E1E     MOVWF 0x1E, ACCESS
03FC  EC36     CALL 0x126C, 0
03FE  F009     NOP
104:               INTCONbits.INT0IE = 1;
0400  88F2     BSF INTCON, 4, ACCESS
105:           
106:               card_read = 3;
0402  0E03     MOVLW 0x3
0404  0100     MOVLB 0x0
0406  6FF8     MOVWF card_read, BANKED
107:           
108:               while (1) {
109:                   while (card_read == 3) {
0408  D013     BRA 0x430
110:                       //            stop(&mL, &mR);
111:                       LCD_line(1);
040A  0E01     MOVLW 0x1
040C  ECC7     CALL 0x138E, 0
040E  F009     NOP
112:                       char buf[16];
113:                       sprintf(buf, "Ready");
0410  0EC4     MOVLW 0xC4
0412  6E12     MOVWF quotient, ACCESS
0414  0E00     MOVLW 0x0
0416  6E13     MOVWF 0x13, ACCESS
0418  0E3C     MOVLW 0x3C
041A  6E14     MOVWF f, ACCESS
041C  0E03     MOVLW 0x3
041E  6E15     MOVWF 0x15, ACCESS
0420  ECC8     CALL 0xB90, 0
0422  F005     NOP
114:                       LCD_string(buf);
0424  0EC4     MOVLW 0xC4
0426  6E0A     MOVWF string, ACCESS
0428  0E00     MOVLW 0x0
042A  6E0B     MOVWF pa, ACCESS
042C  ECAF     CALL 0x135E, 0
042E  F009     NOP
115:                       //            while (PORTCbits.RC3 == 0);
116:                   }
0430  0E03     MOVLW 0x3
0432  0100     MOVLB 0x0
0434  19F8     XORWF card_read, W, BANKED
0436  B4D8     BTFSC STATUS, 2, ACCESS
0438  D7E8     BRA 0x40A
117:           
118:                   int direction = 0;
043A  0E00     MOVLW 0x0
043C  6FDC     MOVWF 0xDC, BANKED
043E  0E00     MOVLW 0x0
0440  6FDB     MOVWF direction, BANKED
119:                   //Searching for IR emitter 
120:           
121:                   while (card_read == 0) { //Card read is set to 0 by the interrupt set by pressing the button
0442  D12E     BRA 0x6A0
122:                       read_IR(&Values);
0444  0EDE     MOVLW 0xDE
0446  6E06     MOVWF Values, ACCESS
0448  0E00     MOVLW 0x0
044A  6E07     MOVWF number, ACCESS
044C  EC18     CALL 0x830, 0
044E  F004     NOP
123:                       //            Values.left = measureIRLeft();
124:                       //            Values.right = measureIRRight();
125:           
126:                       print_IR(&Values);
0450  0EDE     MOVLW 0xDE
0452  6E20     MOVWF Values, ACCESS
0454  0E00     MOVLW 0x0
0456  6E21     MOVWF 0x21, ACCESS
0458  ECF7     CALL 0xDEE, 0
045A  F006     NOP
127:           //                        LCD_clear();
128:           //                        char buf[16];
129:           //                        LCD_line(1);
130:           //                        sprintf(buf, "Count: %c", counter);
131:           //                        LCD_string(buf);
132:           //            //
133:           //                        __delay_ms(50);
134:                       //            __delay_ms(50);
135:           
136:                       int threshold = 50;
045C  0E00     MOVLW 0x0
045E  0100     MOVLB 0x0
0460  6FD9     MOVWF 0xD9, BANKED
0462  0E32     MOVLW 0x32
0464  6FD8     MOVWF threshold, BANKED
137:                       int diff = Values.left - Values.right;
0466  EE20     LFSR 2, 0xE0
0468  F0E0     NOP
046A  CFDE     MOVFF POSTINC2, 0x33
046C  F033     NOP
046E  CFDD     MOVFF POSTDEC2, 0x34
0470  F034     NOP
0472  1E33     COMF 0x33, F, ACCESS
0474  1E34     COMF 0x34, F, ACCESS
0476  4A33     INFSNZ 0x33, F, ACCESS
0478  2A34     INCF 0x34, F, ACCESS
047A  51DE     MOVF Values, W, BANKED
047C  2433     ADDWF 0x33, W, ACCESS
047E  6FD6     MOVWF diff, BANKED
0480  51DF     MOVF 0xDF, W, BANKED
0482  2034     ADDWFC 0x34, W, ACCESS
0484  6FD7     MOVWF 0xD7, BANKED
138:                       if (Values.left > 100 | Values.right > 100) {
0486  51DF     MOVF 0xDF, W, BANKED
0488  E10A     BNZ 0x49E
048A  0E65     MOVLW 0x65
048C  5DDE     SUBWF Values, W, BANKED
048E  B0D8     BTFSC STATUS, 0, ACCESS
0490  D006     BRA 0x49E
0492  51E1     MOVF 0xE1, W, BANKED
0494  E104     BNZ 0x49E
0496  0E65     MOVLW 0x65
0498  5DE0     SUBWF 0xE0, W, BANKED
049A  A0D8     BTFSS STATUS, 0, ACCESS
049C  D004     BRA 0x4A6
139:                           threshold = 20;
049E  0E00     MOVLW 0x0
04A0  6FD9     MOVWF 0xD9, BANKED
04A2  0E14     MOVLW 0x14
04A4  D003     BRA 0x4AC
140:                       } else {
141:                           threshold = 5;
04A6  0E00     MOVLW 0x0
04A8  6FD9     MOVWF 0xD9, BANKED
04AA  0E05     MOVLW 0x5
04AC  6FD8     MOVWF threshold, BANKED
142:                       }
143:           
144:                       if ((diff < -threshold)) {
04AE  C0D8     MOVFF threshold, 0x33
04B0  F033     NOP
04B2  C0D9     MOVFF 0xD9, 0x34
04B4  F034     NOP
04B6  1E33     COMF 0x33, F, ACCESS
04B8  1E34     COMF 0x34, F, ACCESS
04BA  4A33     INFSNZ 0x33, F, ACCESS
04BC  2A34     INCF 0x34, F, ACCESS
04BE  5033     MOVF 0x33, W, ACCESS
04C0  5DD6     SUBWF diff, W, BANKED
04C2  51D7     MOVF 0xD7, W, BANKED
04C4  0A80     XORLW 0x80
04C6  6E35     MOVWF 0x35, ACCESS
04C8  5034     MOVF 0x34, W, ACCESS
04CA  0A80     XORLW 0x80
04CC  5835     SUBWFB 0x35, W, ACCESS
04CE  B0D8     BTFSC STATUS, 0, ACCESS
04D0  D036     BRA 0x53E
145:                           if (direction != 1) {
04D2  05DB     DECF direction, W, BANKED
04D4  11DC     IORWF 0xDC, W, BANKED
04D6  B4D8     BTFSC STATUS, 2, ACCESS
04D8  D00A     BRA 0x4EE
146:                               stop(&mL, &mR);
04DA  0EE6     MOVLW 0xE6
04DC  6E1B     MOVWF mL, ACCESS
04DE  0E00     MOVLW 0x0
04E0  6E1C     MOVWF flag, ACCESS
04E2  0EEF     MOVLW 0xEF
04E4  6E1D     MOVWF val, ACCESS
04E6  0E00     MOVLW 0x0
04E8  6E1E     MOVWF 0x1E, ACCESS
04EA  EC36     CALL 0x126C, 0
04EC  F009     NOP
147:                           }
148:                           
149:           //                stop(&mL, &mR);
150:                           
151:                           direction = 1;
04EE  0E00     MOVLW 0x0
04F0  0100     MOVLB 0x0
04F2  6FDC     MOVWF 0xDC, BANKED
04F4  0E01     MOVLW 0x1
04F6  6FDB     MOVWF direction, BANKED
152:                           counter++;
04F8  2BDD     INCF counter, F, BANKED
153:                           forwardsDirection[counter] = direction;
04FA  51DD     MOVF counter, W, BANKED
04FC  0D02     MULLW 0x2
04FE  0E60     MOVLW 0x60
0500  24F3     ADDWF PROD, W, ACCESS
0502  6ED9     MOVWF FSR2, ACCESS
0504  0E00     MOVLW 0x0
0506  20F4     ADDWFC PRODH, W, ACCESS
0508  6EDA     MOVWF FSR2H, ACCESS
050A  C0DB     MOVFF direction, POSTINC2
050C  FFDE     NOP
050E  C0DC     MOVFF 0xDC, POSTDEC2
0510  FFDD     NOP
154:                           turnLeft(&mL, &mR);
0512  0EE6     MOVLW 0xE6
0514  6E1B     MOVWF mL, ACCESS
0516  0E00     MOVLW 0x0
0518  6E1C     MOVWF flag, ACCESS
051A  0EEF     MOVLW 0xEF
051C  6E1D     MOVWF val, ACCESS
051E  0E00     MOVLW 0x0
0520  6E1E     MOVWF 0x1E, ACCESS
0522  EC99     CALL 0xF32, 0
0524  F007     NOP
155:                           __delay_ms(DELAY);
0526  0E05     MOVLW 0x5
0528  6E34     MOVWF 0x34, ACCESS
052A  0E0F     MOVLW 0xF
052C  6E33     MOVWF 0x33, ACCESS
052E  0EF1     MOVLW 0xF1
0530  2EE8     DECFSZ WREG, F, ACCESS
0532  D7FE     BRA 0x530
0534  2E33     DECFSZ 0x33, F, ACCESS
0536  D7FC     BRA 0x530
0538  2E34     DECFSZ 0x34, F, ACCESS
053A  D7FA     BRA 0x530
053C  D0B0     BRA 0x69E
156:               
157:                       } else if (diff > threshold) {
053E  0100     MOVLB 0x0
0540  51D6     MOVF diff, W, BANKED
0542  5DD8     SUBWF threshold, W, BANKED
0544  51D9     MOVF 0xD9, W, BANKED
0546  0A80     XORLW 0x80
0548  6E33     MOVWF 0x33, ACCESS
054A  51D7     MOVF 0xD7, W, BANKED
054C  0A80     XORLW 0x80
054E  5833     SUBWFB 0x33, W, ACCESS
0550  B0D8     BTFSC STATUS, 0, ACCESS
0552  D037     BRA 0x5C2
158:                           if (direction != 2) {
0554  0E02     MOVLW 0x2
0556  19DB     XORWF direction, W, BANKED
0558  11DC     IORWF 0xDC, W, BANKED
055A  B4D8     BTFSC STATUS, 2, ACCESS
055C  D00A     BRA 0x572
159:                               stop(&mL, &mR);
055E  0EE6     MOVLW 0xE6
0560  6E1B     MOVWF mL, ACCESS
0562  0E00     MOVLW 0x0
0564  6E1C     MOVWF flag, ACCESS
0566  0EEF     MOVLW 0xEF
0568  6E1D     MOVWF val, ACCESS
056A  0E00     MOVLW 0x0
056C  6E1E     MOVWF 0x1E, ACCESS
056E  EC36     CALL 0x126C, 0
0570  F009     NOP
160:                           }
161:           //                stop(&mL, &mR);
162:                           
163:                           direction = 2;
0572  0E00     MOVLW 0x0
0574  0100     MOVLB 0x0
0576  6FDC     MOVWF 0xDC, BANKED
0578  0E02     MOVLW 0x2
057A  6FDB     MOVWF direction, BANKED
164:                           counter++;
057C  2BDD     INCF counter, F, BANKED
165:                           forwardsDirection[counter] = direction;
057E  51DD     MOVF counter, W, BANKED
0580  0D02     MULLW 0x2
0582  0E60     MOVLW 0x60
0584  24F3     ADDWF PROD, W, ACCESS
0586  6ED9     MOVWF FSR2, ACCESS
0588  0E00     MOVLW 0x0
058A  20F4     ADDWFC PRODH, W, ACCESS
058C  6EDA     MOVWF FSR2H, ACCESS
058E  C0DB     MOVFF direction, POSTINC2
0590  FFDE     NOP
0592  C0DC     MOVFF 0xDC, POSTDEC2
0594  FFDD     NOP
166:                           turnRight(&mL, &mR);
0596  0EE6     MOVLW 0xE6
0598  6E1B     MOVWF mL, ACCESS
059A  0E00     MOVLW 0x0
059C  6E1C     MOVWF flag, ACCESS
059E  0EEF     MOVLW 0xEF
05A0  6E1D     MOVWF val, ACCESS
05A2  0E00     MOVLW 0x0
05A4  6E1E     MOVWF 0x1E, ACCESS
05A6  EC4E     CALL 0xE9C, 0
05A8  F007     NOP
167:                           __delay_ms(DELAY);
05AA  0E05     MOVLW 0x5
05AC  6E34     MOVWF 0x34, ACCESS
05AE  0E0F     MOVLW 0xF
05B0  6E33     MOVWF 0x33, ACCESS
05B2  0EF1     MOVLW 0xF1
05B4  2EE8     DECFSZ WREG, F, ACCESS
05B6  D7FE     BRA 0x5B4
05B8  2E33     DECFSZ 0x33, F, ACCESS
05BA  D7FC     BRA 0x5B4
05BC  2E34     DECFSZ 0x34, F, ACCESS
05BE  D7FA     BRA 0x5B4
05C0  D06E     BRA 0x69E
168:                           
169:                       } else { //either forwards or signal lost
170:                           if ((Values.left > 199) | (Values.right > 199)) {
05C2  0100     MOVLB 0x0
05C4  51DF     MOVF 0xDF, W, BANKED
05C6  E10A     BNZ 0x5DC
05C8  0EC8     MOVLW 0xC8
05CA  5DDE     SUBWF Values, W, BANKED
05CC  B0D8     BTFSC STATUS, 0, ACCESS
05CE  D006     BRA 0x5DC
05D0  51E1     MOVF 0xE1, W, BANKED
05D2  E104     BNZ 0x5DC
05D4  0EC8     MOVLW 0xC8
05D6  5DE0     SUBWF 0xE0, W, BANKED
05D8  A0D8     BTFSS STATUS, 0, ACCESS
05DA  D037     BRA 0x64A
171:                               if (direction != 3) {
05DC  0E03     MOVLW 0x3
05DE  19DB     XORWF direction, W, BANKED
05E0  11DC     IORWF 0xDC, W, BANKED
05E2  B4D8     BTFSC STATUS, 2, ACCESS
05E4  D00A     BRA 0x5FA
172:                                   stop(&mL, &mR);
05E6  0EE6     MOVLW 0xE6
05E8  6E1B     MOVWF mL, ACCESS
05EA  0E00     MOVLW 0x0
05EC  6E1C     MOVWF flag, ACCESS
05EE  0EEF     MOVLW 0xEF
05F0  6E1D     MOVWF val, ACCESS
05F2  0E00     MOVLW 0x0
05F4  6E1E     MOVWF 0x1E, ACCESS
05F6  EC36     CALL 0x126C, 0
05F8  F009     NOP
173:                               }
174:           //                    stop(&mL, &mR);
175:                               
176:                               direction = 3;
05FA  0E00     MOVLW 0x0
05FC  0100     MOVLB 0x0
05FE  6FDC     MOVWF 0xDC, BANKED
0600  0E03     MOVLW 0x3
0602  6FDB     MOVWF direction, BANKED
177:                               counter++;
0604  2BDD     INCF counter, F, BANKED
178:                               forwardsDirection[counter] = direction;
0606  51DD     MOVF counter, W, BANKED
0608  0D02     MULLW 0x2
060A  0E60     MOVLW 0x60
060C  24F3     ADDWF PROD, W, ACCESS
060E  6ED9     MOVWF FSR2, ACCESS
0610  0E00     MOVLW 0x0
0612  20F4     ADDWFC PRODH, W, ACCESS
0614  6EDA     MOVWF FSR2H, ACCESS
0616  C0DB     MOVFF direction, POSTINC2
0618  FFDE     NOP
061A  C0DC     MOVFF 0xDC, POSTDEC2
061C  FFDD     NOP
179:                               forwards(&mL, &mR);
061E  0EE6     MOVLW 0xE6
0620  6E1B     MOVWF mL, ACCESS
0622  0E00     MOVLW 0x0
0624  6E1C     MOVWF flag, ACCESS
0626  0EEF     MOVLW 0xEF
0628  6E1D     MOVWF val, ACCESS
062A  0E00     MOVLW 0x0
062C  6E1E     MOVWF 0x1E, ACCESS
062E  ECE4     CALL 0xFC8, 0
0630  F007     NOP
180:                               __delay_ms(DELAY);
0632  0E05     MOVLW 0x5
0634  6E34     MOVWF 0x34, ACCESS
0636  0E0F     MOVLW 0xF
0638  6E33     MOVWF 0x33, ACCESS
063A  0EF1     MOVLW 0xF1
063C  2EE8     DECFSZ WREG, F, ACCESS
063E  D7FE     BRA 0x63C
0640  2E33     DECFSZ 0x33, F, ACCESS
0642  D7FC     BRA 0x63C
0644  2E34     DECFSZ 0x34, F, ACCESS
0646  D7FA     BRA 0x63C
0648  D02A     BRA 0x69E
181:           
182:                           } else {
183:                               if (direction != 2) {
064A  0E02     MOVLW 0x2
064C  0100     MOVLB 0x0
064E  19DB     XORWF direction, W, BANKED
0650  11DC     IORWF 0xDC, W, BANKED
0652  B4D8     BTFSC STATUS, 2, ACCESS
0654  D00A     BRA 0x66A
184:                                   stop(&mL, &mR);
0656  0EE6     MOVLW 0xE6
0658  6E1B     MOVWF mL, ACCESS
065A  0E00     MOVLW 0x0
065C  6E1C     MOVWF flag, ACCESS
065E  0EEF     MOVLW 0xEF
0660  6E1D     MOVWF val, ACCESS
0662  0E00     MOVLW 0x0
0664  6E1E     MOVWF 0x1E, ACCESS
0666  EC36     CALL 0x126C, 0
0668  F009     NOP
185:                               }
186:           //                    stop(&mL, &mR);
187:                               
188:                               direction = 2;
066A  0E00     MOVLW 0x0
066C  0100     MOVLB 0x0
066E  6FDC     MOVWF 0xDC, BANKED
0670  0E02     MOVLW 0x2
0672  6FDB     MOVWF direction, BANKED
189:           //                    counter++;
190:           //                    forwardsDirection[counter] = direction;
191:                               turnRight(&mL, &mR);
0674  0EE6     MOVLW 0xE6
0676  6E1B     MOVWF mL, ACCESS
0678  0E00     MOVLW 0x0
067A  6E1C     MOVWF flag, ACCESS
067C  0EEF     MOVLW 0xEF
067E  6E1D     MOVWF val, ACCESS
0680  0E00     MOVLW 0x0
0682  6E1E     MOVWF 0x1E, ACCESS
0684  EC4E     CALL 0xE9C, 0
0686  F007     NOP
192:                               __delay_ms(DELAY);
0688  0E05     MOVLW 0x5
068A  6E34     MOVWF 0x34, ACCESS
068C  0E0F     MOVLW 0xF
068E  6E33     MOVWF 0x33, ACCESS
0690  0EF1     MOVLW 0xF1
0692  2EE8     DECFSZ WREG, F, ACCESS
0694  D7FE     BRA 0x692
0696  2E33     DECFSZ 0x33, F, ACCESS
0698  D7FC     BRA 0x692
069A  2E34     DECFSZ 0x34, F, ACCESS
069C  D7FA     BRA 0x692
069E  F000     NOP
193:           
194:           
195:           
196:                           }
06A0  0100     MOVLB 0x0
06A2  51F8     MOVF card_read, W, BANKED
06A4  A4D8     BTFSS STATUS, 2, ACCESS
06A6  D0BF     BRA 0x826
06A8  D6CD     BRA 0x444
197:                       }
198:                   }
199:           
200:           
201:           
202:           
203:           
204:                   while (card_read == 1) { //the interrupt for the RFID tag sets card_read to 1 when the card is read
205:                       stop(&mL, &mR);
06AA  0EE6     MOVLW 0xE6
06AC  6E1B     MOVWF mL, ACCESS
06AE  0E00     MOVLW 0x0
06B0  6E1C     MOVWF flag, ACCESS
06B2  0EEF     MOVLW 0xEF
06B4  6E1D     MOVWF val, ACCESS
06B6  0E00     MOVLW 0x0
06B8  6E1E     MOVWF 0x1E, ACCESS
06BA  EC36     CALL 0x126C, 0
06BC  F009     NOP
206:                       //            counter = reverse_routine(&forwardsDirection[counter], &forwardsTime[counter], direction, counter);
207:                 
208:                       print_RFID(&string_rfid[0], &string_rfid[0]); //sends the significant characters read from the RFID to the LCD
06BE  0E3C     MOVLW 0x3C
06C0  6E0B     MOVWF pa, ACCESS
06C2  0E00     MOVLW 0x0
06C4  6E0C     MOVWF counter, ACCESS
06C6  0E3C     MOVLW 0x3C
06C8  6E0D     MOVWF dividend, ACCESS
06CA  0E00     MOVLW 0x0
06CC  6E0E     MOVWF divisor, ACCESS
06CE  ECBC     CALL 0x1178, 0
06D0  F008     NOP
209:                       __delay_ms(10);
06D2  0E1A     MOVLW 0x1A
06D4  6E33     MOVWF 0x33, ACCESS
06D6  0EF8     MOVLW 0xF8
06D8  2EE8     DECFSZ WREG, F, ACCESS
06DA  D7FE     BRA 0x6D8
06DC  2E33     DECFSZ 0x33, F, ACCESS
06DE  D7FC     BRA 0x6D8
06E0  D000     BRA 0x6E2
210:           
211:                       //        while (((TMR0H << 8) | TMR0L) <= forwardsTime[counter]) {      
212:                       for (char ii = 0; ii < counter; ii++) {
06E2  0E00     MOVLW 0x0
06E4  0100     MOVLB 0x0
06E6  6FDA     MOVWF ii, BANKED
06E8  D08E     BRA 0x806
0802  0100     MOVLB 0x0
0804  2BDA     INCF ii, F, BANKED
0806  51DD     MOVF counter, W, BANKED
0808  5DDA     SUBWF ii, W, BANKED
080A  A0D8     BTFSS STATUS, 0, ACCESS
080C  D76E     BRA 0x6EA
213:           
214:                           //                TMR0H = 0;
215:                           //                TMR0L = 0;
216:                           if (forwardsDirection[counter - ii] == 1) {
06EA  51DA     MOVF ii, W, BANKED
06EC  6E33     MOVWF 0x33, ACCESS
06EE  6A34     CLRF 0x34, ACCESS
06F0  1E33     COMF 0x33, F, ACCESS
06F2  1E34     COMF 0x34, F, ACCESS
06F4  4A33     INFSNZ 0x33, F, ACCESS
06F6  2A34     INCF 0x34, F, ACCESS
06F8  51DD     MOVF counter, W, BANKED
06FA  6E35     MOVWF 0x35, ACCESS
06FC  6A36     CLRF 0x36, ACCESS
06FE  5033     MOVF 0x33, W, ACCESS
0700  2635     ADDWF 0x35, F, ACCESS
0702  5034     MOVF 0x34, W, ACCESS
0704  2236     ADDWFC 0x36, F, ACCESS
0706  90D8     BCF STATUS, 0, ACCESS
0708  3635     RLCF 0x35, F, ACCESS
070A  3636     RLCF 0x36, F, ACCESS
070C  0E60     MOVLW 0x60
070E  2435     ADDWF 0x35, W, ACCESS
0710  6ED9     MOVWF FSR2, ACCESS
0712  0E00     MOVLW 0x0
0714  2036     ADDWFC 0x36, W, ACCESS
0716  6EDA     MOVWF FSR2H, ACCESS
0718  04DE     DECF POSTINC2, W, ACCESS
071A  10DE     IORWF POSTINC2, W, ACCESS
071C  A4D8     BTFSS STATUS, 2, ACCESS
071E  D00B     BRA 0x736
217:                               turnRight(&mL, &mR);
0720  0EE6     MOVLW 0xE6
0722  6E1B     MOVWF mL, ACCESS
0724  0E00     MOVLW 0x0
0726  6E1C     MOVWF flag, ACCESS
0728  0EEF     MOVLW 0xEF
072A  6E1D     MOVWF val, ACCESS
072C  0E00     MOVLW 0x0
072E  6E1E     MOVWF 0x1E, ACCESS
0730  EC4E     CALL 0xE9C, 0
0732  F007     NOP
218:                           } else if (forwardsDirection[counter - ii] == 2) {
0734  D05A     BRA 0x7EA
0736  0100     MOVLB 0x0
0738  51DA     MOVF ii, W, BANKED
073A  6E33     MOVWF 0x33, ACCESS
073C  6A34     CLRF 0x34, ACCESS
073E  1E33     COMF 0x33, F, ACCESS
0740  1E34     COMF 0x34, F, ACCESS
0742  4A33     INFSNZ 0x33, F, ACCESS
0744  2A34     INCF 0x34, F, ACCESS
0746  51DD     MOVF counter, W, BANKED
0748  6E35     MOVWF 0x35, ACCESS
074A  6A36     CLRF 0x36, ACCESS
074C  5033     MOVF 0x33, W, ACCESS
074E  2635     ADDWF 0x35, F, ACCESS
0750  5034     MOVF 0x34, W, ACCESS
0752  2236     ADDWFC 0x36, F, ACCESS
0754  90D8     BCF STATUS, 0, ACCESS
0756  3635     RLCF 0x35, F, ACCESS
0758  3636     RLCF 0x36, F, ACCESS
075A  0E60     MOVLW 0x60
075C  2435     ADDWF 0x35, W, ACCESS
075E  6ED9     MOVWF FSR2, ACCESS
0760  0E00     MOVLW 0x0
0762  2036     ADDWFC 0x36, W, ACCESS
0764  6EDA     MOVWF FSR2H, ACCESS
0766  0E02     MOVLW 0x2
0768  18DE     XORWF POSTINC2, W, ACCESS
076A  10DE     IORWF POSTINC2, W, ACCESS
076C  A4D8     BTFSS STATUS, 2, ACCESS
076E  D00B     BRA 0x786
219:                               turnLeft(&mL, &mR);
0770  0EE6     MOVLW 0xE6
0772  6E1B     MOVWF mL, ACCESS
0774  0E00     MOVLW 0x0
0776  6E1C     MOVWF flag, ACCESS
0778  0EEF     MOVLW 0xEF
077A  6E1D     MOVWF val, ACCESS
077C  0E00     MOVLW 0x0
077E  6E1E     MOVWF 0x1E, ACCESS
0780  EC99     CALL 0xF32, 0
0782  F007     NOP
220:                           } else if (forwardsDirection[counter - ii] == 3) {
0784  D032     BRA 0x7EA
0786  0100     MOVLB 0x0
0788  51DA     MOVF ii, W, BANKED
078A  6E33     MOVWF 0x33, ACCESS
078C  6A34     CLRF 0x34, ACCESS
078E  1E33     COMF 0x33, F, ACCESS
0790  1E34     COMF 0x34, F, ACCESS
0792  4A33     INFSNZ 0x33, F, ACCESS
0794  2A34     INCF 0x34, F, ACCESS
0796  51DD     MOVF counter, W, BANKED
0798  6E35     MOVWF 0x35, ACCESS
079A  6A36     CLRF 0x36, ACCESS
079C  5033     MOVF 0x33, W, ACCESS
079E  2635     ADDWF 0x35, F, ACCESS
07A0  5034     MOVF 0x34, W, ACCESS
07A2  2236     ADDWFC 0x36, F, ACCESS
07A4  90D8     BCF STATUS, 0, ACCESS
07A6  3635     RLCF 0x35, F, ACCESS
07A8  3636     RLCF 0x36, F, ACCESS
07AA  0E60     MOVLW 0x60
07AC  2435     ADDWF 0x35, W, ACCESS
07AE  6ED9     MOVWF FSR2, ACCESS
07B0  0E00     MOVLW 0x0
07B2  2036     ADDWFC 0x36, W, ACCESS
07B4  6EDA     MOVWF FSR2H, ACCESS
07B6  0E03     MOVLW 0x3
07B8  18DE     XORWF POSTINC2, W, ACCESS
07BA  10DE     IORWF POSTINC2, W, ACCESS
07BC  A4D8     BTFSS STATUS, 2, ACCESS
07BE  D00B     BRA 0x7D6
221:                               backwards(&mL, &mR);
07C0  0EE6     MOVLW 0xE6
07C2  6E1B     MOVWF mL, ACCESS
07C4  0E00     MOVLW 0x0
07C6  6E1C     MOVWF flag, ACCESS
07C8  0EEF     MOVLW 0xEF
07CA  6E1D     MOVWF val, ACCESS
07CC  0E00     MOVLW 0x0
07CE  6E1E     MOVWF 0x1E, ACCESS
07D0  EC2F     CALL 0x105E, 0
07D2  F008     NOP
222:                           } else {
07D4  D00A     BRA 0x7EA
223:                               stop(&mL, &mR);
07D6  0EE6     MOVLW 0xE6
07D8  6E1B     MOVWF mL, ACCESS
07DA  0E00     MOVLW 0x0
07DC  6E1C     MOVWF flag, ACCESS
07DE  0EEF     MOVLW 0xEF
07E0  6E1D     MOVWF val, ACCESS
07E2  0E00     MOVLW 0x0
07E4  6E1E     MOVWF 0x1E, ACCESS
07E6  EC36     CALL 0x126C, 0
07E8  F009     NOP
224:                           }
225:           
226:           
227:                           __delay_ms(DELAY);
07EA  0E05     MOVLW 0x5
07EC  6E34     MOVWF 0x34, ACCESS
07EE  0E0F     MOVLW 0xF
07F0  6E33     MOVWF 0x33, ACCESS
07F2  0EF1     MOVLW 0xF1
07F4  2EE8     DECFSZ WREG, F, ACCESS
07F6  D7FE     BRA 0x7F4
07F8  2E33     DECFSZ 0x33, F, ACCESS
07FA  D7FC     BRA 0x7F4
07FC  2E34     DECFSZ 0x34, F, ACCESS
07FE  D7FA     BRA 0x7F4
0800  F000     NOP
228:           //                 stop(&mL, &mR);
229:                           
230:           
231:                       }
232:                       card_read = 3;
080E  0E03     MOVLW 0x3
0810  6FF8     MOVWF card_read, BANKED
233:                       stop(&mL, &mR);
0812  0EE6     MOVLW 0xE6
0814  6E1B     MOVWF mL, ACCESS
0816  0E00     MOVLW 0x0
0818  6E1C     MOVWF flag, ACCESS
081A  0EEF     MOVLW 0xEF
081C  6E1D     MOVWF val, ACCESS
081E  0E00     MOVLW 0x0
0820  6E1E     MOVWF 0x1E, ACCESS
0822  EC36     CALL 0x126C, 0
0824  F009     NOP
234:           
235:           
236:                   }
0826  0100     MOVLB 0x0
0828  05F8     DECF card_read, W, BANKED
082A  A4D8     BTFSS STATUS, 2, ACCESS
082C  D601     BRA 0x430
082E  D73D     BRA 0x6AA
237:                   //            
238:                   //        }
239:                   //        while (card_read == 2) {
240:                   //        
241:                   //            //            }
242:                   //            LCD_clear();
243:                   //            char buf[16];
244:                   //            LCD_line(1);
245:                   //            sprintf(buf, "Ready");
246:                   //            LCD_string(buf);
247:                   //            __delay_ms(50);
248:                   //        }
249:           
250:                   //            return 0;
251:           
252:               }
253:           }
254:           
255:           
256:           
257:           
258:           
259:           
260:           
261:           
262:           
---  /Users/hasan/Box Sync/me4/ecm/lcd.c  ---------------------------------------------------------------
1:             #include "lcd.h"
2:             
3:             /*To toggle enable bit on then off*/
4:             void E_TOG(void) {
5:                 PORTCbits.RC0 = 1;
14B6  8082     BSF PORTC, 0, ACCESS
6:                 __delay_us(5);
14B8  0E03     MOVLW 0x3
14BA  2EE8     DECFSZ WREG, F, ACCESS
14BC  D7FE     BRA 0x14BA
14BE  F000     NOP
7:                 PORTCbits.RC0 = 0;
14C0  9082     BCF PORTC, 0, ACCESS
8:                 __delay_us(5);
14C2  0E03     MOVLW 0x3
14C4  2EE8     DECFSZ WREG, F, ACCESS
14C6  D7FE     BRA 0x14C4
14C8  F000     NOP
9:             }
0008  824D     BSF btemp, 1, ACCESS
14CA  0012     RETURN 0
10:            
11:            /*remake*/
12:            void time(int t) {
13:                for (int k = 0; k < t; k++) {
14:                    __delay_ms(90);
15:                }
16:            }
17:            
18:            /*To create 4-bit data stream to the LCD*/
19:            void LCD_out(unsigned char number)
11F4  6E07     MOVWF number, ACCESS
20:             {
21:            
22:                PORTCbits.RC1 = (number & 0b0001);
11F6  C007     MOVFF number, Values
11F8  F006     NOP
11FA  0E01     MOVLW 0x1
11FC  1606     ANDWF Values, F, ACCESS
11FE  4606     RLNCF Values, F, ACCESS
1200  5082     MOVF PORTC, W, ACCESS
1202  1806     XORWF Values, W, ACCESS
1204  0BFD     ANDLW 0xFD
1206  1806     XORWF Values, W, ACCESS
1208  6E82     MOVWF PORTC, ACCESS
23:                PORTCbits.RC2 = (number & 0b0010) >> 1;
120A  C007     MOVFF number, Values
120C  F006     NOP
120E  90D8     BCF STATUS, 0, ACCESS
1210  3206     RRCF Values, F, ACCESS
1212  0E01     MOVLW 0x1
1214  1606     ANDWF Values, F, ACCESS
1216  4606     RLNCF Values, F, ACCESS
1218  4606     RLNCF Values, F, ACCESS
121A  5082     MOVF PORTC, W, ACCESS
121C  1806     XORWF Values, W, ACCESS
121E  0BFB     ANDLW 0xFB
1220  1806     XORWF Values, W, ACCESS
1222  6E82     MOVWF PORTC, ACCESS
24:                PORTDbits.RD0 = (number & 0b0100) >> 2;
1224  C007     MOVFF number, Values
1226  F006     NOP
1228  90D8     BCF STATUS, 0, ACCESS
122A  3206     RRCF Values, F, ACCESS
122C  90D8     BCF STATUS, 0, ACCESS
122E  3206     RRCF Values, F, ACCESS
1230  0E01     MOVLW 0x1
1232  1606     ANDWF Values, F, ACCESS
1234  5083     MOVF PORTD, W, ACCESS
1236  1806     XORWF Values, W, ACCESS
1238  0BFE     ANDLW 0xFE
123A  1806     XORWF Values, W, ACCESS
123C  6E83     MOVWF PORTD, ACCESS
25:                PORTDbits.RD1 = (number & 0b1000) >> 3;
123E  C007     MOVFF number, Values
1240  F006     NOP
1242  90D8     BCF STATUS, 0, ACCESS
1244  3206     RRCF Values, F, ACCESS
1246  90D8     BCF STATUS, 0, ACCESS
1248  3206     RRCF Values, F, ACCESS
124A  90D8     BCF STATUS, 0, ACCESS
124C  3206     RRCF Values, F, ACCESS
124E  0E01     MOVLW 0x1
1250  1606     ANDWF Values, F, ACCESS
1252  4606     RLNCF Values, F, ACCESS
1254  5083     MOVF PORTD, W, ACCESS
1256  1806     XORWF Values, W, ACCESS
1258  0BFD     ANDLW 0xFD
125A  1806     XORWF Values, W, ACCESS
125C  6E83     MOVWF PORTD, ACCESS
26:                //toggle the enable bit to send data
27:                E_TOG();
125E  EC5B     CALL 0x14B6, 0
1260  F00A     NOP
28:                __delay_us(5);
1262  0E03     MOVLW 0x3
1264  2EE8     DECFSZ WREG, F, ACCESS
1266  D7FE     BRA 0x1264
1268  F000     NOP
29:            }
126A  0012     RETURN 0
30:            
31:            /*
32:             * function to send data over 4 bit interface
33:             */
34:            void LCD_send(unsigned char Byte, char type) {
13BE  6E09     MOVWF Byte, ACCESS
35:                // set RS pin whether it is a Command (0) or Data/Char (1)
36:                // using type as the argument
37:                /*TODO needs to be redone, no need for command anymore*/
38:                PORTAbits.RA6 = type;
13C0  B008     BTFSC type, 0, ACCESS
13C2  D002     BRA 0x13C8
13C4  9C80     BCF PORTA, 6, ACCESS
13C6  D001     BRA 0x13CA
13C8  8C80     BSF PORTA, 6, ACCESS
39:            
40:                // send high bits of Byte using LCDout function
41:                LCD_out(Byte >> 4);
13CA  3809     SWAPF Byte, W, ACCESS
13CC  0B0F     ANDLW 0xF
13CE  ECFA     CALL 0x11F4, 0
13D0  F008     NOP
42:                __delay_us(10); //10us delay
13D2  0E06     MOVLW 0x6
13D4  2EE8     DECFSZ WREG, F, ACCESS
13D6  D7FE     BRA 0x13D4
13D8  D000     BRA 0x13DA
43:                // send low bits of Byte using LCDout function
44:                LCD_out(Byte);
13DA  5009     MOVF Byte, W, ACCESS
13DC  ECFA     CALL 0x11F4, 0
13DE  F008     NOP
45:                __delay_us(50);
13E0  0E21     MOVLW 0x21
13E2  2EE8     DECFSZ WREG, F, ACCESS
13E4  D7FE     BRA 0x13E2
13E6  F000     NOP
46:            
47:            }
13E8  0012     RETURN 0
48:            
49:            void LCD_init(void) {
50:            
51:                /* Configuring the outputs, else unknown*/
52:                LATA = 0;
0D04  0E00     MOVLW 0x0
0D06  6E89     MOVWF LATA, ACCESS
53:                LATC = 0;
0D08  0E00     MOVLW 0x0
0D0A  6E8B     MOVWF LATC, ACCESS
54:                LATD = 0;
0D0C  0E00     MOVLW 0x0
0D0E  6E8C     MOVWF LATD, ACCESS
55:            
56:                /*Initialise pins for LCD from PIC, TODO redo and move LCD*/
57:                TRISA = 0;
0D10  0E00     MOVLW 0x0
0D12  6E92     MOVWF TRISA, ACCESS
58:                TRISC = 0; //set the data direction registers to output on all pins
0D14  0E00     MOVLW 0x0
0D16  6E94     MOVWF TRISC, ACCESS
59:                TRISD = 0;
0D18  0E00     MOVLW 0x0
0D1A  6E95     MOVWF TRISD, ACCESS
60:            
61:            
62:                /*Initialisation sequence, page TODO of datasheet*/
63:                __delay_ms(15);
0D1C  0E27     MOVLW 0x27
0D1E  6E0A     MOVWF string, ACCESS
0D20  0EF5     MOVLW 0xF5
0D22  2EE8     DECFSZ WREG, F, ACCESS
0D24  D7FE     BRA 0xD22
0D26  2E0A     DECFSZ string, F, ACCESS
0D28  D7FC     BRA 0xD22
0D2A  F000     NOP
64:                LCD_out(0b0011);
0D2C  0E03     MOVLW 0x3
0D2E  ECFA     CALL 0x11F4, 0
0D30  F008     NOP
65:                __delay_ms(5);
0D32  0E0D     MOVLW 0xD
0D34  6E0A     MOVWF string, ACCESS
0D36  0EFC     MOVLW 0xFC
0D38  2EE8     DECFSZ WREG, F, ACCESS
0D3A  D7FE     BRA 0xD38
0D3C  2E0A     DECFSZ string, F, ACCESS
0D3E  D7FC     BRA 0xD38
66:                LCD_out(0b0011);
0D40  0E03     MOVLW 0x3
0D42  ECFA     CALL 0x11F4, 0
0D44  F008     NOP
67:                __delay_us(200);
0D46  0E85     MOVLW 0x85
0D48  2EE8     DECFSZ WREG, F, ACCESS
0D4A  D7FE     BRA 0xD48
0D4C  F000     NOP
68:                LCD_out(0b0011);
0D4E  0E03     MOVLW 0x3
0D50  ECFA     CALL 0x11F4, 0
0D52  F008     NOP
69:                __delay_us(50);
0D54  0E21     MOVLW 0x21
0D56  2EE8     DECFSZ WREG, F, ACCESS
0D58  D7FE     BRA 0xD56
0D5A  F000     NOP
70:                LCD_out(0b0010);
0D5C  0E02     MOVLW 0x2
0D5E  ECFA     CALL 0x11F4, 0
0D60  F008     NOP
71:                __delay_us(50);
0D62  0E21     MOVLW 0x21
0D64  2EE8     DECFSZ WREG, F, ACCESS
0D66  D7FE     BRA 0xD64
0D68  F000     NOP
72:            
73:                LCD_send(0b00101000, 0); /*4 bit mode, 2 line, 5 x 7 grid*/
0D6A  0E00     MOVLW 0x0
0D6C  6E08     MOVWF type, ACCESS
0D6E  0E28     MOVLW 0x28
0D70  ECDF     CALL 0x13BE, 0
0D72  F009     NOP
74:                __delay_ms(2);
0D74  0E06     MOVLW 0x6
0D76  6E0A     MOVWF string, ACCESS
0D78  0E30     MOVLW 0x30
0D7A  2EE8     DECFSZ WREG, F, ACCESS
0D7C  D7FE     BRA 0xD7A
0D7E  2E0A     DECFSZ string, F, ACCESS
0D80  D7FC     BRA 0xD7A
0D82  D000     BRA 0xD84
75:                LCD_send(0b00001000, 0);
0D84  0E00     MOVLW 0x0
0D86  6E08     MOVWF type, ACCESS
0D88  0E08     MOVLW 0x8
0D8A  ECDF     CALL 0x13BE, 0
0D8C  F009     NOP
76:                __delay_ms(2);
0D8E  0E06     MOVLW 0x6
0D90  6E0A     MOVWF string, ACCESS
0D92  0E30     MOVLW 0x30
0D94  2EE8     DECFSZ WREG, F, ACCESS
0D96  D7FE     BRA 0xD94
0D98  2E0A     DECFSZ string, F, ACCESS
0D9A  D7FC     BRA 0xD94
0D9C  D000     BRA 0xD9E
77:                LCD_send(0b00000001, 0);
0D9E  0E00     MOVLW 0x0
0DA0  6E08     MOVWF type, ACCESS
0DA2  0E01     MOVLW 0x1
0DA4  ECDF     CALL 0x13BE, 0
0DA6  F009     NOP
78:                __delay_ms(2);
0DA8  0E06     MOVLW 0x6
0DAA  6E0A     MOVWF string, ACCESS
0DAC  0E30     MOVLW 0x30
0DAE  2EE8     DECFSZ WREG, F, ACCESS
0DB0  D7FE     BRA 0xDAE
0DB2  2E0A     DECFSZ string, F, ACCESS
0DB4  D7FC     BRA 0xDAE
0DB6  D000     BRA 0xDB8
79:                LCD_send(0b00000110, 0);
0DB8  0E00     MOVLW 0x0
0DBA  6E08     MOVWF type, ACCESS
0DBC  0E06     MOVLW 0x6
0DBE  ECDF     CALL 0x13BE, 0
0DC0  F009     NOP
80:                __delay_ms(2);
0DC2  0E06     MOVLW 0x6
0DC4  6E0A     MOVWF string, ACCESS
0DC6  0E30     MOVLW 0x30
0DC8  2EE8     DECFSZ WREG, F, ACCESS
0DCA  D7FE     BRA 0xDC8
0DCC  2E0A     DECFSZ string, F, ACCESS
0DCE  D7FC     BRA 0xDC8
0DD0  D000     BRA 0xDD2
81:                LCD_send(0b00001100, 0);
0DD2  0E00     MOVLW 0x0
0DD4  6E08     MOVWF type, ACCESS
0DD6  0E0C     MOVLW 0xC
0DD8  ECDF     CALL 0x13BE, 0
0DDA  F009     NOP
82:                __delay_ms(2);
0DDC  0E06     MOVLW 0x6
0DDE  6E0A     MOVWF string, ACCESS
0DE0  0E30     MOVLW 0x30
0DE2  2EE8     DECFSZ WREG, F, ACCESS
0DE4  D7FE     BRA 0xDE2
0DE6  2E0A     DECFSZ string, F, ACCESS
0DE8  D7FC     BRA 0xDE2
0DEA  D000     BRA 0xDEC
83:            
84:            }
0DEC  0012     RETURN 0
85:            
86:            /*
87:             * To set cursor to correct line (of two)
88:             */
89:            void LCD_line(char line) {
138E  6E0A     MOVWF string, ACCESS
90:                if (line == 1) {
1390  040A     DECF string, W, ACCESS
1392  A4D8     BTFSS STATUS, 2, ACCESS
1394  D006     BRA 0x13A2
91:                    LCD_send(0x80, 0); /*DDRAM address for line 1*/
1396  0E00     MOVLW 0x0
1398  6E08     MOVWF type, ACCESS
139A  0E80     MOVLW 0x80
139C  ECDF     CALL 0x13BE, 0
139E  F009     NOP
92:                } else if (line == 2) {
13A0  D009     BRA 0x13B4
13A2  0E02     MOVLW 0x2
13A4  180A     XORWF string, W, ACCESS
13A6  A4D8     BTFSS STATUS, 2, ACCESS
13A8  D005     BRA 0x13B4
93:                    LCD_send(0xC0, 0);
13AA  0E00     MOVLW 0x0
13AC  6E08     MOVWF type, ACCESS
13AE  0EC0     MOVLW 0xC0
13B0  ECDF     CALL 0x13BE, 0
13B2  F009     NOP
94:                }
95:                __delay_us(50); //50us delay
13B4  0E21     MOVLW 0x21
13B6  2EE8     DECFSZ WREG, F, ACCESS
13B8  D7FE     BRA 0x13B6
13BA  F000     NOP
96:            }
13BC  0012     RETURN 0
97:            
98:            /*
99:             * To print character by character to screen
100:            */
101:           void LCD_string(char *string) {
102:               while (*string != 0) {
135E  D00F     BRA 0x137E
103:                   //Send out the current byte pointed to
104:                   //and increment the pointer
105:                   LCD_send(*string++, 1);
1360  0E01     MOVLW 0x1
1362  6E08     MOVWF type, ACCESS
1364  C00A     MOVFF string, FSR2
1366  FFD9     NOP
1368  C00B     MOVFF pa, FSR2H
136A  FFDA     NOP
136C  50DF     MOVF INDF2, W, ACCESS
136E  ECDF     CALL 0x13BE, 0
1370  F009     NOP
1372  4A0A     INFSNZ string, F, ACCESS
1374  2A0B     INCF pa, F, ACCESS
106:                   __delay_us(50); //so we can see each character
1376  0E21     MOVLW 0x21
1378  2EE8     DECFSZ WREG, F, ACCESS
137A  D7FE     BRA 0x1378
137C  F000     NOP
107:                   //being printed in turn (remove delay if you want
108:                   //your message to appear almost instantly)
109:               }
137E  C00A     MOVFF string, FSR2
1380  FFD9     NOP
1382  C00B     MOVFF pa, FSR2H
1384  FFDA     NOP
1386  50DF     MOVF INDF2, W, ACCESS
1388  B4D8     BTFSC STATUS, 2, ACCESS
138A  0012     RETURN 0
138C  D7E9     BRA 0x1360
110:           }
111:           
112:           /*
113:            * To clear LCD
114:            */
115:           void LCD_clear(void) {
116:               LCD_send(0b00000001, 0);
144C  0E00     MOVLW 0x0
144E  6E08     MOVWF type, ACCESS
1450  0E01     MOVLW 0x1
1452  ECDF     CALL 0x13BE, 0
1454  F009     NOP
117:               __delay_ms(2);
1456  0E06     MOVLW 0x6
1458  6E0A     MOVWF string, ACCESS
145A  0E30     MOVLW 0x30
145C  2EE8     DECFSZ WREG, F, ACCESS
145E  D7FE     BRA 0x145C
1460  2E0A     DECFSZ string, F, ACCESS
1462  D7FC     BRA 0x145C
1464  D000     BRA 0x1466
118:           }
1466  0012     RETURN 0
119:           
120:           /*
121:            * To print IR values to LCD
122:            */
123:           void print_IR(struct Sensor_ir *Values) {
124:               LCD_clear();
0DEE  EC26     CALL 0x144C, 0
0DF0  F00A     NOP
125:               char buf[16];
126:               LCD_line(1);
0DF2  0E01     MOVLW 0x1
0DF4  ECC7     CALL 0x138E, 0
0DF6  F009     NOP
127:               sprintf(buf, "Left: %u", Values->left);
0DF8  0E23     MOVLW 0x23
0DFA  6E12     MOVWF quotient, ACCESS
0DFC  0E00     MOVLW 0x0
0DFE  6E13     MOVWF 0x13, ACCESS
0E00  0E33     MOVLW 0x33
0E02  6E14     MOVWF f, ACCESS
0E04  0E03     MOVLW 0x3
0E06  6E15     MOVWF 0x15, ACCESS
0E08  C020     MOVFF Values, FSR2
0E0A  FFD9     NOP
0E0C  C021     MOVFF 0x21, FSR2H
0E0E  FFDA     NOP
0E10  CFDE     MOVFF POSTINC2, 0x16
0E12  F016     NOP
0E14  CFDD     MOVFF POSTDEC2, 0x17
0E16  F017     NOP
0E18  ECC8     CALL 0xB90, 0
0E1A  F005     NOP
128:               LCD_string(buf);
0E1C  0E23     MOVLW 0x23
0E1E  6E0A     MOVWF string, ACCESS
0E20  0E00     MOVLW 0x0
0E22  6E0B     MOVWF pa, ACCESS
0E24  ECAF     CALL 0x135E, 0
0E26  F009     NOP
129:               LCD_line(2);
0E28  0E02     MOVLW 0x2
0E2A  ECC7     CALL 0x138E, 0
0E2C  F009     NOP
130:               sprintf(buf, "Right: %u", Values->right);
0E2E  0E23     MOVLW 0x23
0E30  6E12     MOVWF quotient, ACCESS
0E32  0E00     MOVLW 0x0
0E34  6E13     MOVWF 0x13, ACCESS
0E36  0E29     MOVLW 0x29
0E38  6E14     MOVWF f, ACCESS
0E3A  0E03     MOVLW 0x3
0E3C  6E15     MOVWF 0x15, ACCESS
0E3E  EE20     LFSR 2, 0x2
0E40  F002     NOP
0E42  5020     MOVF Values, W, ACCESS
0E44  26D9     ADDWF FSR2, F, ACCESS
0E46  5021     MOVF 0x21, W, ACCESS
0E48  22DA     ADDWFC FSR2H, F, ACCESS
0E4A  CFDE     MOVFF POSTINC2, 0x16
0E4C  F016     NOP
0E4E  CFDD     MOVFF POSTDEC2, 0x17
0E50  F017     NOP
0E52  ECC8     CALL 0xB90, 0
0E54  F005     NOP
131:               LCD_string(buf);
0E56  0E23     MOVLW 0x23
0E58  6E0A     MOVWF string, ACCESS
0E5A  0E00     MOVLW 0x0
0E5C  6E0B     MOVWF pa, ACCESS
0E5E  ECAF     CALL 0x135E, 0
0E60  F009     NOP
132:               __delay_ms(50);
0E62  0E82     MOVLW 0x82
0E64  6E22     MOVWF 0x22, ACCESS
0E66  0EDE     MOVLW 0xDE
0E68  2EE8     DECFSZ WREG, F, ACCESS
0E6A  D7FE     BRA 0xE68
0E6C  2E22     DECFSZ 0x22, F, ACCESS
0E6E  D7FC     BRA 0xE68
133:               __delay_ms(50);
0E70  0E82     MOVLW 0x82
0E72  6E22     MOVWF 0x22, ACCESS
0E74  0EDE     MOVLW 0xDE
0E76  2EE8     DECFSZ WREG, F, ACCESS
0E78  D7FE     BRA 0xE76
0E7A  2E22     DECFSZ 0x22, F, ACCESS
0E7C  D7FC     BRA 0xE76
134:               __delay_ms(50);
0E7E  0E82     MOVLW 0x82
0E80  6E22     MOVWF 0x22, ACCESS
0E82  0EDE     MOVLW 0xDE
0E84  2EE8     DECFSZ WREG, F, ACCESS
0E86  D7FE     BRA 0xE84
0E88  2E22     DECFSZ 0x22, F, ACCESS
0E8A  D7FC     BRA 0xE84
135:               __delay_ms(50);
0E8C  0E82     MOVLW 0x82
0E8E  6E22     MOVWF 0x22, ACCESS
0E90  0EDE     MOVLW 0xDE
0E92  2EE8     DECFSZ WREG, F, ACCESS
0E94  D7FE     BRA 0xE92
0E96  2E22     DECFSZ 0x22, F, ACCESS
0E98  D7FC     BRA 0xE92
136:           
137:           }
0E9A  0012     RETURN 0
---  /Users/hasan/Box Sync/me4/ecm/ir.c  ----------------------------------------------------------------
1:             #include "ir.h"
2:             
3:             /*
4:              * Timer 5 for input capture, initialisation
5:              */
6:             void init_TIMER5(void) {
7:                 /*need to reset TMR5
8:                  *see page 139
9:                  */
10:            
11:                T5CON = 0;
1482  0E00     MOVLW 0x0
1484  6EB7     MOVWF T5CON, ACCESS
12:                T5CONbits.T5SEN = 0; /*disable during sleep            */
1486  9EB7     BCF T5CON, 7, ACCESS
13:                T5CONbits.RESEN = 0; /*disable special event trigger   */
1488  9CB7     BCF T5CON, 6, ACCESS
14:                T5CONbits.T5PS = 0b10; /*prescale, unsure TODO           */
148A  50B7     MOVF T5CON, W, ACCESS
148C  0BE7     ANDLW 0xE7
148E  0910     IORLW 0x10
1490  6EB7     MOVWF T5CON, ACCESS
15:                T5CONbits.T5MOD = 0; /*prescale, unsure TODO           */
1492  9AB7     BCF T5CON, 5, ACCESS
16:                T5CONbits.T5SYNC = 0; /*continuous count                */
1494  94B7     BCF T5CON, 2, ACCESS
17:                T5CONbits.TMR5CS = 0; /*internal clock                  */
1496  92B7     BCF T5CON, 1, ACCESS
18:                T5CONbits.TMR5ON = 1; /*turn on                         */
1498  80B7     BSF T5CON, 0, ACCESS
19:            
20:            }
149A  0012     RETURN 0
21:            
22:            /*
23:             * Detect falling edge to rising edge from IR detector
24:             */
25:            void init_capture(void) {
26:            
27:                LATA = 0; //Tensure all pins have same value initially
1468  0E00     MOVLW 0x0
146A  6E89     MOVWF LATA, ACCESS
28:                TRISA = 0b00001100; //Turn on CAP1 (RA2) and CAP2 (RA3) Pins.
146C  0E0C     MOVLW 0xC
146E  6E92     MOVWF TRISA, ACCESS
29:                CAP1CON = 0b01000110; //Time base enabled, measure PWM falling to rising 
1470  0E46     MOVLW 0x46
1472  6E63     MOVWF CAP1CON, ACCESS
30:                CAP2CON = 0b01000110;
1474  0E46     MOVLW 0x46
1476  6E62     MOVWF CAP2CON, ACCESS
31:                T5CON = 0b00001001; //Timer 5 prescaler 1:2, Timer on (overflow 65.536ms - max PWM is 50ms)
1478  0E09     MOVLW 0x9
147A  6EB7     MOVWF T5CON, ACCESS
32:                DFLTCON = 0b00011000; //Noise filter for CAP1 and CAP2 
147C  0E18     MOVLW 0x18
147E  6E60     MOVWF DFLTCON, ACCESS
33:            }
1480  0012     RETURN 0
34:            
35:            /*
36:             * Printing IR signal
37:             */
38:            void read_IR(struct Sensor_ir *Values) {
39:            
40:                Values->left_prev = Values->left;
0830  C006     MOVFF Values, FSR2
0832  FFD9     NOP
0834  C007     MOVFF number, FSR2H
0836  FFDA     NOP
0838  EE10     LFSR 1, 0x4
083A  F004     NOP
083C  5006     MOVF Values, W, ACCESS
083E  26E1     ADDWF FSR1, F, ACCESS
0840  5007     MOVF number, W, ACCESS
0842  22E2     ADDWFC FSR1H, F, ACCESS
0844  CFDE     MOVFF POSTINC2, POSTINC1
0846  FFE6     NOP
0848  CFDD     MOVFF POSTDEC2, POSTDEC1
084A  FFE5     NOP
41:                Values->right_prev = Values->right;
084C  EE20     LFSR 2, 0x2
084E  F002     NOP
0850  5006     MOVF Values, W, ACCESS
0852  26D9     ADDWF FSR2, F, ACCESS
0854  5007     MOVF number, W, ACCESS
0856  22DA     ADDWFC FSR2H, F, ACCESS
0858  EE10     LFSR 1, 0x6
085A  F006     NOP
085C  5006     MOVF Values, W, ACCESS
085E  26E1     ADDWF FSR1, F, ACCESS
0860  5007     MOVF number, W, ACCESS
0862  22E2     ADDWFC FSR1H, F, ACCESS
0864  CFDE     MOVFF POSTINC2, POSTINC1
0866  FFE6     NOP
0868  CFDD     MOVFF POSTDEC2, POSTDEC1
086A  FFE5     NOP
42:                Values->left = ((CAP2BUFH << 8) | (CAP2BUFL)); //left is cap2, i.e. lower
086C  5066     MOVF CAP2BUFL, W, ACCESS
086E  CF67     MOVFF CAP2BUFH, type
0870  F008     NOP
0872  6A09     CLRF Byte, ACCESS
0874  C008     MOVFF type, Byte
0876  F009     NOP
0878  6A08     CLRF type, ACCESS
087A  1208     IORWF type, F, ACCESS
087C  0E00     MOVLW 0x0
087E  1209     IORWF Byte, F, ACCESS
0880  C006     MOVFF Values, FSR2
0882  FFD9     NOP
0884  C007     MOVFF number, FSR2H
0886  FFDA     NOP
0888  C008     MOVFF type, POSTINC2
088A  FFDE     NOP
088C  C009     MOVFF Byte, POSTDEC2
088E  FFDD     NOP
43:                Values->right = ((CAP1BUFH << 8) | (CAP1BUFL));
0890  5068     MOVF CAP1BUFL, W, ACCESS
0892  CF69     MOVFF CAP1BUFH, type
0894  F008     NOP
0896  6A09     CLRF Byte, ACCESS
0898  C008     MOVFF type, Byte
089A  F009     NOP
089C  6A08     CLRF type, ACCESS
089E  1208     IORWF type, F, ACCESS
08A0  0E00     MOVLW 0x0
08A2  1209     IORWF Byte, F, ACCESS
08A4  EE20     LFSR 2, 0x2
08A6  F002     NOP
08A8  5006     MOVF Values, W, ACCESS
08AA  26D9     ADDWF FSR2, F, ACCESS
08AC  5007     MOVF number, W, ACCESS
08AE  22DA     ADDWFC FSR2H, F, ACCESS
08B0  C008     MOVFF type, POSTINC2
08B2  FFDE     NOP
08B4  C009     MOVFF Byte, POSTDEC2
08B6  FFDD     NOP
44:            
45:                if ((Values->left == Values->left_prev) && (Values->left <= 200)) {
08B8  EE20     LFSR 2, 0x4
08BA  F004     NOP
08BC  5006     MOVF Values, W, ACCESS
08BE  26D9     ADDWF FSR2, F, ACCESS
08C0  5007     MOVF number, W, ACCESS
08C2  22DA     ADDWFC FSR2H, F, ACCESS
08C4  C006     MOVFF Values, FSR1
08C6  FFE1     NOP
08C8  C007     MOVFF number, FSR1H
08CA  FFE2     NOP
08CC  50DE     MOVF POSTINC2, W, ACCESS
08CE  18E6     XORWF POSTINC1, W, ACCESS
08D0  E117     BNZ 0x900
08D2  50DE     MOVF POSTINC2, W, ACCESS
08D4  18E6     XORWF POSTINC1, W, ACCESS
08D6  A4D8     BTFSS STATUS, 2, ACCESS
08D8  D013     BRA 0x900
08DA  C006     MOVFF Values, FSR2
08DC  FFD9     NOP
08DE  C007     MOVFF number, FSR2H
08E0  FFDA     NOP
08E2  0E01     MOVLW 0x1
08E4  50DB     MOVF PLUSW2, W, ACCESS
08E6  E10C     BNZ 0x900
08E8  0EC9     MOVLW 0xC9
08EA  5CDE     SUBWF POSTINC2, W, ACCESS
08EC  B0D8     BTFSC STATUS, 0, ACCESS
08EE  D008     BRA 0x900
46:                    Values->left = 0;
08F0  C006     MOVFF Values, FSR2
08F2  FFD9     NOP
08F4  C007     MOVFF number, FSR2H
08F6  FFDA     NOP
08F8  0E00     MOVLW 0x0
08FA  6EDE     MOVWF POSTINC2, ACCESS
08FC  0E00     MOVLW 0x0
08FE  6EDD     MOVWF POSTDEC2, ACCESS
47:                }
48:            
49:                if ((Values->right == Values->right_prev) && (Values->right <= 200)) {
0900  EE20     LFSR 2, 0x6
0902  F006     NOP
0904  5006     MOVF Values, W, ACCESS
0906  26D9     ADDWF FSR2, F, ACCESS
0908  5007     MOVF number, W, ACCESS
090A  22DA     ADDWFC FSR2H, F, ACCESS
090C  EE10     LFSR 1, 0x2
090E  F002     NOP
0910  5006     MOVF Values, W, ACCESS
0912  26E1     ADDWF FSR1, F, ACCESS
0914  5007     MOVF number, W, ACCESS
0916  22E2     ADDWFC FSR1H, F, ACCESS
0918  50DE     MOVF POSTINC2, W, ACCESS
091A  18E6     XORWF POSTINC1, W, ACCESS
091C  E11B     BNZ 0x954
091E  50DE     MOVF POSTINC2, W, ACCESS
0920  18E6     XORWF POSTINC1, W, ACCESS
0922  A4D8     BTFSS STATUS, 2, ACCESS
0924  D017     BRA 0x954
0926  EE20     LFSR 2, 0x2
0928  F002     NOP
092A  5006     MOVF Values, W, ACCESS
092C  26D9     ADDWF FSR2, F, ACCESS
092E  5007     MOVF number, W, ACCESS
0930  22DA     ADDWFC FSR2H, F, ACCESS
0932  0E01     MOVLW 0x1
0934  50DB     MOVF PLUSW2, W, ACCESS
0936  E10E     BNZ 0x954
0938  0EC9     MOVLW 0xC9
093A  5CDE     SUBWF POSTINC2, W, ACCESS
093C  B0D8     BTFSC STATUS, 0, ACCESS
093E  D00A     BRA 0x954
50:                    Values->right = 0;
0940  EE20     LFSR 2, 0x2
0942  F002     NOP
0944  5006     MOVF Values, W, ACCESS
0946  26D9     ADDWF FSR2, F, ACCESS
0948  5007     MOVF number, W, ACCESS
094A  22DA     ADDWFC FSR2H, F, ACCESS
094C  0E00     MOVLW 0x0
094E  6EDE     MOVWF POSTINC2, ACCESS
0950  0E00     MOVLW 0x0
0952  6EDD     MOVWF POSTDEC2, ACCESS
51:                }
52:            
53:                Values->left = Values->left / 64;
0954  C006     MOVFF Values, FSR2
0956  FFD9     NOP
0958  C007     MOVFF number, FSR2H
095A  FFDA     NOP
095C  CFDE     MOVFF POSTINC2, type
095E  F008     NOP
0960  CFDD     MOVFF POSTDEC2, Byte
0962  F009     NOP
0964  0E06     MOVLW 0x6
0966  6E0A     MOVWF string, ACCESS
0968  90D8     BCF STATUS, 0, ACCESS
096A  3209     RRCF Byte, F, ACCESS
096C  3208     RRCF type, F, ACCESS
096E  2E0A     DECFSZ string, F, ACCESS
0970  D7FB     BRA 0x968
0972  C006     MOVFF Values, FSR2
0974  FFD9     NOP
0976  C007     MOVFF number, FSR2H
0978  FFDA     NOP
097A  C008     MOVFF type, POSTINC2
097C  FFDE     NOP
097E  C009     MOVFF Byte, POSTDEC2
0980  FFDD     NOP
54:                if (Values->left > 200) {
0982  C006     MOVFF Values, FSR2
0984  FFD9     NOP
0986  C007     MOVFF number, FSR2H
0988  FFDA     NOP
098A  0E01     MOVLW 0x1
098C  50DB     MOVF PLUSW2, W, ACCESS
098E  E104     BNZ 0x998
0990  0EC9     MOVLW 0xC9
0992  5CDE     SUBWF POSTINC2, W, ACCESS
0994  A0D8     BTFSS STATUS, 0, ACCESS
0996  D008     BRA 0x9A8
55:                    Values->left = 200;
0998  C006     MOVFF Values, FSR2
099A  FFD9     NOP
099C  C007     MOVFF number, FSR2H
099E  FFDA     NOP
09A0  0EC8     MOVLW 0xC8
09A2  6EDE     MOVWF POSTINC2, ACCESS
09A4  0E00     MOVLW 0x0
09A6  6EDD     MOVWF POSTDEC2, ACCESS
56:                } //reduce un-required noise above 200
57:            
58:                Values->right = Values->right / 64;
09A8  EE20     LFSR 2, 0x2
09AA  F002     NOP
09AC  5006     MOVF Values, W, ACCESS
09AE  26D9     ADDWF FSR2, F, ACCESS
09B0  5007     MOVF number, W, ACCESS
09B2  22DA     ADDWFC FSR2H, F, ACCESS
09B4  CFDE     MOVFF POSTINC2, type
09B6  F008     NOP
09B8  CFDD     MOVFF POSTDEC2, Byte
09BA  F009     NOP
09BC  0E06     MOVLW 0x6
09BE  6E0A     MOVWF string, ACCESS
09C0  90D8     BCF STATUS, 0, ACCESS
09C2  3209     RRCF Byte, F, ACCESS
09C4  3208     RRCF type, F, ACCESS
09C6  2E0A     DECFSZ string, F, ACCESS
09C8  D7FB     BRA 0x9C0
09CA  EE20     LFSR 2, 0x2
09CC  F002     NOP
09CE  5006     MOVF Values, W, ACCESS
09D0  26D9     ADDWF FSR2, F, ACCESS
09D2  5007     MOVF number, W, ACCESS
09D4  22DA     ADDWFC FSR2H, F, ACCESS
09D6  C008     MOVFF type, POSTINC2
09D8  FFDE     NOP
09DA  C009     MOVFF Byte, POSTDEC2
09DC  FFDD     NOP
59:                if (Values->right > 200) {
09DE  EE20     LFSR 2, 0x2
09E0  F002     NOP
09E2  5006     MOVF Values, W, ACCESS
09E4  26D9     ADDWF FSR2, F, ACCESS
09E6  5007     MOVF number, W, ACCESS
09E8  22DA     ADDWFC FSR2H, F, ACCESS
09EA  0E01     MOVLW 0x1
09EC  50DB     MOVF PLUSW2, W, ACCESS
09EE  E104     BNZ 0x9F8
09F0  0EC9     MOVLW 0xC9
09F2  5CDE     SUBWF POSTINC2, W, ACCESS
09F4  A0D8     BTFSS STATUS, 0, ACCESS
09F6  0012     RETURN 0
60:                    Values->right = 200;
09F8  EE20     LFSR 2, 0x2
09FA  F002     NOP
09FC  5006     MOVF Values, W, ACCESS
09FE  26D9     ADDWF FSR2, F, ACCESS
0A00  5007     MOVF number, W, ACCESS
0A02  22DA     ADDWFC FSR2H, F, ACCESS
0A04  0EC8     MOVLW 0xC8
0A06  6EDE     MOVWF POSTINC2, ACCESS
0A08  0E00     MOVLW 0x0
0A0A  6EDD     MOVWF POSTDEC2, ACCESS
0A0C  0012     RETURN 0
61:                } //reduce un-required noise above 200
62:                // __delay_ms(50);
63:                //    if ((Values->left_prev = Values->left) && (Values->left < 50)) 
64:                //        {
65:                //            Values->left = 0;
66:                //        }
67:                //    if ((Values->right_prev = Values->right) && (Values->right < 50)) {
68:                //            {
69:                //                Values->right = 0;
70:                //            }
71:            
72:                //        }
73:            }
74:            
75:            //int measureIRLeft(void)
76:            //{
77:            //    // Initialise IR level variable
78:            //    // ----------------------------------------------------------------------
79:            //    unsigned int IRlevel = 0;
80:            //
81:            //    // Take a predetermined number of readings, and sum the results
82:            //    // ----------------------------------------------------------------------
83:            //    for (char i = 0; i < 2; i++)
84:            //    {
85:            //         IRlevel += CAP1BUFL;  // Get the 8 bit LSB result
86:            //         IRlevel += ((unsigned int)CAP1BUFH << 8); // Get 2 bit MSB result
87:            //         __delay_ms(50);
88:            //    }
89:            //
90:            //    // Reset to zero
91:            //    // ----------------------------------------------------------------------
92:            //    CAP1BUFL = 0;
93:            //    CAP1BUFH = 0;
94:            //
95:            //    // Calculate the average
96:            //    // ----------------------------------------------------------------------
97:            //    IRlevel = IRlevel/3;
98:            //
99:            //    // Return the averaged value
100:           //    // ----------------------------------------------------------------------
101:           //    return IRlevel;
102:           //}
103:           //
104:           //int measureIRright(void)
105:           //{
106:           //    // Initialise IR level variable
107:           //    // ----------------------------------------------------------------------
108:           //    unsigned int IRlevel = 0;
109:           //
110:           //    // Take a predetermined number of readings, and sum the results
111:           //    // ----------------------------------------------------------------------
112:           //    for (char i = 0; i < 2; i++)
113:           //    {
114:           //         IRlevel += CAP1BUFL;  // Get the 8 bit LSB result
115:           //         IRlevel += ((unsigned int)CAP1BUFH << 8); // Get 2 bit MSB result
116:           //         __delay_ms(50);
117:           //    }
118:           //
119:           //    // Reset to zero
120:           //    // ----------------------------------------------------------------------
121:           //    CAP1BUFL = 0;
122:           //    CAP1BUFH = 0;
123:           //
124:           //    // Calculate the average
125:           //    // ----------------------------------------------------------------------
126:           //    IRlevel = IRlevel/2;
127:           //
128:           //    // Return the averaged value
129:           //    // ----------------------------------------------------------------------
130:           //    return IRlevel;
131:           //}
---  /Applications/microchip/xc8/v2.00/pic/sources/c90/common/lwmod.c  ----------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             __lwmod(unsigned int divisor, unsigned int dividend)
6:             #else
7:             __lwmod(unsigned int dividend, unsigned int divisor)
8:             #endif
9:             {
10:            	unsigned char	counter;
11:            
12:            	if(divisor != 0) {
131C  500F     MOVF divisor, W, ACCESS
131E  1010     IORWF counter, W, ACCESS
1320  B4D8     BTFSC STATUS, 2, ACCESS
1322  D018     BRA 0x1354
13:            		counter = 1;
1324  0E01     MOVLW 0x1
1326  6E11     MOVWF sign, ACCESS
14:            		while((divisor & 0x8000) == 0) {
1328  D004     BRA 0x1332
15:            			divisor <<= 1;
132A  90D8     BCF STATUS, 0, ACCESS
132C  360F     RLCF divisor, F, ACCESS
132E  3610     RLCF counter, F, ACCESS
16:            			counter++;
1330  2A11     INCF sign, F, ACCESS
17:            		}
1332  AE10     BTFSS counter, 7, ACCESS
1334  D7FA     BRA 0x132A
18:            		do {
19:            			if(divisor <= dividend)
1336  500F     MOVF divisor, W, ACCESS
1338  5C0D     SUBWF dividend, W, ACCESS
133A  5010     MOVF counter, W, ACCESS
133C  580E     SUBWFB divisor, W, ACCESS
133E  A0D8     BTFSS STATUS, 0, ACCESS
1340  D004     BRA 0x134A
20:            				dividend -= divisor;
1342  500F     MOVF divisor, W, ACCESS
1344  5E0D     SUBWF dividend, F, ACCESS
1346  5010     MOVF counter, W, ACCESS
1348  5A0E     SUBWFB divisor, F, ACCESS
21:            			divisor >>= 1;
134A  90D8     BCF STATUS, 0, ACCESS
134C  3210     RRCF counter, F, ACCESS
134E  320F     RRCF divisor, F, ACCESS
22:            		} while(--counter != 0);
1350  2E11     DECFSZ sign, F, ACCESS
1352  D7F1     BRA 0x1336
23:            	}
24:            	return dividend;
1354  C00D     MOVFF dividend, dividend
1356  F00D     NOP
1358  C00E     MOVFF divisor, divisor
135A  F00E     NOP
25:            }
135C  0012     RETURN 0
---  /Applications/microchip/xc8/v2.00/pic/sources/c90/common/lwdiv.c  ----------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             __lwdiv(unsigned int divisor, unsigned int dividend)
6:             #else
7:             __lwdiv(unsigned int dividend, unsigned int divisor)
8:             #endif
9:             {
10:            	unsigned int	quotient;
11:            	unsigned char	counter;
12:            
13:            	quotient = 0;
12CA  0E00     MOVLW 0x0
12CC  6E0B     MOVWF pa, ACCESS
12CE  0E00     MOVLW 0x0
12D0  6E0A     MOVWF string, ACCESS
14:            	if(divisor != 0) {
12D2  5008     MOVF type, W, ACCESS
12D4  1009     IORWF Byte, W, ACCESS
12D6  B4D8     BTFSC STATUS, 2, ACCESS
12D8  D01C     BRA 0x1312
15:            		counter = 1;
12DA  0E01     MOVLW 0x1
12DC  6E0C     MOVWF counter, ACCESS
16:            		while((divisor & 0x8000) == 0) {
12DE  D004     BRA 0x12E8
17:            			divisor <<= 1;
12E0  90D8     BCF STATUS, 0, ACCESS
12E2  3608     RLCF type, F, ACCESS
12E4  3609     RLCF Byte, F, ACCESS
18:            			counter++;
12E6  2A0C     INCF counter, F, ACCESS
19:            		}
12E8  AE09     BTFSS Byte, 7, ACCESS
12EA  D7FA     BRA 0x12E0
20:            		do {
21:            			quotient <<= 1;
12EC  90D8     BCF STATUS, 0, ACCESS
12EE  360A     RLCF string, F, ACCESS
12F0  360B     RLCF pa, F, ACCESS
22:            			if(divisor <= dividend) {
12F2  5008     MOVF type, W, ACCESS
12F4  5C06     SUBWF Values, W, ACCESS
12F6  5009     MOVF Byte, W, ACCESS
12F8  5807     SUBWFB number, W, ACCESS
12FA  A0D8     BTFSS STATUS, 0, ACCESS
12FC  D005     BRA 0x1308
23:            				dividend -= divisor;
12FE  5008     MOVF type, W, ACCESS
1300  5E06     SUBWF Values, F, ACCESS
1302  5009     MOVF Byte, W, ACCESS
1304  5A07     SUBWFB number, F, ACCESS
24:            				quotient |= 1;
1306  800A     BSF string, 0, ACCESS
25:            			}
26:            			divisor >>= 1;
1308  90D8     BCF STATUS, 0, ACCESS
130A  3209     RRCF Byte, F, ACCESS
130C  3208     RRCF type, F, ACCESS
27:            		} while(--counter != 0);
130E  2E0C     DECFSZ counter, F, ACCESS
1310  D7ED     BRA 0x12EC
28:            	}
29:            	return quotient;
1312  C00A     MOVFF string, Values
1314  F006     NOP
1316  C00B     MOVFF pa, number
1318  F007     NOP
30:            }
131A  0012     RETURN 0
---  /Applications/microchip/xc8/v2.00/pic/sources/c90/common/doprnt.c  ---------------------------------
1:             #include	<stdio.h>
2:             #include	<ctype.h>
3:             #include	<stdlib.h>
4:             #include	<string.h>
5:             #include	<stdarg.h>
6:             #include	<conio.h>
7:             #include	<math.h>
8:             #include	<float.h>
9:             
10:            // disable unused variable warnings
11:            // the compiler will optimize them away, so no harm is done
12:            #pragma warning disable 350
13:            
14:            /*
15:             *	doprnt - versions depends on conditional compilation.
16:             *	Can be customized with defines.
17:             *
18:             *	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
19:             *
20:             *	$Header$
21:             *
22:             */
23:            
24:            #ifndef	CUSTOM_PRINTF
25:            
26:             // define all flags, thus enabling all features
27:            
28:            #define	BASEM	0xC0
29:            #define	OPTSIGN	0x00
30:            #define	SPCSIGN	0x01
31:            #define	MANSIGN	0x02
32:            #define	NEGSIGN	0x03
33:            #define	FILL	0x04
34:            #define	LEFT	0x08
35:            #define	LONG	0x10
36:            #define	LONGLONG	0x4000000
37:            #define	UPCASE	0x20
38:            #define	TEN		0x00
39:            #define	EIGHT	0x40
40:            #define	SIXTEEN	0x80
41:            #define	UNSIGN	0xC0
42:            #ifdef	__FLOAT
43:            #define	EFMT	0x100
44:            #define	GFMT	0x200
45:            #define	FFMT	0x400
46:            #endif	// __FLOAT
47:            #define	ALTERN	0x800
48:            #define POINTER	0x2000
49:            #define HEXUPCASE
50:            #define HEXLOWCASE
51:            
52:             // defines for ifdef only, not used as flags
53:            #define	WIDTH	1		// width used
54:            #define	STAR	1		// width or precision as an arg
55:            #define	STRING	1		// %s used
56:            #define	CHAR	1		// %c used
57:            #define	PERCPERC	1	// %% used
58:            #define	SPRINTF	1		// sprintf is used
59:            #define	PRINTF	1		// printf is used
60:            #define	MULTRAD	1		// handle multiple radices
61:            #define	RETVALUE	1	// return value is needed
62:            
63:            #else	// CUSTOM_PRINTF
64:            
65:            #if	defined(HEXUPCASE) || defined(HEXLOWCASE)
66:            #define	SIXTEEN
67:            #endif
68:            
69:            #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
70:            #ifndef UPCASE
71:            #define	UPCASE
72:            #endif
73:            #endif
74:            
75:             // make sure we have the right values for each define
76:            #ifdef	OPTSIGN
77:            #undef	OPTSIGN
78:            #define	OPTSIGN	0x00
79:            #endif
80:            #ifdef	SPCSIGN
81:            #undef	SPCSIGN
82:            #define	SPCSIGN	0x01
83:            #endif
84:            #ifdef	MANSIGN
85:            #undef	MANSIGN
86:            #define	MANSIGN	0x02
87:            #define	SPCSIGN	0x01
88:            #endif
89:            #ifdef	NEGSIGN
90:            #undef	NEGSIGN
91:            #define	NEGSIGN	0x03
92:            #endif
93:            #ifdef	FILL
94:            #define	WIDTH	1
95:            #undef	FILL
96:            #define	FILL	0x04
97:            #endif
98:            #ifdef	LEFT
99:            #undef	LEFT
100:            // LEFT without WIDTH is meaningless
101:           #ifdef	WIDTH
102:           #define	LEFT	0x08
103:           #endif
104:           #endif
105:           #ifdef	LONG
106:           #undef	LONG
107:           #define	LONG	0x10
108:           #define	__LONG	1
109:           #endif
110:           #ifdef	UPCASE
111:           #undef	UPCASE
112:           #define	UPCASE	0x20
113:           #endif
114:           #ifdef	TEN	
115:           #undef	TEN	
116:           #define	TEN		0x00
117:           #endif
118:           #ifdef	EIGHT
119:           #undef	EIGHT
120:           #define	EIGHT	0x40
121:           #endif
122:           #ifdef	SIXTEEN
123:           #undef	SIXTEEN
124:           #define	SIXTEEN	0x80
125:           #endif
126:           #ifdef	UNSIGN
127:           #undef	UNSIGN
128:           #define	UNSIGN	0xC0
129:           #endif
130:           #ifdef	EFMT
131:           #undef	EFMT
132:           #define	EFMT	0x100
133:           #endif
134:           #ifdef	GFMT
135:           #undef	GFMT
136:           #define	GFMT	0x200
137:           #endif
138:           #ifdef	FFMT
139:           #undef	FFMT
140:           #define	FFMT	0x400
141:           #endif
142:           #ifdef	ALTERN
143:           #undef	ALTERN
144:           #define	ALTERN	0x800
145:           #endif
146:           #ifdef	POINTER
147:           #undef	POINTER
148:           #define POINTER	0x2000
149:           #ifndef	SIXTEEN
150:           #define	SIXTEEN	0x80
151:           #endif
152:           #endif
153:           #ifdef	PRECISION
154:           #undef	PRECISION
155:           #define PRECISION	0x4000
156:           #endif
157:           
158:           #if	defined(TEN) && !defined(EIGHT) && !defined(SIXTEEN) && defined(UNSIGN)
159:           #undef	UNSIGN
160:           #define	UNSIGN	0x40
161:           #define	BASEM	UNSIGN
162:           #endif
163:           #if	defined(UNSIGN) && (defined(EIGHT) || defined(SIXTEEN))
164:           #define	MULTRAD	1
165:           #define	BASEM	(UNSIGN)
166:           #endif
167:           #if	defined(TEN) && !defined(SIXTEEN) && defined(EIGHT) && !defined(UNSIGN)
168:           #define	BASEM	EIGHT
169:           #define	MULTRAD	1
170:           #endif
171:           #if	defined(TEN) && defined(SIXTEEN) && !defined(EIGHT) && !defined(UNSIGN)
172:           #define	BASEM	SIXTEEN
173:           #define	MULTRAD	1
174:           #endif
175:           #if	defined(SIXTEEN) && defined(EIGHT) && !defined(BASEM)
176:           #define	BASEM	(SIXTEEN|EIGHT)
177:           #define	MULTRAD	1
178:           #endif
179:           
180:           #endif
181:           
182:            // float code needs these flags
183:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT)
184:           #ifndef	__FLOAT
185:           #define	__FLOAT	1
186:           #endif
187:           #define	FLOATFORMAT	0x700
188:           #ifdef	PRECISION
189:           #define	DEFPREC	0x1000
190:           #endif
191:           #endif
192:           
193:           #ifdef	__FLOAT
194:           //#ifndef	MANSIGN
195:           //#define	MANSIGN	0x02
196:           //#endif
197:           //#ifndef	SPCSIGN
198:           //#define	SPCSIGN	0x01
199:           //#endif
200:           #ifndef	NEGSIGN
201:           #define	NEGSIGN	0x03
202:           #endif
203:           //#ifndef	WIDTH
204:           //#define	WIDTH	1
205:           //#endif
206:           #endif
207:           
208:           #ifdef	SPCSIGN
209:           #define	putsign()	pputc(flag & SPCSIGN ? '-' : '+')
210:           #else
211:           #define	putsign()	pputc('-')
212:           #endif	// SPCSIGN
213:           
214:           // were there ANY % formats defined?
215:           #if	defined(FLOATFORMAT) || defined(TEN) || defined(EIGHT) || defined(SIXTEEN) || \
216:           	defined(CHAR) || defined(POINTER) || defined(STRING) || defined(UNSIGN) || defined(PERCPERC)
217:           #define	ANYFORMAT
218:           #else
219:           #undef	ANYFORMAT
220:           #endif
221:           
222:           #ifdef	CHAR
223:           #ifndef	PERCPERC
224:           #define	PERCPERC
225:           #endif
226:           #endif
227:           
228:           #if	!defined(PRINTF) && !defined(VPRINTF) && !defined(SPRINTF) && !defined(VSPRINTF)
229:           #error	Must define at least one of PRINTF SPRINTF or VSPRINTF
230:           #endif
231:           
232:           #if	i8086 && SMALL_DATA
233:           #define	CONST	__far
234:           #else
235:           #define	CONST	const
236:           #endif
237:           
238:            /* we don't need plus signs, use minus signs only if we have floats or signed ints */
239:           
240:           #if	!defined(NEGSIGN) && defined(TEN)
241:           #define	NEGSIGN	0x03
242:           #endif
243:           
244:           #ifndef	RETVALUE
245:           #define	INCR_CNT	/*nix */
246:           #else
247:           #define	INCR_CNT	,(++ccnt)
248:           #endif
249:           
250:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT) || defined(ALTERN) || defined(DEFPREC) || defined(POINTER)
251:           #define	FLAG_SIZE	unsigned short
252:           #else
253:           #define	FLAG_SIZE	unsigned char
254:           #endif
255:           
256:           
257:           #if	(__SIZEOF_LONG__ == __SIZEOF_INT__ || defined(__FLOAT)) && !defined(__LONG)
258:           #define	__LONG	1
259:           #endif
260:           
261:           #if (__SIZEOF_LONG__ > 4)
262:           #define __LONGLONG	1
263:           #endif
264:           
265:           #if	__SIZEOF_DOUBLE__ == __SIZEOF_LONG__ && DBL_MAX_EXP == 128
266:           #undef	frexp
267:           #define	frexp(val, ptr) (void)(*(ptr) = (unsigned char)((*(unsigned long *)&val >> 23) & 255) - 126)
268:           #elif	defined(_PSOC_)
269:           #undef	frexp
270:           #define	frexp(val, ptr) (void)(*(ptr) = ((unsigned char)(*(__uint24 *)&val >> 15)) - 126)
271:           #elif	__SIZEOF_DOUBLE__ == 3 && DBL_MAX_EXP == 128
272:           #undef	frexp
273:           #define	frexp(val, ptr) (void)(*(ptr) = ((*(unsigned long *)&val >> 15) & 255) - 126)
274:           #endif
275:           
276:           #if	defined(__FLOAT) && __SIZEOF_DOUBLE__ == 8
277:           #define	DOUBLE	1
278:           
279:           extern double	_dto64i(double);
280:           extern double	_64itod(double);
281:           extern double	_div64(double, double);
282:           extern double	_divto64i(double, double);
283:           extern unsigned	_div64ir(double, double);
284:           extern unsigned	_mod64i10(double);
285:           
286:           #else
287:           #define	DOUBLE	0
288:           #endif
289:           
290:           #ifdef	__LONG
291:           #define	value	long
292:           #define	NDIG	12		/* max number of digits to be printed */
293:           #else
294:           #define	value	int
295:           #define	NDIG	6		/* max number of digits to be printed */
296:           #endif
297:           
298:           #if	DOUBLE
299:           union {
300:           	unsigned long	ul[40];
301:           	double		db[20];
302:           }	_fdp =
303:           {
304:           #if	!defined(BIG_ENDIAN) && !defined(LITTLE_ENDIAN)
305:           #error Neither BIG_ENDIAN or LITTLE_ENDIAN has been set
306:           #endif
307:           #if	BIG_ENDIAN
308:           	0x00000000,0x00000001,
309:           	0x00000000,0x0000000A,
310:           	0x00000000,0x00000064,
311:           	0x00000000,0x000003E8,
312:           	0x00000000,0x00002710,
313:           	0x00000000,0x000186A0,
314:           	0x00000000,0x000F4240,
315:           	0x00000000,0x00989680,
316:           	0x00000000,0x05F5E100,
317:           	0x00000000,0x3B9ACA00,
318:           	0x00000002,0x540BE400,
319:           	0x00000017,0x4876E800,
320:           	0x000000E8,0xD4A51000,
321:           	0x00000918,0x4E72A000,
322:           	0x00005AF3,0x107A4000,
323:           	0x00038D7E,0xA4C68000,
324:           	0x002386F2,0x6FC10000,
325:           	0x01634578,0x5D8A0000,
326:           	0x0DE0B6B3,0xA7640000,
327:           	0x8AC72304,0x89E80000,
328:           #else
329:           	0x00000001,0x00000000,
330:           	0x0000000A,0x00000000,
331:           	0x00000064,0x00000000,
332:           	0x000003E8,0x00000000,
333:           	0x00002710,0x00000000,
334:           	0x000186A0,0x00000000,
335:           	0x000F4240,0x00000000,
336:           	0x00989680,0x00000000,
337:           	0x05F5E100,0x00000000,
338:           	0x3B9ACA00,0x00000000,
339:           	0x540BE400,0x00000002,
340:           	0x4876E800,0x00000017,
341:           	0xD4A51000,0x000000E8,
342:           	0x4E72A000,0x00000918,
343:           	0x107A4000,0x00005AF3,
344:           	0xA4C68000,0x00038D7E,
345:           	0x6FC10000,0x002386F2,
346:           	0x5D8A0000,0x01634578,
347:           	0xA7640000,0x0DE0B6B3,
348:           	0x89E80000,0x8AC72304,
349:           #endif
350:           };
351:           
352:           #define	fdpowers	_fdp.db
353:           
354:           #else
355:           #define	fdpowers	dpowers
356:           #endif
357:           #if defined(TEN) || defined(__FLOAT) || defined (UNSIGN)
358:           const static unsigned value	dpowers[] =	{1, 10, 100, 1000, 10000,
359:           #ifdef	__LONG
360:           						 100000, 1000000, 10000000, 100000000,
361:           						 1000000000
362:           #endif
363:           							 };
364:           #endif
365:           #ifdef	SIXTEEN
366:           const static unsigned value	hexpowers[] =	{1, 0x10, 0x100, 0x1000,
367:           #if	__LONG
368:           						 0x10000, 0x100000, 0x1000000, 0x10000000
369:           #endif
370:           							};
371:           #endif
372:           #ifdef	EIGHT
373:           const static unsigned value	octpowers[] =	{1, 010, 0100, 01000, 010000, 0100000,
374:           #ifdef	__LONG
375:           						01000000,
376:           						 010000000, 0100000000, 01000000000, 010000000000,
377:           #ifdef __LONGLONG
378:           						 0100000000000
379:           #endif
380:           #endif
381:           							};
382:           #endif
383:           
384:           #ifdef	__FLOAT
385:           
386:           #define	NDDIG	(sizeof fdpowers/sizeof fdpowers[0])
387:           
388:           #if	DBL_MAX_10_EXP > 120
389:           #define	expon	int
390:           #define	uns_expon	unsigned int
391:           #else
392:           #define	expon	signed char
393:           #define	uns_expon	unsigned char
394:           #endif
395:           
396:           extern const double	_powers_[], _npowers_[];
397:           #ifdef	z80
398:           #define	_div_to_l_(a, b)	((unsigned long)((a)/(b)))
399:           #else
400:           extern unsigned long	_div_to_l_(double, double);
401:           #ifdef	_OMNI_CODE_
402:           extern unsigned long	_tdiv_to_l_(float, float);
403:           #ifdef	_HTKC_
404:           #pragma callname _div_to_l_ double
405:           #pragma callname _tdiv_to_l_ float
406:           #endif
407:           #define	div_to_l_(a,b)	((sizeof(double)== 3) ? _tdiv_to_l_(a,b) : _div_to_l_(a,b))
408:           #else
409:           #define	div_to_l_	_div_to_l_
410:           #endif
411:           #endif
412:           
413:           /* this routine returns a value to round to the number of decimal
414:           	places specified */
415:           #if __FLOAT
416:           static double
417:           fround(unsigned char prec)
418:           {
419:           	/* prec is guaranteed to be less than NDIG */
420:           
421:           	if(prec>=110)
422:           		return 0.5 * _npowers_[prec/100U+18U] * _npowers_[(prec%100U)/10U+9U] * _npowers_[prec%10U];
423:           	else if(prec > 10)
424:           		return 0.5 * _npowers_[prec/10U+9U] * _npowers_[prec%10U];
425:           	return 0.5 * _npowers_[prec];
426:           }
427:           #endif
428:           
429:           /* this routine returns a scaling factor equal to 1 to the decimal
430:              power supplied */
431:           
432:           static double
433:           scale(expon scl)
434:           {
435:           
436:           	if(scl < 0) {
437:           		scl = -scl;
438:           		if(scl>=110)
439:           			return _npowers_[(uns_expon)(scl/100+18)] * _npowers_[(uns_expon)((scl%100)/10+9)] * _npowers_[(uns_expon)(scl%10)];
440:           		else if(scl > 10)
441:           			return _npowers_[(uns_expon)(scl/10+9)] * _npowers_[(uns_expon)(scl%10)];
442:           		return _npowers_[(uns_expon)scl];
443:           	}
444:           	if(scl>=110)
445:           		return _powers_[(uns_expon)(scl/100+18)] * _powers_[(uns_expon)((scl%100)/10+9)] * _powers_[(uns_expon)(scl%10)];
446:           	else if(scl > 10)
447:           		return _powers_[(uns_expon)(scl/10+9)] * _powers_[(uns_expon)(scl%10)];
448:           	return _powers_[(uns_expon)scl];
449:           }
450:           
451:           
452:           #endif	/* __FLOAT */
453:           
454:           
455:           
456:           #ifdef	_HOSTED
457:           #define	pputc(c)	(putc(c, fp) != EOF && ++ccnt)
458:           int
459:           vfprintf(FILE * fp, register const  char * f, register va_list ap)
460:           {
461:           	char		cbuf[2];
462:           #else	/* _HOSTED */
463:           int
464:           #if	defined(VPRINTF) || (defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF)))
465:           #define	pputc(c)	do { if(pb->func) (pb->func(c))INCR_CNT; else ((*pb->ptr++ = c)INCR_CNT); } while(0)
466:           _doprnt(struct __prbuf * pb, register const  char * f, register va_list ap)
467:           {
468:           #endif
469:           
470:           #if	defined(PRINTF) && !(defined(SPRINTF) || defined(VSPRINTF))
471:           #define	pputc(c)	(putch(c) INCR_CNT)
472:           printf(const char * f, ...)
473:           {
474:           	va_list	ap;
475:           #define	NEED_START
476:           #endif
477:           
478:           #if	!defined(PRINTF) && defined(VSPRINTF)
479:           
480:           #ifdef	SPRINTF
481:           sprintf(char * sp, const char * f, ...)
482:           {
483:           	va_list	ap;
484:           
485:           	va_start(ap, f);
486:           	vsprintf(sp, f, ap);
487:           	va_end(ap);
488:           }
489:           int
490:           #endif	// SPRINTF
491:           
492:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
493:           vsprintf(char * sp, register const  char * f, register va_list ap)
494:           {
495:           #define NEED_START
496:           #endif	// VSPRINTF
497:           
498:           #if	!defined(PRINTF) && defined(SPRINTF) && !defined(VSPRINTF)
499:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
500:           sprintf(char * sp, const  char * f, ...)
501:           {
502:           	va_list	ap;
503:           #define	NEED_START
504:           #endif
505:           #endif	// HOSTED
506:           
507:           	char		c;
508:           #if	defined(WIDTH) || defined(__FLOAT)
509:           	int		width;
510:           #endif
511:           #ifdef	__LONG
512:           	int		prec;
513:           #define uns_prec	unsigned int
514:           #define prec_t		int
515:           #else
516:           	signed char	prec;
517:           #define uns_prec	unsigned char
518:           #define prec_t		signed char
519:           #endif
520:           	FLAG_SIZE	flag;
521:           #ifdef	RETVALUE
522:           	int		ccnt = 0;
523:           #else
524:           #define	ccnt	0
525:           #endif
526:           #ifdef	__FLOAT
527:           	char	d;
528:           	double	fval; 
529:           	int		eexp;
530:           #if DOUBLE
531:           	double		ival;
532:           #endif
533:           #endif
534:           #if ! DOUBLE || __FLOAT
535:           	union {
536:           		unsigned long vd;
537:           		double integ;
538:           	} tmpval;
539:           #endif
540:           	unsigned value	val;
541:           	unsigned	len;
542:           	CONST char *	cp;
543:           	
544:           #ifdef	NEED_START
545:           	va_start(ap, f);
0B90  0E16     MOVLW 0x16
0B92  6E1A     MOVWF ap, ACCESS
0B94  0E00     MOVLW 0x0
0B96  6E1B     MOVWF mL, ACCESS
546:           #endif
547:           
548:           	while((c = *f++)) {
0B98  D0A2     BRA 0xCDE
0CDE  C014     MOVFF f, TBLPTR
0CE0  FFF6     NOP
0CE2  C015     MOVFF 0x15, TBLPTRH
0CE4  FFF7     NOP
0CE6  4A14     INFSNZ f, F, ACCESS
0CE8  2A15     INCF 0x15, F, ACCESS
0CEA  0008     TBLRD*
0CEC  CFF5     MOVFF TABLAT, c
0CEE  F01F     NOP
0CF0  501F     MOVF c, W, ACCESS
0CF2  A4D8     BTFSS STATUS, 2, ACCESS
0CF4  D752     BRA 0xB9A
549:           #ifdef	ANYFORMAT
550:           		if(c != '%')
0B9A  0E25     MOVLW 0x25
0B9C  181F     XORWF c, W, ACCESS
0B9E  B4D8     BTFSC STATUS, 2, ACCESS
0BA0  D009     BRA 0xBB4
551:           #endif	//ANYFORMAT
552:           		{
553:           			pputc(c);
0BA2  C012     MOVFF quotient, FSR2
0BA4  FFD9     NOP
0BA6  C013     MOVFF 0x13, FSR2H
0BA8  FFDA     NOP
0BAA  C01F     MOVFF c, INDF2
0BAC  FFDF     NOP
0BAE  4A12     INFSNZ quotient, F, ACCESS
0BB0  2A13     INCF 0x13, F, ACCESS
554:           			continue;
0BB2  D095     BRA 0xCDE
555:           		}
556:           #ifdef	ANYFORMAT
557:           #ifdef	WIDTH
558:           		width = 0;
559:           #endif
560:           		flag = 0;
0BB4  0E00     MOVLW 0x0
0BB6  6E1C     MOVWF flag, ACCESS
561:           #if	defined(LEFT) || defined(SPCSIGN) || defined(MANSIGN) || defined(ALTERN) || defined(FILL)
562:           		for(;;) {
563:           			switch(*f) {
564:           #ifdef	LEFT
565:           			case '-':
566:           				flag |= LEFT;
567:           				f++;
568:           				continue;
569:           #endif
570:           
571:           #ifdef	SPCSIGN
572:           			case ' ':
573:           				flag |= SPCSIGN;
574:           				f++;
575:           				continue;
576:           #endif
577:           
578:           #ifdef	MANSIGN
579:           			case '+':
580:           				flag |= MANSIGN;
581:           				f++;
582:           				continue;
583:           #endif
584:           #ifdef	ALTERN
585:           			case '#':
586:           				flag |= ALTERN;
587:           				f++;
588:           				continue;
589:           #endif
590:           #ifdef	FILL
591:           			case '0':
592:           				flag |= FILL;
593:           				f++;
594:           				continue;
595:           #endif
596:           			}
597:           			break;
598:           		}
599:           #endif
600:           #if	defined(MANSIGN) && defined(SPCSIGN)
601:           		if(flag & MANSIGN)
602:           			flag &= ~SPCSIGN;
603:           #endif
604:           #if	defined(LEFT) && defined(FILL)
605:           		if(flag & LEFT)
606:           			flag &= ~FILL;
607:           #endif
608:           #ifdef	WIDTH
609:           		if(isdigit((unsigned)*f)) {
610:           			width = 0;
611:           			do {
612:           				width *= 10;
613:           			   	width += *f++ - '0';
614:           			} while(isdigit((unsigned)*f));
615:           #ifdef	STAR
616:           		} else if(*f == '*') {
617:           			width = va_arg(ap, int);
618:           			f++;
619:           #endif
620:           		}
621:           #endif
622:           #ifdef	PRECISION
623:           		if(*f == '.') {
624:           			flag |= PRECISION;
625:           			f++;
626:           #ifdef	STAR
627:           			if(*f == '*') {
628:           				prec = va_arg(ap, int);
629:           				if (prec < 0) {
630:           					prec = 0;
631:           					flag &= ~PRECISION;
632:           #ifdef DEFPREC
633:           					flag |= DEFPREC;
634:           #endif
635:           				}
636:           				f++;
637:           			} else
638:           #endif
639:           			{
640:           				prec = 0;
641:           				while(isdigit((unsigned)*f))
642:           					prec = prec*10 + *f++ - '0';
643:           			}
644:           		} else {
645:           			prec = 0;
646:           #ifdef	DEFPREC
647:           			flag |= DEFPREC;
648:           #endif	// DEFPREC
649:           		}
650:           #endif	// PRECISION
651:           #if	defined(__LONG) && defined(LONG)
652:           loop:
653:           #endif
654:           		switch(c = *f++) {
0BB8  D002     BRA 0xBBE
0BBE  C014     MOVFF f, TBLPTR
0BC0  FFF6     NOP
0BC2  C015     MOVFF 0x15, TBLPTRH
0BC4  FFF7     NOP
0BC6  4A14     INFSNZ f, F, ACCESS
0BC8  2A15     INCF 0x15, F, ACCESS
0BCA  0008     TBLRD*
0BCC  CFF5     MOVFF TABLAT, c
0BCE  F01F     NOP
0BD0  501F     MOVF c, W, ACCESS
0BD2  0A00     XORLW 0x0
0BD4  B4D8     BTFSC STATUS, 2, ACCESS
0BD6  D08F     BRA 0xCF6
0BD8  0A64     XORLW 0x64
0BDA  B4D8     BTFSC STATUS, 2, ACCESS
0BDC  D007     BRA 0xBEC
0BDE  0A0D     XORLW 0xD
0BE0  B4D8     BTFSC STATUS, 2, ACCESS
0BE2  D004     BRA 0xBEC
0BE4  0A1C     XORLW 0x1C
0BE6  B4D8     BTFSC STATUS, 2, ACCESS
0BE8  D7E8     BRA 0xBBA
0BEA  D079     BRA 0xCDE
655:           
656:           		case 0:
657:           			goto alldone;
658:           
659:           #ifdef	LONG
660:           		case 'l':
661:           #ifdef	__LONG
662:           			flag |= LONG;
663:           			goto loop;
664:           #else
665:           			cp = "(non-long printf)";
666:           			goto strings;
667:           #endif
668:           #endif
669:           
670:           #ifdef	FLOATFORMAT
671:           #ifndef	__FLOAT
672:           		case 'E':
673:           		case 'f':
674:           		case 'e':
675:           		case 'G':
676:           		case 'g':
677:           			cp = "(non-float printf)";
678:           			goto strings;
679:           #else
680:           #ifdef	FFMT
681:           		case 'f':
682:           			flag |= FFMT;
683:           			break;
684:           #endif
685:           
686:           #ifdef	EFMT
687:           #ifdef	UPCASE
688:           		case 'E':
689:           			flag |= UPCASE;
690:           #endif
691:           		case 'e':
692:           			flag |= EFMT;
693:           			break;
694:           #endif
695:           
696:           #ifdef	GFMT
697:           #ifdef	UPCASE
698:           		case 'G':
699:           			flag |= UPCASE;
700:           #endif
701:           		case 'g':
702:           			flag |= GFMT;
703:           			break;
704:           #endif	// GFMT
705:           #endif
706:           #endif	// FLOATFORMAT
707:           #ifdef	EIGHT
708:           		case 'o':
709:           #ifdef	MULTRAD
710:           			flag |= EIGHT;
711:           #endif
712:           			break;
713:           #endif
714:           
715:           #ifdef	TEN
716:           		case 'd':
717:           		case 'i':
718:           			break;
719:           #endif
720:           
721:           #ifdef	POINTER
722:           		case 'p':
723:           #if	i8086 && LARGE_DATA
724:           			flag |= LONG;
725:           #elif	_PIC18
726:           			flag |= POINTER;
727:           #endif
728:           #endif	// POINTER
729:           #ifdef	SIXTEEN
730:           #ifdef	HEXUPCASE
731:           		case 'X':
732:           #ifdef	UPCASE
733:           			flag |= UPCASE;
734:           #endif
735:           #endif
736:           #if	defined(HEXLOWCASE) || !defined(UPCASE)
737:           		case 'x':
738:           #endif
739:           #ifdef	MULTRAD
740:           			flag |= SIXTEEN;
741:           #endif
742:           			break;
743:           #endif	// SIXTEEN
744:           
745:           #if	defined(STRING) || defined(PERCPERC)
746:           #ifdef	STRING
747:           		case 's':
748:           #if	i8086 && SMALL_DATA
749:           			if(flag & LONG)
750:           				cp = va_arg(ap, __far char *);
751:           			else
752:           #endif
753:           				cp = va_arg(ap, const char *);
754:           #endif	// STRING
755:           #if	!defined(__FLOAT) && !defined(CUSTOM_PRINTF)
756:           strings:
757:           #endif
758:           #ifdef	STRING
759:           			if(!cp)
760:           				cp = "(null)";
761:           #endif
762:           #if	defined(WIDTH) || defined(PRECISION)
763:           #if	defined(STRING)
764:           			len = 0;
765:           			while(cp[len])
766:           				len++;
767:           #endif
768:           #ifdef	PERCPERC
769:           dostring:
770:           #endif
771:           #ifdef	PRECISION
772:           			if(prec && prec < len)
773:           				len = prec;
774:           #endif	// PRECISION
775:           #ifdef	WIDTH
776:           			if(width > len)
777:           				width -= len;
778:           			else
779:           				width = 0;
780:           #ifdef	LEFT
781:           			if(!(flag & LEFT))
782:           #endif	// LEFT
783:           				while(width--)
784:           					pputc(' ');
785:           #endif	// WIDTH
786:           			while(len--)
787:           				pputc(*cp++);
788:           #ifdef	LEFT
789:           			if(flag & LEFT)
790:           				while(width--)
791:           					pputc(' ');
792:           #endif	// LEFT
793:           			continue;
794:           #else	// WIDTH || PRECISION
795:           #if	defined(STRING)
796:           			while(*cp)
797:           				pputc(*cp++);
798:           			continue;
799:           #endif
800:           #endif	// WIDTH || PRECISION
801:           #endif	// defined(STRING) || defined(PERCPERC)
802:           #ifdef	CHAR
803:           		case 'c':
804:           #if	_HOSTED
805:           			val = va_arg(ap, int);
806:           			c = val >> 8;
807:           			if(flag & LONG && c && (unsigned char)c != 0xFF) {
808:           				cbuf[0] = c;
809:           				cbuf[1] = val;
810:           				len = 2;
811:           			} else {
812:           				cbuf[0] = val;
813:           				len = 1;
814:           			}
815:           			cp = cbuf;
816:           			goto dostring;
817:           #else
818:           			c = va_arg(ap, int);
819:           #endif	// _HOSTED
820:           #endif	// CHAR
821:           		default:
822:           #ifdef	PERCPERC
823:           #if	defined(WIDTH) || defined(PRECISION)
824:           			cp = (char *)&c;
825:           			len = 1;
826:           			goto dostring;
827:           #else
828:           			pputc(c);
829:           			continue;
830:           #endif
831:           #else	// PERCPERC
832:           			continue;
833:           #endif
834:           
835:           #ifdef	UNSIGN
836:           		case 'u':
837:           			flag |= UNSIGN;
0BBA  8C1C     BSF flag, 6, ACCESS
838:           			break;
839:           #endif
840:           
841:           		}
0BBC  D017     BRA 0xBEC
842:           #endif	// ANYFORMAT
843:           #ifdef	__FLOAT
844:           		if(flag & (FLOATFORMAT)) {
845:           #ifdef	DEFPREC
846:           			if(flag & DEFPREC)
847:           #endif
848:           				prec = 6;
849:           			fval = va_arg(ap, double);	// source the floating point value
850:           			if(fval < 0.0) {
851:           				fval = -fval;		// get the absolute value
852:           				flag |= NEGSIGN;
853:           			}
854:           			eexp = 0;		/* If the number is zero, the exponent is zero. */
855:           			if( fval!=0) {		/* If the number is non-zero, find the exponent. */
856:           				frexp(fval, &eexp);		/* get binary exponent */
857:           				eexp--;				/* adjust 0.5 -> 1.0 */
858:           				eexp *= 3;
859:           				eexp /= 10;			/* estimate decimal exponent */
860:           				if(eexp < 0)
861:           					eexp--;
862:           				// the following line can cause "recursive call" errors because scale calls
863:           				// ftmul, and is used when evaluating an argument to ftmul
864:           				//integ = fval * scale(-eexp);
865:           				tmpval.integ = scale(-eexp);		// replaced with this
866:           				tmpval.integ *= fval;
867:           				if(tmpval.integ < 1.0)
868:           					eexp--;
869:           				else if(tmpval.integ >= 10.0)
870:           					eexp++;
871:           			}
872:           #if	defined(EFMT) || defined(GFMT)
873:           			if(eexp <= 0)	// value is 0.??? (neg expnt) whole characters = 1 (allow zero)
874:           				c = 1;
875:           			else
876:           				c = eexp;
877:           			if(
878:           #ifdef	EFMT
879:           					flag & EFMT
880:           #ifdef	GFMT
881:           					||
882:           #endif
883:           #endif
884:           #ifdef	GFMT
885:           					(flag & GFMT && (eexp < -4 || eexp >= (int)prec))
886:           #endif
887:           				) {	/* use e format */
888:           #ifdef	GFMT
889:           				if(prec && flag & GFMT)
890:           					prec--;		/* g format precision includes integer digit */
891:           #endif
892:           				if((unsigned)prec > NDDIG - 2)
893:           					c = NDDIG - 2;
894:           				else
895:           					c = prec;
896:           				if( fval!=0) {	/* Normalise only if the number is non-zero. */
897:           					fval /= scale(eexp-c);
898:           #if	DOUBLE
899:           					ival = _dto64i(fval);
900:           					if(fval - _64itod(ival) >= 0.5) {
901:           						fval += 0.5;
902:           						ival = _dto64i(fval);
903:           					}
904:           					if(ival >= fdpowers[c+1]) {
905:           						fval *= 1e-1;
906:           						eexp++;
907:           					} else if(ival < fdpowers[c]) {
908:           						fval *= 10.0;
909:           						eexp--;
910:           					}
911:           #else	
912:           					if(fval - (double)(unsigned long)fval >= 0.5)
913:           						fval += 0.5;
914:           					if((unsigned long)fval >= fdpowers[c+1]) {
915:           						fval *= 1e-1;
916:           						eexp++;
917:           					} else if((unsigned long)fval < fdpowers[c]) {
918:           						fval *= 10.0;
919:           						eexp--;
920:           					}
921:           #endif
922:           				}
923:           #if defined(GFMT) && defined(ALTERN)
924:           				if(flag & GFMT && !(flag & ALTERN)) {		/* g format, precision means something different */
925:           					if(prec > (int)(NDDIG))
926:           						prec = NDDIG;
927:           #if	DOUBLE
928:           					ival = _dto64i(fval);
929:           					while(ival != 0.0 && _mod64i10(ival) == 0) {
930:           						prec--;
931:           						ival = _div64(ival, fdpowers[1]);
932:           					}
933:           #else
934:           					val = (unsigned long)fval;
935:           					while(val && val % 10 == 0) {
936:           						prec--;
937:           						val /= 10;
938:           					}
939:           #endif
940:           					if(prec < c) {
941:           						fval /= scale(c-prec);
942:           						c = prec;
943:           					}
944:           
945:           				}
946:           #endif
947:           #ifdef	WIDTH
948:           				width -=  prec + 5;
949:           #ifdef	ALTERN
950:           				if(prec || flag & ALTERN)
951:           					width--;
952:           #endif
953:           				if(flag & NEGSIGN)
954:           					width--;
955:           #if	DBL_MAX_10_EXP >= 100
956:           #if	DBL_MAX_10_EXP >= 1000
957:           				if(eexp >= 1000 || eexp <= -1000)	/* 4 digit exponent */
958:           					width--;
959:           #endif
960:           				if(eexp >= 100 || eexp <= -100)	/* 3 digit exponent */
961:           					width--;
962:           #endif
963:           #endif	// WIDTH
964:           #ifdef	FILL
965:           				if(flag & FILL) {
966:           #if defined(MANSIGN) && defined(SPCSIGN)
967:           					if(flag & MANSIGN)
968:           						pputc(flag & SPCSIGN ? '-' : '+');
969:           					else if(flag & SPCSIGN)
970:           						pputc(' ');
971:           #endif
972:           					while(width > 0) {
973:           						pputc('0');
974:           						width--;
975:           					}
976:           				} else
977:           #endif	// FILL
978:           				{
979:           #ifdef	WIDTH
980:           #ifdef	LEFT
981:           					if(!(flag & LEFT))
982:           #endif
983:           						while(width > 0) {
984:           							pputc(' ');
985:           							width--;
986:           						}
987:           #endif	// WIDTH
988:           #ifdef	MANSIGN
989:           					if(flag & MANSIGN)
990:           						putsign();
991:           #else
992:           					if(flag & NEGSIGN)
993:           						pputc('-');
994:           #endif	// MANSIGN
995:           #ifdef	SPCSIGN
996:           					else if(flag & SPCSIGN)
997:           						pputc(' ');
998:           #endif	// SPCSIGN
999:           				}
1000:          #if	DOUBLE
1001:          				ival = _dto64i(fval);
1002:          				pputc(_div64ir(ival, fdpowers[c]) + '0');
1003:          #else
1004:          				val = (unsigned long)fval;
1005:          				pputc(val/dpowers[c] + '0');
1006:          				val %= dpowers[c];
1007:          #endif
1008:          #ifdef	ALTERN
1009:          				if(prec || flag & ALTERN)
1010:          #else
1011:          				if(prec)
1012:          #endif
1013:          				{
1014:          					pputc('.');
1015:          					prec -= c;
1016:          					while(c--) {
1017:          #if	DOUBLE
1018:          						pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1019:          #else
1020:          #ifdef	GFMT
1021:          						if(flag & GFMT && val == 0) {
1022:          							prec = c = 0;
1023:          							break;
1024:          						}
1025:          #endif
1026:          						pputc('0' + (val/dpowers[c]));
1027:          						val %= dpowers[c];
1028:          #endif
1029:          					}
1030:          					while(prec) {
1031:          						pputc('0');
1032:          						prec--;
1033:          					}
1034:          				}
1035:          #ifdef	UPCASE
1036:          				if(flag & UPCASE)
1037:          					pputc('E');
1038:          				else
1039:          #endif
1040:          					pputc('e');
1041:          				if(eexp < 0) {
1042:          					eexp = -eexp;
1043:          					pputc('-');
1044:          				} else
1045:          					pputc('+');
1046:          #if	DBL_MAX_10_EXP >= 100
1047:          #if	DBL_MAX_10_EXP >= 1000
1048:          				if(eexp >= 1000) {
1049:          					pputc(eexp / 1000 + '0');
1050:          					eexp %= 1000;
1051:          				}
1052:          #endif
1053:          				if(eexp >= 100) {
1054:          					pputc(eexp / 100 + '0');
1055:          					eexp %= 100;
1056:          				}
1057:          #endif
1058:          				pputc(eexp / 10 + '0');
1059:          				pputc(eexp % 10 + '0');
1060:          #ifdef	LEFT
1061:          				if((flag & LEFT) && width > 0)
1062:          					do
1063:          						pputc(' ');
1064:          					while(--width);
1065:          #endif	// LEFT
1066:          					continue;
1067:          				}
1068:          #endif	// EFMT || GFMT
1069:          				/* here for f format */
1070:          #if	DOUBLE
1071:          #ifdef	GFMT
1072:          				if(flag & GFMT) {
1073:          					if(eexp < 0)	// fractional part only
1074:          						prec -= eexp-1;
1075:          					ival = _dto64i(fval);
1076:          					for(c = 1 ; c != NDDIG ; c++)
1077:          						if(ival < fdpowers[c])
1078:          							break;
1079:          					if(prec > NDDIG)
1080:          						prec = NDDIG;
1081:          					prec -= c;
1082:          					ival = _dto64i((fval - _64itod(ival)) * scale(prec)+0.5);
1083:          					// see how many zeros are at the end of the fractional part
1084:          					while(prec && _mod64i10(ival) == 0) {
1085:          						prec--;
1086:          						ival = _div64(ival, fdpowers[1]);
1087:          					}
1088:          				}
1089:          #endif	// GFMT
1090:          				if(prec <= (int)NDDIG)
1091:          					fval += fround(prec);
1092:          				if(eexp > (int)(NDDIG)-2) {
1093:          					eexp -= NDDIG-2;
1094:          					ival = _divto64i(fval, scale(eexp));
1095:          					fval = 0.0;
1096:          				} else {
1097:          					ival = _dto64i(fval);
1098:          					fval -= _64itod(ival);
1099:          					eexp = 0;
1100:          				}
1101:          				for(c = 1 ; c != NDDIG ; c++)
1102:          					if(ival < fdpowers[c])
1103:          						break;
1104:          #else	// DOUBLE
1105:          #ifdef	GFMT
1106:          				if(flag & GFMT) {
1107:          					if(eexp < 0)	// fractional part only
1108:          						prec -= (eexp+1);
1109:          					// count number of digits in the integral part (this is for %g)
1110:          					val = (unsigned long)fval;
1111:          					for(c = 0 ; c != NDDIG ; c++)
1112:          						if(val < fdpowers[c])
1113:          							break;
1114:          					prec -= c;		// reduce precision by this
1115:          					if(prec <= NDIG)
1116:          						fval += fround(prec);
1117:          					// get fractional part and count trailing zeros - reduce
1118:          					// prec as required
1119:          					{
1120:          						double	temp;
1121:          						temp = scale(prec);
1122:          						temp *= fval - (double)val;
1123:          						val = (unsigned long)temp;
1124:          					}
1125:          					while(prec && val % 10 == 0) {
1126:          						val /= 10;
1127:          						prec--;
1128:          					}
1129:          				} else
1130:          #endif	//GFMT
1131:          					if(prec <= NDIG)
1132:          						fval += fround((uns_prec)prec);
1133:          
1134:          				/* ~4.2e9 is the largest float that will fit into a 32-bit long */
1135:          				if((eexp > 9)||(fval != 0 && (unsigned long)fval == 0 && eexp > 1)) {
1136:          					// fval is > 4.2e9
1137:          					// new eexp must be such that div_to_l() is < 4.2e9
1138:          					// OLD CODE:	if(fval / scale(eexp) < 4.294967296){
1139:          					if(tmpval.integ < 4.294967296){
1140:          						eexp -= NDDIG-1;
1141:          					}else{
1142:          						eexp -= NDDIG-2;
1143:          					}
1144:          					tmpval.integ = scale(eexp);
1145:          					val = div_to_l_(fval, tmpval.integ);
1146:           					//val = _div_to_l_(integ, fval);
1147:          					//val = (long)(integ * fval);	// fit as much signifigant data into the long as it can hold
1148:          					fval = 0.0;	// There will be no fractional component
1149:          				} else {
1150:          					val = (unsigned long)fval;
1151:          					fval -= (double)val;
1152:          					eexp = 0;
1153:          				}
1154:          				// count digits in integral part
1155:          				for(c = 1 ; c != NDDIG ; c++)
1156:          					if(val < fdpowers[c])
1157:          						break;
1158:          #endif	// DOUBLE
1159:          #ifdef	WIDTH
1160:          				// at this point, c contains the number of whole-number digits to print
1161:          				width -= prec + c + eexp;
1162:          				if(
1163:          #ifdef	ALTERN
1164:          						flag & ALTERN ||
1165:          #endif
1166:          						prec)
1167:          					width--;		// allow for decimal point
1168:          				if(flag & NEGSIGN)
1169:          					width--;
1170:          #endif	// WIDTH
1171:          #ifdef	FILL
1172:          				if(flag & FILL) {
1173:          #ifdef	MANSIGN
1174:          					if(flag & MANSIGN)
1175:          #else
1176:          					if(flag & NEGSIGN)
1177:          #endif	// MANSIGN
1178:          						putsign();
1179:          #if defined(MANSIGN) && defined(SPCSIGN)
1180:          					else
1181:          #endif
1182:          #ifdef	SPCSIGN
1183:          					if(flag & SPCSIGN)
1184:          						pputc(' ');
1185:          #endif	// SPCSIGN
1186:          #ifdef	WIDTH
1187:          					while(width > 0) {
1188:          						pputc('0');
1189:          						width--;
1190:          					}
1191:          #endif	// WIDTH
1192:          				} else
1193:          #endif	// FILL
1194:          				{
1195:          #ifdef	LEFT
1196:          					if(!(flag & LEFT))
1197:          #endif
1198:          #ifdef	WIDTH
1199:          					while(width > 0) {
1200:          						pputc(' ');
1201:          						width--;
1202:          					}
1203:          #endif	// WIDTH
1204:          #ifdef	MANSIGN
1205:          				if(flag & MANSIGN)
1206:          #else
1207:          				if(flag & NEGSIGN)
1208:          #endif	// MANSIGN
1209:          					putsign();
1210:          #ifdef	SPCSIGN
1211:          				else if(flag & SPCSIGN)
1212:          					pputc(' ');
1213:          #endif	// SPCSIGN
1214:          			}
1215:          			while(c--) {
1216:          #if	DOUBLE
1217:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1218:          #else
1219:          				{
1220:          					tmpval.vd = val/dpowers[c];
1221:          					tmpval.vd %= 10;
1222:          					pputc('0' + tmpval.vd);
1223:          				}
1224:          #endif	// DOUBLE
1225:          			}
1226:          			while(eexp > 0) {
1227:          				pputc('0');
1228:          				eexp--;
1229:          			}
1230:          			if(prec > (int)(NDDIG-2))
1231:          				c = NDDIG-2;
1232:          			else
1233:          				c = (char)prec;
1234:          			prec -= (prec_t)c;
1235:          #ifdef	ALTERN
1236:          			if(c || flag & ALTERN)
1237:          #else
1238:          			if(c)
1239:          #endif
1240:          				pputc('.');
1241:          #if	DOUBLE
1242:          			ival = _dto64i(fval * scale(c));
1243:          			while(c)
1244:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[--c])));
1245:          #else	// DOUBLE
1246:          			val = (unsigned value)(fval * scale((expon)c));
1247:          			while(c--) {
1248:          				tmpval.vd = val/dpowers[c];
1249:          				tmpval.vd %= 10;
1250:          				pputc('0' + tmpval.vd);
1251:          				val %= dpowers[c];
1252:          			}
1253:          #endif	// DOUBLE
1254:          			while(prec) {
1255:          				pputc('0');
1256:          				prec--;
1257:          			}
1258:          #ifdef	LEFT
1259:          			if((flag & LEFT) && width > 0)
1260:          				do
1261:          					pputc(' ');
1262:          				while(--width);
1263:          #endif
1264:          			continue;
1265:          		}
1266:          #endif	/* __FLOAT */
1267:          
1268:          #if	defined(TEN)
1269:          #ifdef	BASEM
1270:          		if((flag & BASEM) == TEN)
0BEC  BC1C     BTFSC flag, 6, ACCESS
0BEE  D015     BRA 0xC1A
1271:          #endif	//BASEM
1272:          		{
1273:          #ifdef	LONG
1274:          			if(flag & LONG)
1275:          				val = va_arg(ap, long);
1276:          			else
1277:          #endif	// LONG
1278:          				val = (value)va_arg(ap, int);
0BF0  C01A     MOVFF ap, FSR2
0BF2  FFD9     NOP
0BF4  C01B     MOVFF mL, FSR2H
0BF6  FFDA     NOP
0BF8  CFDE     MOVFF POSTINC2, val
0BFA  F01D     NOP
0BFC  CFDD     MOVFF POSTDEC2, 0x1E
0BFE  F01E     NOP
0C00  0E02     MOVLW 0x2
0C02  261A     ADDWF ap, F, ACCESS
0C04  0E00     MOVLW 0x0
0C06  221B     ADDWFC mL, F, ACCESS
1279:          #ifdef	NEGSIGN
1280:          			if((value)val < 0) {
0C08  AE1E     BTFSS 0x1E, 7, ACCESS
0C0A  D013     BRA 0xC32
1281:          				flag |= NEGSIGN;
0C0C  0E03     MOVLW 0x3
0C0E  121C     IORWF flag, F, ACCESS
1282:          				val = -val;
0C10  6C1D     NEGF val, ACCESS
0C12  1E1E     COMF 0x1E, F, ACCESS
0C14  B0D8     BTFSC STATUS, 0, ACCESS
0C16  2A1E     INCF 0x1E, F, ACCESS
1283:          			}
1284:          #endif
1285:          		}
0C18  D00C     BRA 0xC32
1286:          #ifdef	BASEM
1287:          		else
1288:          #endif
1289:          #endif	// TEN
1290:          
1291:          #if	defined(EIGHT) || defined(SIXTEEN) || defined(UNSIGN)
1292:          		{
1293:          #ifdef	__LONG
1294:          #if	defined(_PIC18) && defined(POINTER)
1295:          			if(flag & POINTER)
1296:          				val = (unsigned long)va_arg(ap, __far char *);
1297:          			else
1298:          #endif
1299:          #ifdef	LONG
1300:          				if(flag & LONG)
1301:          				val = va_arg(ap, unsigned long);
1302:          			else
1303:          #endif	// LONG
1304:          #endif	// __LONG
1305:          				val = va_arg(ap, unsigned);
0C1A  C01A     MOVFF ap, FSR2
0C1C  FFD9     NOP
0C1E  C01B     MOVFF mL, FSR2H
0C20  FFDA     NOP
0C22  CFDE     MOVFF POSTINC2, val
0C24  F01D     NOP
0C26  CFDD     MOVFF POSTDEC2, 0x1E
0C28  F01E     NOP
0C2A  0E02     MOVLW 0x2
0C2C  261A     ADDWF ap, F, ACCESS
0C2E  0E00     MOVLW 0x0
0C30  221B     ADDWFC mL, F, ACCESS
1306:          		}
1307:          #endif	// EIGHT or SIXTEEN or UNSIGN
1308:          #ifdef	PRECISION
1309:          		if(prec == 0 && val == 0)
1310:          			prec++;
1311:          #endif
1312:          #ifdef	MULTRAD
1313:          		switch((unsigned char)(flag & BASEM)) {
1314:          #endif
1315:          #if	defined(TEN) || defined(UNSIGN)
1316:          #ifdef	MULTRAD
1317:          #ifdef	TEN
1318:          		case TEN:
1319:          #endif
1320:          #ifdef	UNSIGN
1321:          		case UNSIGN:
1322:          #endif
1323:          #endif	// MULTRAD
1324:          			for(c = 1 ; c != sizeof dpowers/sizeof dpowers[0] ; c++)
0C32  0E01     MOVLW 0x1
0C34  6E1F     MOVWF c, ACCESS
0C36  0E05     MOVLW 0x5
0C38  181F     XORWF c, W, ACCESS
0C3A  B4D8     BTFSC STATUS, 2, ACCESS
0C3C  D012     BRA 0xC62
0C5E  2A1F     INCF c, F, ACCESS
0C60  D7EA     BRA 0xC36
1325:          				if(val < dpowers[c])
0C3E  501F     MOVF c, W, ACCESS
0C40  0D02     MULLW 0x2
0C42  0E01     MOVLW 0x1
0C44  24F3     ADDWF PROD, W, ACCESS
0C46  6EF6     MOVWF TBLPTR, ACCESS
0C48  0E03     MOVLW 0x3
0C4A  20F4     ADDWFC PRODH, W, ACCESS
0C4C  6EF7     MOVWF TBLPTRH, ACCESS
0C4E  0009     TBLRD*+
0C50  50F5     MOVF TABLAT, W, ACCESS
0C52  5C1D     SUBWF val, W, ACCESS
0C54  0009     TBLRD*+
0C56  50F5     MOVF TABLAT, W, ACCESS
0C58  581E     SUBWFB 0x1E, W, ACCESS
0C5A  A0D8     BTFSS STATUS, 0, ACCESS
0C5C  D002     BRA 0xC62
1326:          					break;
1327:          #ifdef	MULTRAD
1328:          			break;
1329:          #endif
1330:          #endif	// TEN || UNSIGN
1331:          #ifdef	SIXTEEN
1332:          #ifdef	MULTRAD
1333:          		case SIXTEEN:
1334:          #endif	// MULTRAD
1335:          			for(c = 1 ; c != sizeof hexpowers/sizeof hexpowers[0] ; c++)
1336:          				if(val < hexpowers[c])
1337:          					break;
1338:          #ifdef	MULTRAD
1339:          			break;
1340:          #endif
1341:          #endif
1342:          
1343:          #ifdef	EIGHT
1344:          #ifdef	MULTRAD
1345:          		case EIGHT:
1346:          #endif	// MULTRAD
1347:          			for(c = 1 ; c != sizeof octpowers/sizeof octpowers[0] ; c++)
1348:          				if(val < octpowers[c])
1349:          					break;
1350:          #ifdef	MULTRAD
1351:          			break;
1352:          #endif
1353:          #endif
1354:          #ifdef	MULTRAD
1355:          		}
1356:          #endif
1357:          #ifdef	PRECISION
1358:          		if(c < prec)
1359:          			c = prec;
1360:          		else if(prec < c)
1361:          			prec = c;
1362:          #endif
1363:          #if	defined(WIDTH) && defined(NEGSIGN)
1364:          		if(width && flag & NEGSIGN)
1365:          			width--;
1366:          #ifdef	PRECISION
1367:          		if(flag & PRECISION) {
1368:          			if(width > prec)
1369:          				width -= prec;
1370:          			else
1371:          				width = 0;
1372:          		}
1373:          #endif
1374:          #ifdef	ALTERN
1375:          #ifdef	EIGHT
1376:          		if((flag & (
1377:          #ifdef	FILL
1378:          						FILL|
1379:          #endif
1380:          							BASEM|ALTERN)) == (EIGHT|ALTERN)) {
1381:          			if(width)
1382:          				width--;
1383:          		} else
1384:          #endif	// EIGHT
1385:          #if	defined(SIXTEEN)
1386:          #ifdef	BASEM
1387:          		if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1388:          #else
1389:          		if(flag & ALTERN) {
1390:          #endif
1391:          			if(width > 2)
1392:          				width -= 2;
1393:          			else
1394:          				width = 0;
1395:          		}
1396:          #endif	// SIXTEEN
1397:          #endif	// ALTERN
1398:          #endif	// WIDTH
1399:          #ifdef	WIDTH
1400:          		if(width > c)
1401:          			width -= c;
1402:          		else
1403:          			width = 0;
1404:          #endif
1405:          #ifdef	FILL
1406:          		if(flag & FILL) {
1407:          #ifdef	MANSIGN
1408:          			if(flag & MANSIGN)
1409:          				putsign();
1410:          #elif defined(NEGSIGN)
1411:          			if(flag & NEGSIGN)
1412:          				pputc('-');
1413:          #endif
1414:          #if defined(MANSIGN) || defined(NEGSIGN) && defined(SPCSIGN)
1415:          			else
1416:          #endif	// MANSIGN
1417:          #ifdef	SPCSIGN
1418:          			if(flag & SPCSIGN)
1419:          				pputc(' ');
1420:          #endif
1421:          #if defined(ALTERN) && defined(SIXTEEN) && defined(BASEM)
1422:          			else if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1423:          				pputc('0');
1424:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1425:          				pputc(flag & UPCASE ? 'X' : 'x');
1426:          #elif defined(HEXUPCASE)
1427:          				pputc('X');
1428:          #else
1429:          				pputc('x');
1430:          #endif	// HEXUPCASE
1431:          			}
1432:          #endif	// ALTERN
1433:          #ifdef	WIDTH
1434:          			if(width)
1435:          				do
1436:          					pputc('0');
1437:          				while(--width);
1438:          #endif	// WIDTH
1439:          		} else
1440:          #endif	//FILL
1441:          		{
1442:          #ifdef	WIDTH
1443:          			if(width
1444:          #ifdef	LEFT
1445:          					&& !(flag & LEFT)
1446:          #endif
1447:          					)
1448:          				do
1449:          					pputc(' ');
1450:          				while(--width);
1451:          #endif	// WIDTH
1452:          #ifdef	MANSIGN
1453:          			if(flag & MANSIGN)
1454:          				putsign();
1455:          #else
1456:          #ifdef	NEGSIGN
1457:          			if(flag & NEGSIGN)
0C62  C01C     MOVFF flag, 0x18
0C64  F018     NOP
0C66  0E03     MOVLW 0x3
0C68  1618     ANDWF 0x18, F, ACCESS
0C6A  B4D8     BTFSC STATUS, 2, ACCESS
0C6C  D008     BRA 0xC7E
1458:          				pputc('-');
0C6E  C012     MOVFF quotient, FSR2
0C70  FFD9     NOP
0C72  C013     MOVFF 0x13, FSR2H
0C74  FFDA     NOP
0C76  0E2D     MOVLW 0x2D
0C78  6EDF     MOVWF INDF2, ACCESS
0C7A  4A12     INFSNZ quotient, F, ACCESS
0C7C  2A13     INCF 0x13, F, ACCESS
1459:          #endif
1460:          #endif	// MANSIGN
1461:          #ifdef	SPCSIGN
1462:          			else if(flag & SPCSIGN)
1463:          				pputc(' ');
1464:          #endif
1465:          #ifdef	ALTERN
1466:          #ifdef	EIGHT
1467:          			if((flag & (BASEM|ALTERN)) == (EIGHT|ALTERN))
1468:          				pputc('0');
1469:          			else
1470:          #endif	// EIGHT
1471:          #ifdef	SIXTEEN
1472:          #ifdef	BASEM
1473:          			if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1474:          #else
1475:          			if(flag & ALTERN) {
1476:          #endif
1477:          				pputc('0');
1478:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1479:          				pputc(flag & UPCASE ? 'X' : 'x');
1480:          #elif defined(HEXUPCASE)
1481:          				pputc('X');
1482:          #else
1483:          				pputc('x');
1484:          #endif
1485:          			}
1486:          #endif	// SIXTEEN
1487:          #endif	// ALTERN
1488:          		}
1489:          #if	defined(SIXTEEN) || defined(TEN) || defined(EIGHT) || defined(UNSIGN)
1490:          #ifndef	PRECISION
1491:          		prec = c;
0C7E  C01F     MOVFF c, prec
0C80  F019     NOP
1492:          #endif
1493:          		while(prec--) {
0C82  D029     BRA 0xCD6
1494:          #ifdef	MULTRAD
1495:          			switch((unsigned char)(flag & BASEM))
1496:          #endif
1497:          			{
1498:          
1499:          #if	defined(TEN) || defined(UNSIGN)
1500:          #ifdef	MULTRAD
1501:          #ifdef	TEN
1502:          		case TEN:
1503:          #endif
1504:          #ifdef	UNSIGN
1505:          		case UNSIGN:
1506:          #endif
1507:          #endif	// MULTRAD
1508:          				c = (val / dpowers[prec]) % 10 + '0';
0C84  5019     MOVF prec, W, ACCESS
0C86  0D02     MULLW 0x2
0C88  0E01     MOVLW 0x1
0C8A  24F3     ADDWF PROD, W, ACCESS
0C8C  6EF6     MOVWF TBLPTR, ACCESS
0C8E  0E03     MOVLW 0x3
0C90  20F4     ADDWFC PRODH, W, ACCESS
0C92  6EF7     MOVWF TBLPTRH, ACCESS
0C94  0009     TBLRD*+
0C96  CFF5     MOVFF TABLAT, type
0C98  F008     NOP
0C9A  000A     TBLRD*-
0C9C  CFF5     MOVFF TABLAT, Byte
0C9E  F009     NOP
0CA0  C01D     MOVFF val, Values
0CA2  F006     NOP
0CA4  C01E     MOVFF 0x1E, number
0CA6  F007     NOP
0CA8  EC65     CALL 0x12CA, 0
0CAA  F009     NOP
0CAC  C006     MOVFF Values, dividend
0CAE  F00D     NOP
0CB0  C007     MOVFF number, divisor
0CB2  F00E     NOP
0CB4  0E00     MOVLW 0x0
0CB6  6E10     MOVWF counter, ACCESS
0CB8  0E0A     MOVLW 0xA
0CBA  6E0F     MOVWF divisor, ACCESS
0CBC  EC8E     CALL 0x131C, 0
0CBE  F009     NOP
0CC0  500D     MOVF dividend, W, ACCESS
0CC2  0F30     ADDLW 0x30
0CC4  6E1F     MOVWF c, ACCESS
1509:          #ifdef	MULTRAD
1510:          				break;
1511:          #endif
1512:          #endif	// TEN || UNSIGN
1513:          
1514:          #ifdef	SIXTEEN
1515:          #ifdef	MULTRAD
1516:          			case SIXTEEN:
1517:          #endif
1518:          			{
1519:          				unsigned char idx = (val / hexpowers[prec]) & 0xF;
1520:          #if	defined(HEXLOWCASE) && defined(HEXUPCASE)
1521:          				c = (flag & UPCASE ? "0123456789ABCDEF" : "0123456789abcdef")[idx];
1522:          #elif	defined(HEXUPCASE)
1523:          				c = "0123456789ABCDEF"[idx];
1524:          #else
1525:          				c = "0123456789abcdef"[idx];
1526:          #endif	//HEXCASE
1527:          			}
1528:          #ifdef	MULTRAD
1529:          				break;
1530:          #endif
1531:          #endif
1532:          
1533:          #ifdef	EIGHT
1534:          #ifdef	MULTRAD
1535:          			case EIGHT:
1536:          #endif	// MULTRAD
1537:          				c = ((val / octpowers[prec]) & 07) + '0';
1538:          #ifdef	MULTRAD
1539:          				break;
1540:          #endif	// MULTRAD
1541:          #endif	// EIGHT
1542:          			}
1543:          			pputc(c);
0CC6  C012     MOVFF quotient, FSR2
0CC8  FFD9     NOP
0CCA  C013     MOVFF 0x13, FSR2H
0CCC  FFDA     NOP
0CCE  C01F     MOVFF c, INDF2
0CD0  FFDF     NOP
0CD2  4A12     INFSNZ quotient, F, ACCESS
0CD4  2A13     INCF 0x13, F, ACCESS
1544:          		}
0CD6  0619     DECF prec, F, ACCESS
0CD8  2819     INCF prec, W, ACCESS
0CDA  A4D8     BTFSS STATUS, 2, ACCESS
0CDC  D7D3     BRA 0xC84
1545:          #endif	// 16 or 10 or 8
1546:          #ifdef	LEFT
1547:          		if((flag & LEFT) && width > 0)
1548:          			do
1549:          				pputc(' ');
1550:          			while(--width);
1551:          #endif	// LEFT
1552:          	}
1553:          #ifdef	ANYFORMAT
1554:          alldone:
1555:          #endif	// ANYFORMAT
1556:          #if	!defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
1557:          	*sp = 0;
0CF6  C012     MOVFF quotient, FSR2
0CF8  FFD9     NOP
0CFA  C013     MOVFF 0x13, FSR2H
0CFC  FFDA     NOP
0CFE  0E00     MOVLW 0x0
0D00  6EDF     MOVWF INDF2, ACCESS
0D02  0012     RETURN 0
1558:          #endif
1559:          	return ccnt;
1560:          }
1561:          
---  /Applications/microchip/xc8/v2.00/pic/sources/c90/common/awdiv.c  ----------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awdiv(signed int divisor, signed int dividend)
6:             #else
7:             __awdiv(signed int dividend, signed int divisor)
8:             #endif
9:             {
10:            	signed int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
10F4  0E00     MOVLW 0x0
10F6  6E11     MOVWF sign, ACCESS
14:            	if(divisor < 0) {
10F8  AE0F     BTFSS divisor, 7, ACCESS
10FA  D006     BRA 0x1108
15:            		divisor = -divisor;
10FC  6C0E     NEGF divisor, ACCESS
10FE  1E0F     COMF divisor, F, ACCESS
1100  B0D8     BTFSC STATUS, 0, ACCESS
1102  2A0F     INCF divisor, F, ACCESS
16:            		sign = 1;
1104  0E01     MOVLW 0x1
1106  6E11     MOVWF sign, ACCESS
17:            	}
18:            	if(dividend < 0) {
1108  AE0D     BTFSS dividend, 7, ACCESS
110A  D006     BRA 0x1118
19:            		dividend = -dividend;
110C  6C0C     NEGF counter, ACCESS
110E  1E0D     COMF dividend, F, ACCESS
1110  B0D8     BTFSC STATUS, 0, ACCESS
1112  2A0D     INCF dividend, F, ACCESS
20:            		sign ^= 1;
1114  0E01     MOVLW 0x1
1116  1A11     XORWF sign, F, ACCESS
21:            	}
22:            	quotient = 0;
1118  0E00     MOVLW 0x0
111A  6E13     MOVWF 0x13, ACCESS
111C  0E00     MOVLW 0x0
111E  6E12     MOVWF quotient, ACCESS
23:            	if(divisor != 0) {
1120  500E     MOVF divisor, W, ACCESS
1122  100F     IORWF divisor, W, ACCESS
1124  B4D8     BTFSC STATUS, 2, ACCESS
1126  D01C     BRA 0x1160
24:            		counter = 1;
1128  0E01     MOVLW 0x1
112A  6E10     MOVWF counter, ACCESS
25:            		while((divisor & 0x8000U) == 0) {
112C  D004     BRA 0x1136
26:            			divisor <<= 1;
112E  90D8     BCF STATUS, 0, ACCESS
1130  360E     RLCF divisor, F, ACCESS
1132  360F     RLCF divisor, F, ACCESS
27:            			counter++;
1134  2A10     INCF counter, F, ACCESS
28:            		}
1136  AE0F     BTFSS divisor, 7, ACCESS
1138  D7FA     BRA 0x112E
29:            		do {
30:            			quotient <<= 1;
113A  90D8     BCF STATUS, 0, ACCESS
113C  3612     RLCF quotient, F, ACCESS
113E  3613     RLCF 0x13, F, ACCESS
31:            			if((unsigned int)divisor <= (unsigned int)dividend) {
1140  500E     MOVF divisor, W, ACCESS
1142  5C0C     SUBWF counter, W, ACCESS
1144  500F     MOVF divisor, W, ACCESS
1146  580D     SUBWFB dividend, W, ACCESS
1148  A0D8     BTFSS STATUS, 0, ACCESS
114A  D005     BRA 0x1156
32:            				dividend -= divisor;
114C  500E     MOVF divisor, W, ACCESS
114E  5E0C     SUBWF counter, F, ACCESS
1150  500F     MOVF divisor, W, ACCESS
1152  5A0D     SUBWFB dividend, F, ACCESS
33:            				quotient |= 1;
1154  8012     BSF quotient, 0, ACCESS
34:            			}
35:            			*(unsigned int *)&divisor >>= 1;
1156  90D8     BCF STATUS, 0, ACCESS
1158  320F     RRCF divisor, F, ACCESS
115A  320E     RRCF divisor, F, ACCESS
36:            		} while(--counter != 0);
115C  2E10     DECFSZ counter, F, ACCESS
115E  D7ED     BRA 0x113A
37:            	}
38:            	if(sign)
1160  5011     MOVF sign, W, ACCESS
1162  B4D8     BTFSC STATUS, 2, ACCESS
1164  D004     BRA 0x116E
39:            		quotient = -quotient;
1166  6C12     NEGF quotient, ACCESS
1168  1E13     COMF 0x13, F, ACCESS
116A  B0D8     BTFSC STATUS, 0, ACCESS
116C  2A13     INCF 0x13, F, ACCESS
40:            	return quotient;
116E  C012     MOVFF quotient, counter
1170  F00C     NOP
1172  C013     MOVFF 0x13, dividend
1174  F00D     NOP
1176  0012     RETURN 0
41:            }
---  /Applications/microchip/xc8/v2.00/pic/sources/c90/common/Umul16.c  ---------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
13EA  5006     MOVF Values, W, ACCESS
13EC  0208     MULWF type, ACCESS
13EE  CFF3     MOVFF PROD, string
13F0  F00A     NOP
13F2  CFF4     MOVFF PRODH, pa
13F4  F00B     NOP
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
13F6  5006     MOVF Values, W, ACCESS
13F8  0209     MULWF Byte, ACCESS
13FA  50F3     MOVF PROD, W, ACCESS
13FC  260B     ADDWF pa, F, ACCESS
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
13FE  5007     MOVF number, W, ACCESS
1400  0208     MULWF type, ACCESS
1402  50F3     MOVF PROD, W, ACCESS
1404  260B     ADDWF pa, F, ACCESS
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
1406  C00A     MOVFF string, Values
1408  F006     NOP
140A  C00B     MOVFF pa, number
140C  F007     NOP
140E  0012     RETURN 0
53:            }
