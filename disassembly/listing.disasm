Disassembly Listing for final
Generated From:
/Users/hasan/Box Sync/me4/ecm/dist/default/production/ecm.production.elf
Dec 4, 2018 11:28:57 AM

---  /Users/hasan/Box Sync/me4/ecm/rfid.c  --------------------------------------------------------------
1:             #include "rfid.h"
2:             
3:             void init_RFID(void) {
4:                 TRISC = TRISC | 0b11000000; //set data direction registers to the TRGIF tag
1BDA  5094     MOVF TRISC, W, ACCESS
1BDC  09C0     IORLW 0xC0
1BDE  6E94     MOVWF TRISC, ACCESS
5:                 SPBRG = 204; //set baud rate to 9600
1BE0  0ECC     MOVLW 0xCC
1BE2  6EAF     MOVWF SPBRG, ACCESS
6:                 SPBRGH = 0;
1BE4  0E00     MOVLW 0x0
1BE6  6EB0     MOVWF SPBRGH, ACCESS
7:                 BAUDCONbits.BRG16 = 1; //set baud rate scaling to 16 bit mode
1BE8  86AA     BSF BAUDCON, 3, ACCESS
8:                 TXSTAbits.BRGH = 1; //high baud rate select bit
1BEA  84AC     BSF TXSTA, 2, ACCESS
9:                 RCSTAbits.CREN = 1; //continous receive mode
1BEC  88AB     BSF RCSTA, 4, ACCESS
10:                RCSTAbits.SPEN = 1; //enable serial port, other settings default
1BEE  8EAB     BSF RCSTA, 7, ACCESS
11:                TXSTAbits.TXEN = 1; //enable transmitter, other settings default
1BF0  8AAC     BSF TXSTA, 5, ACCESS
12:            }
1BF2  0012     RETURN 0
13:            
14:            void interrupt_EUSART(void) {
15:                RCREG;
1C0A  50AE     MOVF RCREG, W, ACCESS
16:                RCREG;
1C0C  50AE     MOVF RCREG, W, ACCESS
17:                RCREG; //Calling RCREG to clear any previous data
1C0E  50AE     MOVF RCREG, W, ACCESS
18:                PIE1bits.RCIE = 1; //Enable EUSART interrupt
1C10  8A9D     BSF PIE1, 5, ACCESS
19:                INTCONbits.GIEL = 1; //enable peripheral interrupts
1C12  8CF2     BSF INTCON, 6, ACCESS
20:                INTCONbits.GIEH = 1; //enable global interrupts
1C14  8EF2     BSF INTCON, 7, ACCESS
21:                INTCON3bits.INT2IE = 1; //enable external interrupts
1C16  88F0     BSF INTCON3, 4, ACCESS
22:            }
1C18  0012     RETURN 0
23:            //this functions inputs the address of the RFID string array. Values in the LCD displaying ir readings are cleared and the RFID string is sent to the LCD
24:            
25:            void print_RFID(char *pa, char *dis) {
26:            
27:                LCD_clear(); //Remove the current data displayed in the LCD
17D4  ECC5     CALL 0x1B8A, 0
17D6  F00D     NOP
28:                LCD_line(1);
17D8  0E01     MOVLW 0x1
17DA  EC61     CALL 0x1AC2, 0
17DC  F00D     NOP
29:                while (*pa != 0x03) { //Finds the address at the last RFID character
17DE  D002     BRA 0x17E4
30:                    pa++;
17E0  4A0B     INFSNZ pa, F, ACCESS
17E2  2A0C     INCF dividend, F, ACCESS
31:                }
17E4  C00B     MOVFF pa, FSR2
17E6  FFD9     NOP
17E8  C00C     MOVFF dividend, FSR2H
17EA  FFDA     NOP
17EC  0E03     MOVLW 0x3
17EE  18DE     XORWF POSTINC2, W, ACCESS
17F0  B4D8     BTFSC STATUS, 2, ACCESS
17F2  D012     BRA 0x1818
17F4  D7F5     BRA 0x17E0
32:            
33:                //Send ASCII characters read from the RFID string to the LCD
34:                while ((dis + 1) < (pa - 2)) { //dis is the address at the first value of the rfid string array. Starting at dis + 1 and finishing at pa - 2 removes undesired ASCII characters read by the RFID.
35:            
36:                    LCD_send(*(dis + 1), 1);
17F6  0E01     MOVLW 0x1
17F8  6E08     MOVWF type, ACCESS
17FA  EE20     LFSR 2, 0x1
17FC  F001     NOP
17FE  500D     MOVF dis, W, ACCESS
1800  26D9     ADDWF FSR2, F, ACCESS
1802  500E     MOVF divisor, W, ACCESS
1804  22DA     ADDWFC FSR2H, F, ACCESS
1806  50DF     MOVF INDF2, W, ACCESS
1808  EC79     CALL 0x1AF2, 0
180A  F00D     NOP
37:                    __delay_us(50);
180C  0E21     MOVLW 0x21
180E  2EE8     DECFSZ WREG, F, ACCESS
1810  D7FE     BRA 0x180E
1812  F000     NOP
38:            
39:                    dis++;
1814  4A0D     INFSNZ dis, F, ACCESS
1816  2A0E     INCF divisor, F, ACCESS
40:                }
1818  0EFE     MOVLW 0xFE
181A  6E0F     MOVWF s, ACCESS
181C  0EFF     MOVLW 0xFF
181E  6E10     MOVWF counter, ACCESS
1820  C00B     MOVFF pa, fp
1822  F011     NOP
1824  C00C     MOVFF dividend, quotient
1826  F012     NOP
1828  500F     MOVF s, W, ACCESS
182A  2611     ADDWF fp, F, ACCESS
182C  5010     MOVF counter, W, ACCESS
182E  2212     ADDWFC quotient, F, ACCESS
1830  0E01     MOVLW 0x1
1832  240D     ADDWF dis, W, ACCESS
1834  6E13     MOVWF c, ACCESS
1836  0E00     MOVLW 0x0
1838  200E     ADDWFC divisor, W, ACCESS
183A  6E14     MOVWF i, ACCESS
183C  5011     MOVF fp, W, ACCESS
183E  5C13     SUBWF c, W, ACCESS
1840  5012     MOVF quotient, W, ACCESS
1842  5814     SUBWFB i, W, ACCESS
1844  A0D8     BTFSS STATUS, 0, ACCESS
1846  D7D7     BRA 0x17F6
41:                LCD_line(2); // Set next line for the checksum display function
1848  0E02     MOVLW 0x2
184A  EC61     CALL 0x1AC2, 0
184C  F00D     NOP
42:            }
184E  0012     RETURN 0
43:            
44:            
45:            // This function calls the stored RFID string initial value address. The stores RFID string has 12 valuable characters in ASCII format. These are transformed into hexadecimal and stored in the array_check array. low and high bits are combined to form 16 bit integers in the bit_16 array, where the first 5 values are XORed and compared to the 6th value. If satisfied, checksum is correct.
46:            
47:            void check_sum(char *str, char *arr_check, int *bit16, int btc) {
48:            
49:                //Conversion of the string from ASCII to Hexadecimal
50:                int i = 0;
51:                while (i < 12) { // store the 12 valuable characters of the RFID called with the *str address into the array_check array
52:                    if ((*(str + 1) >> 6) == 1) { //If the (str + 1)th character in the RFID string is an ASCII letter, subtract 55 and move to the next character
53:                        *(arr_check) = *(str + 1) - 55;
54:                        str++;
55:                        arr_check++;
56:                        i++;
57:                    } else { //else if it is an ASCII number, subtract 48 and move to the next character
58:                        *(arr_check) = *(str + 1) - 48;
59:                        str++;
60:                        arr_check++;
61:                        i++;
62:                    }
63:                }
64:            
65:                for (char j = 0; j < 6; j++) { //bit_16(count) is written with overlaid low and high bits from the array_check array, compressing a 12 dimensional array into a 6 dimensional array 
66:                    *bit16 = (*(arr_check + 2 * j - 12) << 8) | *(arr_check + 2 * j + 1 - 12); //previous arr_check stopped at 12th position, thus - 12 is necessary to start at the first position of array_check
67:                    bit16++; //move to the next address in the bit_16 array
68:                }
69:            
70:                int xor_value = ((*(bit16 - 6))^(*(bit16 - 5))^(*(bit16 - 4))^(*(bit16 - 3))^(*(bit16 - 2))); // calculate the XOR value of the first 5 entries of the bit_16 array (starts at -6 instead of -5 because the bit16 address is increased in the last iteration above).
71:            
72:                char buf_cs[16];
73:                if (xor_value == *(bit16 - 1)) { //check if the calculated XOR value is identical to the RFID string checksum value and display condition in the LCD display
74:                    sprintf(buf_cs, "CS CORRECT %d", btc); //Also displaying the value of back trace counter to see the number of steps
75:                    LCD_string(buf_cs);
76:                } else {
77:                    sprintf(buf_cs, "CS INCORRECT %d", btc);
78:                    LCD_string(buf_cs);
79:                }
80:            
81:            }
82:            
83:            
84:            
85:            
86:            
---  /Users/hasan/Box Sync/me4/ecm/motor.c  -------------------------------------------------------------
1:             #include "motor.h"
2:             #define POWER 100
3:             #define POWER2 50
4:             #define POWER3 50
5:             void initTimer0(void) {
6:                 T0CONbits.TMR0ON = 1; //turn on timer0
7:                 T0CONbits.T016BIT = 0; // 16bit mode
8:                 T0CONbits.T0CS = 1; // Transition on T0CKI pin input edge
9:                 T0CONbits.PSA = 0; //Enable prescaler
10:                T0CONbits.T0PS = 0b001; // set prescaler value to 4
11:                T0CONbits.T0SE = 0; // Increment on low-to-high transition on T0CKI pin
12:                TMR0L = 0; //Initialise TMR0L and TMR0H to 0, these are re-set to 0 every time the back_trace_counter step increases
13:                TMR0H = 0;
14:            }
15:            
16:            /*
17:             * To initialise motor PWM
18:             */
19:            void initPWM(void) {
20:                TRISB = 0; //setting port as output TODO remove 
1B6C  0E00     MOVLW 0x0
1B6E  6E93     MOVWF TRISB, ACCESS
21:            
22:                PTCON0 = 0b00000000;
1B70  0E00     MOVLW 0x0
1B72  6E7F     MOVWF PTCON0, ACCESS
23:                PTCON1 = 0b10000000;
1B74  0E80     MOVLW 0x80
1B76  6E7E     MOVWF PTCON1, ACCESS
24:            
25:                PWMCON0 = 0b01111111;
1B78  0E7F     MOVLW 0x7F
1B7A  6E6F     MOVWF PWMCON0, ACCESS
26:                PWMCON1 = 0x00;
1B7C  0E00     MOVLW 0x0
1B7E  6E6E     MOVWF PWMCON1, ACCESS
27:            
28:                /*base period low and high bytes*/
29:                PTPERL = 0b11000111;
1B80  0EC7     MOVLW 0xC7
1B82  6E7B     MOVWF PTPERL, ACCESS
30:                PTPERH = 0b0000;
1B84  0E00     MOVLW 0x0
1B86  6E7A     MOVWF PTPERH, ACCESS
31:            }
1B88  0012     RETURN 0
32:            
33:            void setMotorPWM(struct Motor *m) {
34:                int PWMduty; //tmp variable to store PWM duty cycle
35:                if (m->direction) { //if forward
0BEC  EE20     LFSR 2, 0x1
0BEE  F001     NOP
0BF0  5014     MOVF i, W, ACCESS
0BF2  26D9     ADDWF FSR2, F, ACCESS
0BF4  5015     MOVF 0x15, W, ACCESS
0BF6  22DA     ADDWFC FSR2H, F, ACCESS
0BF8  50DF     MOVF INDF2, W, ACCESS
0BFA  B4D8     BTFSC STATUS, 2, ACCESS
0BFC  D034     BRA 0xC66
36:                    // low time increases with power
37:                    PWMduty = m->period - ((int) (m->power)*(m->period)) / 100;
0BFE  EE20     LFSR 2, 0x7
0C00  F007     NOP
0C02  5014     MOVF i, W, ACCESS
0C04  26D9     ADDWF FSR2, F, ACCESS
0C06  5015     MOVF 0x15, W, ACCESS
0C08  22DA     ADDWFC FSR2H, F, ACCESS
0C0A  CFDE     MOVFF POSTINC2, fp
0C0C  F016     NOP
0C0E  CFDD     MOVFF POSTDEC2, sign
0C10  F017     NOP
0C12  C014     MOVFF i, FSR2
0C14  FFD9     NOP
0C16  C015     MOVFF 0x15, FSR2H
0C18  FFDA     NOP
0C1A  50DF     MOVF INDF2, W, ACCESS
0C1C  6E18     MOVWF buf, ACCESS
0C1E  5018     MOVF buf, W, ACCESS
0C20  6E06     MOVWF Values, ACCESS
0C22  6A07     CLRF number, ACCESS
0C24  EE20     LFSR 2, 0x7
0C26  F007     NOP
0C28  5014     MOVF i, W, ACCESS
0C2A  26D9     ADDWF FSR2, F, ACCESS
0C2C  5015     MOVF 0x15, W, ACCESS
0C2E  22DA     ADDWFC FSR2H, F, ACCESS
0C30  CFDE     MOVFF POSTINC2, type
0C32  F008     NOP
0C34  CFDD     MOVFF POSTDEC2, Byte
0C36  F009     NOP
0C38  ECA3     CALL 0x1B46, 0
0C3A  F00D     NOP
0C3C  C006     MOVFF Values, dividend
0C3E  F00C     NOP
0C40  C007     MOVFF number, dis
0C42  F00D     NOP
0C44  0E00     MOVLW 0x0
0C46  6E0F     MOVWF s, ACCESS
0C48  0E64     MOVLW 0x64
0C4A  6E0E     MOVWF divisor, ACCESS
0C4C  ECA8     CALL 0x1750, 0
0C4E  F00B     NOP
0C50  1E0C     COMF dividend, F, ACCESS
0C52  1E0D     COMF dis, F, ACCESS
0C54  4A0C     INFSNZ dividend, F, ACCESS
0C56  2A0D     INCF dis, F, ACCESS
0C58  5016     MOVF fp, W, ACCESS
0C5A  240C     ADDWF dividend, W, ACCESS
0C5C  6E19     MOVWF PWMduty, ACCESS
0C5E  5017     MOVF sign, W, ACCESS
0C60  200D     ADDWFC dis, W, ACCESS
0C62  6E1A     MOVWF p, ACCESS
38:                } else { //if reverse
0C64  D023     BRA 0xCAC
39:                    // high time increases with power
40:                    PWMduty = ((int) (m->power)*(m->period)) / 100;
0C66  C014     MOVFF i, FSR2
0C68  FFD9     NOP
0C6A  C015     MOVFF 0x15, FSR2H
0C6C  FFDA     NOP
0C6E  50DF     MOVF INDF2, W, ACCESS
0C70  6E16     MOVWF fp, ACCESS
0C72  5016     MOVF fp, W, ACCESS
0C74  6E06     MOVWF Values, ACCESS
0C76  6A07     CLRF number, ACCESS
0C78  EE20     LFSR 2, 0x7
0C7A  F007     NOP
0C7C  5014     MOVF i, W, ACCESS
0C7E  26D9     ADDWF FSR2, F, ACCESS
0C80  5015     MOVF 0x15, W, ACCESS
0C82  22DA     ADDWFC FSR2H, F, ACCESS
0C84  CFDE     MOVFF POSTINC2, type
0C86  F008     NOP
0C88  CFDD     MOVFF POSTDEC2, Byte
0C8A  F009     NOP
0C8C  ECA3     CALL 0x1B46, 0
0C8E  F00D     NOP
0C90  C006     MOVFF Values, dividend
0C92  F00C     NOP
0C94  C007     MOVFF number, dis
0C96  F00D     NOP
0C98  0E00     MOVLW 0x0
0C9A  6E0F     MOVWF s, ACCESS
0C9C  0E64     MOVLW 0x64
0C9E  6E0E     MOVWF divisor, ACCESS
0CA0  ECA8     CALL 0x1750, 0
0CA2  F00B     NOP
0CA4  C00C     MOVFF dividend, PWMduty
0CA6  F019     NOP
0CA8  C00D     MOVFF dis, p
0CAA  F01A     NOP
41:                }
42:                PWMduty = (PWMduty << 2); // two LSBs are reserved for other things
0CAC  C019     MOVFF PWMduty, fp
0CAE  F016     NOP
0CB0  C01A     MOVFF p, sign
0CB2  F017     NOP
0CB4  90D8     BCF STATUS, 0, ACCESS
0CB6  3616     RLCF fp, F, ACCESS
0CB8  3617     RLCF sign, F, ACCESS
0CBA  90D8     BCF STATUS, 0, ACCESS
0CBC  3616     RLCF fp, F, ACCESS
0CBE  3617     RLCF sign, F, ACCESS
0CC0  C016     MOVFF fp, PWMduty
0CC2  F019     NOP
0CC4  C017     MOVFF sign, p
0CC6  F01A     NOP
43:                *(m->duty_low) = PWMduty & 0xFF; //set low duty cycle byte
0CC8  EE20     LFSR 2, 0x2
0CCA  F002     NOP
0CCC  5014     MOVF i, W, ACCESS
0CCE  26D9     ADDWF FSR2, F, ACCESS
0CD0  5015     MOVF 0x15, W, ACCESS
0CD2  22DA     ADDWFC FSR2H, F, ACCESS
0CD4  CFDE     MOVFF POSTINC2, fp
0CD6  F016     NOP
0CD8  CFDD     MOVFF POSTDEC2, sign
0CDA  F017     NOP
0CDC  C016     MOVFF fp, FSR2
0CDE  FFD9     NOP
0CE0  C017     MOVFF sign, FSR2H
0CE2  FFDA     NOP
0CE4  C019     MOVFF PWMduty, INDF2
0CE6  FFDF     NOP
44:                *(m->duty_high) = (PWMduty >> 8) & 0x3F; //set high duty cycle byte
0CE8  EE20     LFSR 2, 0x4
0CEA  F004     NOP
0CEC  5014     MOVF i, W, ACCESS
0CEE  26D9     ADDWF FSR2, F, ACCESS
0CF0  5015     MOVF 0x15, W, ACCESS
0CF2  22DA     ADDWFC FSR2H, F, ACCESS
0CF4  CFDE     MOVFF POSTINC2, fp
0CF6  F016     NOP
0CF8  CFDD     MOVFF POSTDEC2, sign
0CFA  F017     NOP
0CFC  C016     MOVFF fp, FSR2
0CFE  FFD9     NOP
0D00  C017     MOVFF sign, FSR2H
0D02  FFDA     NOP
0D04  501A     MOVF p, W, ACCESS
0D06  0B3F     ANDLW 0x3F
0D08  6EDF     MOVWF INDF2, ACCESS
45:            
46:                if (m->direction) { // if direction is high,
0D0A  EE20     LFSR 2, 0x1
0D0C  F001     NOP
0D0E  5014     MOVF i, W, ACCESS
0D10  26D9     ADDWF FSR2, F, ACCESS
0D12  5015     MOVF 0x15, W, ACCESS
0D14  22DA     ADDWFC FSR2H, F, ACCESS
0D16  50DF     MOVF INDF2, W, ACCESS
0D18  B4D8     BTFSC STATUS, 2, ACCESS
0D1A  D014     BRA 0xD44
47:                    LATB = LATB | (1 << (m->dir_pin)); // set dir_pin bit in LATB to high
0D1C  EE20     LFSR 2, 0x6
0D1E  F006     NOP
0D20  5014     MOVF i, W, ACCESS
0D22  26D9     ADDWF FSR2, F, ACCESS
0D24  5015     MOVF 0x15, W, ACCESS
0D26  22DA     ADDWFC FSR2H, F, ACCESS
0D28  50DF     MOVF INDF2, W, ACCESS
0D2A  6E16     MOVWF fp, ACCESS
0D2C  0E01     MOVLW 0x1
0D2E  6E17     MOVWF sign, ACCESS
0D30  2A16     INCF fp, F, ACCESS
0D32  D002     BRA 0xD38
0D34  90D8     BCF STATUS, 0, ACCESS
0D36  3617     RLCF sign, F, ACCESS
0D38  2E16     DECFSZ fp, F, ACCESS
0D3A  D7FC     BRA 0xD34
0D3C  5017     MOVF sign, W, ACCESS
0D3E  108A     IORWF LATB, W, ACCESS
0D40  6E8A     MOVWF LATB, ACCESS
48:                } else { // if direction is low,
0D42  0012     RETURN 0
49:                    LATB = LATB & (~(1 << (m->dir_pin))); // set dir_pin bit in LATB to low
0D44  EE20     LFSR 2, 0x6
0D46  F006     NOP
0D48  5014     MOVF i, W, ACCESS
0D4A  26D9     ADDWF FSR2, F, ACCESS
0D4C  5015     MOVF 0x15, W, ACCESS
0D4E  22DA     ADDWFC FSR2H, F, ACCESS
0D50  50DF     MOVF INDF2, W, ACCESS
0D52  6E16     MOVWF fp, ACCESS
0D54  0E01     MOVLW 0x1
0D56  6E17     MOVWF sign, ACCESS
0D58  2A16     INCF fp, F, ACCESS
0D5A  D002     BRA 0xD60
0D5C  90D8     BCF STATUS, 0, ACCESS
0D5E  3617     RLCF sign, F, ACCESS
0D60  2E16     DECFSZ fp, F, ACCESS
0D62  D7FC     BRA 0xD5C
0D64  5017     MOVF sign, W, ACCESS
0D66  0AFF     XORLW 0xFF
0D68  148A     ANDWF LATB, W, ACCESS
0D6A  6E8A     MOVWF LATB, ACCESS
0D6C  0012     RETURN 0
50:                }
51:            }
52:            
53:            //Control which motor turns on and which direction it rotates
54:            
55:            void accelerate(struct Motor *m) {
56:                for (m->power; (m->power) <= POWER; m->power++) { //increase motor power until 100
57:                    setMotorPWM(m); //pass pointer to setMotorSpeed function (not &m here)
58:                    __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
59:                }
60:            }
61:            
62:            void decelerate(struct Motor *m) {
63:                for (m->power; (m->power) > 0; m->power--) { //increase motor power until 100
64:                    setMotorPWM(m); //pass pointer to setMotorSpeed function (not &m here)
65:                    __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
66:                }
67:            }
68:            
69:            // high level functions to control left and right motor
70:            // use setMotorPWM to perform low level update
71:            // bring the robot base to a stop
72:            
73:            void stop(struct Motor *mL, struct Motor *mR) {
74:                // mL->direction = 0;
75:                // mR->direction = 0;
76:                while (mL->power > 0 || mR->power > 0) {
18C8  D02B     BRA 0x1920
77:                    if (mL->power > 0) {
18CA  C01B     MOVFF mL, FSR2
18CC  FFD9     NOP
18CE  C01C     MOVFF 0x1C, FSR2H
18D0  FFDA     NOP
18D2  50DF     MOVF INDF2, W, ACCESS
18D4  B4D8     BTFSC STATUS, 2, ACCESS
18D6  D005     BRA 0x18E2
78:                        mL->power--;
18D8  C01B     MOVFF mL, FSR2
18DA  FFD9     NOP
18DC  C01C     MOVFF 0x1C, FSR2H
18DE  FFDA     NOP
18E0  06DF     DECF INDF2, F, ACCESS
79:                    }
80:                    if (mR->power > 0) {
18E2  C01D     MOVFF i, FSR2
18E4  FFD9     NOP
18E6  C01E     MOVFF counter, FSR2H
18E8  FFDA     NOP
18EA  50DF     MOVF INDF2, W, ACCESS
18EC  B4D8     BTFSC STATUS, 2, ACCESS
18EE  D005     BRA 0x18FA
81:                        mR->power--;
18F0  C01D     MOVFF i, FSR2
18F2  FFD9     NOP
18F4  C01E     MOVFF counter, FSR2H
18F6  FFDA     NOP
18F8  06DF     DECF INDF2, F, ACCESS
82:                    }
83:                    setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
18FA  C01B     MOVFF mL, i
18FC  F014     NOP
18FE  C01C     MOVFF 0x1C, 0x15
1900  F015     NOP
1902  ECF6     CALL 0xBEC, 0
1904  F005     NOP
84:                    setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
1906  C01D     MOVFF i, i
1908  F014     NOP
190A  C01E     MOVFF counter, 0x15
190C  F015     NOP
190E  ECF6     CALL 0xBEC, 0
1910  F005     NOP
85:                    __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
1912  0E0D     MOVLW 0xD
1914  6E1F     MOVWF w, ACCESS
1916  0EFC     MOVLW 0xFC
1918  2EE8     DECFSZ WREG, F, ACCESS
191A  D7FE     BRA 0x1918
191C  2E1F     DECFSZ w, F, ACCESS
191E  D7FC     BRA 0x1918
86:                }
1920  C01B     MOVFF mL, FSR2
1922  FFD9     NOP
1924  C01C     MOVFF 0x1C, FSR2H
1926  FFDA     NOP
1928  50DF     MOVF INDF2, W, ACCESS
192A  A4D8     BTFSS STATUS, 2, ACCESS
192C  D7CE     BRA 0x18CA
192E  C01D     MOVFF i, FSR2
1930  FFD9     NOP
1932  C01E     MOVFF counter, FSR2H
1934  FFDA     NOP
1936  50DF     MOVF INDF2, W, ACCESS
1938  B4D8     BTFSC STATUS, 2, ACCESS
193A  0012     RETURN 0
193C  D7C6     BRA 0x18CA
87:            }
88:            
89:            void turnLeft(struct Motor *mL, struct Motor *mR) {
90:                //setMotorStop(mL);
91:                //setMotorStop(mR);
92:                mL->direction = 0;
158E  EE20     LFSR 2, 0x1
1590  F001     NOP
1592  501B     MOVF mL, W, ACCESS
1594  26D9     ADDWF FSR2, F, ACCESS
1596  501C     MOVF 0x1C, W, ACCESS
1598  22DA     ADDWFC FSR2H, F, ACCESS
159A  0E00     MOVLW 0x0
159C  6EDF     MOVWF INDF2, ACCESS
93:                mR->direction = 1;
159E  EE20     LFSR 2, 0x1
15A0  F001     NOP
15A2  501D     MOVF i, W, ACCESS
15A4  26D9     ADDWF FSR2, F, ACCESS
15A6  501E     MOVF counter, W, ACCESS
15A8  22DA     ADDWFC FSR2H, F, ACCESS
15AA  0E01     MOVLW 0x1
15AC  6EDF     MOVWF INDF2, ACCESS
94:                while (mL->power < POWER2 || mR->power < POWER2) {
15AE  D02B     BRA 0x1606
95:                    if (mL->power < POWER2) {
15B0  C01B     MOVFF mL, FSR2
15B2  FFD9     NOP
15B4  C01C     MOVFF 0x1C, FSR2H
15B6  FFDA     NOP
15B8  0E32     MOVLW 0x32
15BA  60DF     CPFSLT INDF2, ACCESS
15BC  D005     BRA 0x15C8
96:                        mL->power++;
15BE  C01B     MOVFF mL, FSR2
15C0  FFD9     NOP
15C2  C01C     MOVFF 0x1C, FSR2H
15C4  FFDA     NOP
15C6  2ADF     INCF INDF2, F, ACCESS
97:                    }
98:                    if (mR->power < POWER2) {
15C8  C01D     MOVFF i, FSR2
15CA  FFD9     NOP
15CC  C01E     MOVFF counter, FSR2H
15CE  FFDA     NOP
15D0  0E32     MOVLW 0x32
15D2  60DF     CPFSLT INDF2, ACCESS
15D4  D005     BRA 0x15E0
99:                        mR->power++;
15D6  C01D     MOVFF i, FSR2
15D8  FFD9     NOP
15DA  C01E     MOVFF counter, FSR2H
15DC  FFDA     NOP
15DE  2ADF     INCF INDF2, F, ACCESS
100:                   }
101:                   setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
15E0  C01B     MOVFF mL, i
15E2  F014     NOP
15E4  C01C     MOVFF 0x1C, 0x15
15E6  F015     NOP
15E8  ECF6     CALL 0xBEC, 0
15EA  F005     NOP
102:                   setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
15EC  C01D     MOVFF i, i
15EE  F014     NOP
15F0  C01E     MOVFF counter, 0x15
15F2  F015     NOP
15F4  ECF6     CALL 0xBEC, 0
15F6  F005     NOP
103:                   __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
15F8  0E0D     MOVLW 0xD
15FA  6E1F     MOVWF w, ACCESS
15FC  0EFC     MOVLW 0xFC
15FE  2EE8     DECFSZ WREG, F, ACCESS
1600  D7FE     BRA 0x15FE
1602  2E1F     DECFSZ w, F, ACCESS
1604  D7FC     BRA 0x15FE
104:               }
1606  C01B     MOVFF mL, FSR2
1608  FFD9     NOP
160A  C01C     MOVFF 0x1C, FSR2H
160C  FFDA     NOP
160E  0E31     MOVLW 0x31
1610  64DF     CPFSGT INDF2, ACCESS
1612  D7CE     BRA 0x15B0
1614  C01D     MOVFF i, FSR2
1616  FFD9     NOP
1618  C01E     MOVFF counter, FSR2H
161A  FFDA     NOP
161C  0E31     MOVLW 0x31
161E  64DF     CPFSGT INDF2, ACCESS
1620  D7C7     BRA 0x15B0
1622  0012     RETURN 0
105:           }
106:           
107:           void turnRight(struct Motor *mL, struct Motor *mR) {
108:               //setMotorStop(mL);
109:               //setMotorStop(mR);
110:               mL->direction = 1;
14F8  EE20     LFSR 2, 0x1
14FA  F001     NOP
14FC  501B     MOVF mL, W, ACCESS
14FE  26D9     ADDWF FSR2, F, ACCESS
1500  501C     MOVF 0x1C, W, ACCESS
1502  22DA     ADDWFC FSR2H, F, ACCESS
1504  0E01     MOVLW 0x1
1506  6EDF     MOVWF INDF2, ACCESS
111:               mR->direction = 0;
1508  EE20     LFSR 2, 0x1
150A  F001     NOP
150C  501D     MOVF i, W, ACCESS
150E  26D9     ADDWF FSR2, F, ACCESS
1510  501E     MOVF counter, W, ACCESS
1512  22DA     ADDWFC FSR2H, F, ACCESS
1514  0E00     MOVLW 0x0
1516  6EDF     MOVWF INDF2, ACCESS
112:               while (mL->power < POWER2 || mR->power < POWER2) {
1518  D02B     BRA 0x1570
113:                   if (mL->power < POWER2) {
151A  C01B     MOVFF mL, FSR2
151C  FFD9     NOP
151E  C01C     MOVFF 0x1C, FSR2H
1520  FFDA     NOP
1522  0E32     MOVLW 0x32
1524  60DF     CPFSLT INDF2, ACCESS
1526  D005     BRA 0x1532
114:                       mL->power++;
1528  C01B     MOVFF mL, FSR2
152A  FFD9     NOP
152C  C01C     MOVFF 0x1C, FSR2H
152E  FFDA     NOP
1530  2ADF     INCF INDF2, F, ACCESS
115:                   }
116:                   if (mR->power < POWER2) {
1532  C01D     MOVFF i, FSR2
1534  FFD9     NOP
1536  C01E     MOVFF counter, FSR2H
1538  FFDA     NOP
153A  0E32     MOVLW 0x32
153C  60DF     CPFSLT INDF2, ACCESS
153E  D005     BRA 0x154A
117:                       mR->power++;
1540  C01D     MOVFF i, FSR2
1542  FFD9     NOP
1544  C01E     MOVFF counter, FSR2H
1546  FFDA     NOP
1548  2ADF     INCF INDF2, F, ACCESS
118:                   }
119:                   setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
154A  C01B     MOVFF mL, i
154C  F014     NOP
154E  C01C     MOVFF 0x1C, 0x15
1550  F015     NOP
1552  ECF6     CALL 0xBEC, 0
1554  F005     NOP
120:                   setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
1556  C01D     MOVFF i, i
1558  F014     NOP
155A  C01E     MOVFF counter, 0x15
155C  F015     NOP
155E  ECF6     CALL 0xBEC, 0
1560  F005     NOP
121:                   __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
1562  0E0D     MOVLW 0xD
1564  6E1F     MOVWF w, ACCESS
1566  0EFC     MOVLW 0xFC
1568  2EE8     DECFSZ WREG, F, ACCESS
156A  D7FE     BRA 0x1568
156C  2E1F     DECFSZ w, F, ACCESS
156E  D7FC     BRA 0x1568
122:               }
1570  C01B     MOVFF mL, FSR2
1572  FFD9     NOP
1574  C01C     MOVFF 0x1C, FSR2H
1576  FFDA     NOP
1578  0E31     MOVLW 0x31
157A  64DF     CPFSGT INDF2, ACCESS
157C  D7CE     BRA 0x151A
157E  C01D     MOVFF i, FSR2
1580  FFD9     NOP
1582  C01E     MOVFF counter, FSR2H
1584  FFDA     NOP
1586  0E31     MOVLW 0x31
1588  64DF     CPFSGT INDF2, ACCESS
158A  D7C7     BRA 0x151A
158C  0012     RETURN 0
123:           }
124:           void turnRightSlow(struct Motor *mL, struct Motor *mR) {
125:               //setMotorStop(mL);
126:               //setMotorStop(mR);
127:               mL->direction = 1;
1462  EE20     LFSR 2, 0x1
1464  F001     NOP
1466  501B     MOVF mL, W, ACCESS
1468  26D9     ADDWF FSR2, F, ACCESS
146A  501C     MOVF 0x1C, W, ACCESS
146C  22DA     ADDWFC FSR2H, F, ACCESS
146E  0E01     MOVLW 0x1
1470  6EDF     MOVWF INDF2, ACCESS
128:               mR->direction = 0;
1472  EE20     LFSR 2, 0x1
1474  F001     NOP
1476  501D     MOVF i, W, ACCESS
1478  26D9     ADDWF FSR2, F, ACCESS
147A  501E     MOVF counter, W, ACCESS
147C  22DA     ADDWFC FSR2H, F, ACCESS
147E  0E00     MOVLW 0x0
1480  6EDF     MOVWF INDF2, ACCESS
129:               while (mL->power < POWER3 || mR->power < POWER3) {
1482  D02B     BRA 0x14DA
130:                   if (mL->power < POWER3) {
1484  C01B     MOVFF mL, FSR2
1486  FFD9     NOP
1488  C01C     MOVFF 0x1C, FSR2H
148A  FFDA     NOP
148C  0E32     MOVLW 0x32
148E  60DF     CPFSLT INDF2, ACCESS
1490  D005     BRA 0x149C
131:                       mL->power++;
1492  C01B     MOVFF mL, FSR2
1494  FFD9     NOP
1496  C01C     MOVFF 0x1C, FSR2H
1498  FFDA     NOP
149A  2ADF     INCF INDF2, F, ACCESS
132:                   }
133:                   if (mR->power < POWER3
149C  C01D     MOVFF i, FSR2
149E  FFD9     NOP
14A0  C01E     MOVFF counter, FSR2H
14A2  FFDA     NOP
14A4  0E32     MOVLW 0x32
14A6  60DF     CPFSLT INDF2, ACCESS
14A8  D005     BRA 0x14B4
134:                           ) {
135:                       mR->power++;
14AA  C01D     MOVFF i, FSR2
14AC  FFD9     NOP
14AE  C01E     MOVFF counter, FSR2H
14B0  FFDA     NOP
14B2  2ADF     INCF INDF2, F, ACCESS
136:                   }
137:                   setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
14B4  C01B     MOVFF mL, i
14B6  F014     NOP
14B8  C01C     MOVFF 0x1C, 0x15
14BA  F015     NOP
14BC  ECF6     CALL 0xBEC, 0
14BE  F005     NOP
138:                   setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
14C0  C01D     MOVFF i, i
14C2  F014     NOP
14C4  C01E     MOVFF counter, 0x15
14C6  F015     NOP
14C8  ECF6     CALL 0xBEC, 0
14CA  F005     NOP
139:                   __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
14CC  0E0D     MOVLW 0xD
14CE  6E1F     MOVWF w, ACCESS
14D0  0EFC     MOVLW 0xFC
14D2  2EE8     DECFSZ WREG, F, ACCESS
14D4  D7FE     BRA 0x14D2
14D6  2E1F     DECFSZ w, F, ACCESS
14D8  D7FC     BRA 0x14D2
140:               }
14DA  C01B     MOVFF mL, FSR2
14DC  FFD9     NOP
14DE  C01C     MOVFF 0x1C, FSR2H
14E0  FFDA     NOP
14E2  0E31     MOVLW 0x31
14E4  64DF     CPFSGT INDF2, ACCESS
14E6  D7CE     BRA 0x1484
14E8  C01D     MOVFF i, FSR2
14EA  FFD9     NOP
14EC  C01E     MOVFF counter, FSR2H
14EE  FFDA     NOP
14F0  0E31     MOVLW 0x31
14F2  64DF     CPFSGT INDF2, ACCESS
14F4  D7C7     BRA 0x1484
14F6  0012     RETURN 0
141:           }
142:           // both motors forward and up to full power
143:           
144:           void forwards(struct Motor *mL, struct Motor *mR) {
145:               mL->direction = 0;
16BA  EE20     LFSR 2, 0x1
16BC  F001     NOP
16BE  501B     MOVF mL, W, ACCESS
16C0  26D9     ADDWF FSR2, F, ACCESS
16C2  501C     MOVF 0x1C, W, ACCESS
16C4  22DA     ADDWFC FSR2H, F, ACCESS
16C6  0E00     MOVLW 0x0
16C8  6EDF     MOVWF INDF2, ACCESS
146:               mR->direction = 0;
16CA  EE20     LFSR 2, 0x1
16CC  F001     NOP
16CE  501D     MOVF i, W, ACCESS
16D0  26D9     ADDWF FSR2, F, ACCESS
16D2  501E     MOVF counter, W, ACCESS
16D4  22DA     ADDWFC FSR2H, F, ACCESS
16D6  0E00     MOVLW 0x0
16D8  6EDF     MOVWF INDF2, ACCESS
147:               while (mL->power < POWER || mR->power < POWER) {
16DA  D02B     BRA 0x1732
148:                   if (mL->power < POWER) {
16DC  C01B     MOVFF mL, FSR2
16DE  FFD9     NOP
16E0  C01C     MOVFF 0x1C, FSR2H
16E2  FFDA     NOP
16E4  0E64     MOVLW 0x64
16E6  60DF     CPFSLT INDF2, ACCESS
16E8  D005     BRA 0x16F4
149:                       mL->power++;
16EA  C01B     MOVFF mL, FSR2
16EC  FFD9     NOP
16EE  C01C     MOVFF 0x1C, FSR2H
16F0  FFDA     NOP
16F2  2ADF     INCF INDF2, F, ACCESS
150:                   }
151:                   if (mR->power < POWER) {
16F4  C01D     MOVFF i, FSR2
16F6  FFD9     NOP
16F8  C01E     MOVFF counter, FSR2H
16FA  FFDA     NOP
16FC  0E64     MOVLW 0x64
16FE  60DF     CPFSLT INDF2, ACCESS
1700  D005     BRA 0x170C
152:                       mR->power++;
1702  C01D     MOVFF i, FSR2
1704  FFD9     NOP
1706  C01E     MOVFF counter, FSR2H
1708  FFDA     NOP
170A  2ADF     INCF INDF2, F, ACCESS
153:                   }
154:                   setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
170C  C01B     MOVFF mL, i
170E  F014     NOP
1710  C01C     MOVFF 0x1C, 0x15
1712  F015     NOP
1714  ECF6     CALL 0xBEC, 0
1716  F005     NOP
155:                   setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
1718  C01D     MOVFF i, i
171A  F014     NOP
171C  C01E     MOVFF counter, 0x15
171E  F015     NOP
1720  ECF6     CALL 0xBEC, 0
1722  F005     NOP
156:                   __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
1724  0E0D     MOVLW 0xD
1726  6E1F     MOVWF w, ACCESS
1728  0EFC     MOVLW 0xFC
172A  2EE8     DECFSZ WREG, F, ACCESS
172C  D7FE     BRA 0x172A
172E  2E1F     DECFSZ w, F, ACCESS
1730  D7FC     BRA 0x172A
157:               }
1732  C01B     MOVFF mL, FSR2
1734  FFD9     NOP
1736  C01C     MOVFF 0x1C, FSR2H
1738  FFDA     NOP
173A  0E63     MOVLW 0x63
173C  64DF     CPFSGT INDF2, ACCESS
173E  D7CE     BRA 0x16DC
1740  C01D     MOVFF i, FSR2
1742  FFD9     NOP
1744  C01E     MOVFF counter, FSR2H
1746  FFDA     NOP
1748  0E63     MOVLW 0x63
174A  64DF     CPFSGT INDF2, ACCESS
174C  D7C7     BRA 0x16DC
174E  0012     RETURN 0
158:           }
159:           
160:           
161:           
162:           
163:           
---  /Users/hasan/Box Sync/me4/ecm/main.c  --------------------------------------------------------------
1:             #pragma config OSC = IRCIO, LVP = OFF, MCLRE = OFF
2:             #include <stdio.h>
3:             #include <stdlib.h>
4:             #include <xc.h>
5:             #define _XTAL_FREQ 8000000
6:             #define PWMPERIOD 199
7:             #define TIME 100
8:             #include "lcd.h"
9:             #include "ir.h"
10:            #include "motor.h"
11:            #include "rfid.h"
12:            
13:            
14:            
15:            volatile char card_read; //value will change during the code at any time therefore it must be a volatile character 
16:            char string_rfid[17]; //global variable because it is used in the RFID interrupt and called in the main loop 
17:            //
18:            
19:            void __interrupt(high_priority) InterruptHandlerHigh() {
0008  825A     BSF btemp, 1, ACCESS
20:            
21:                //RFID tag
22:                static char count = 0;
23:                char rx_char;
24:            
25:                if (PIR1bits.RCIF) { //if a character is read from the rfid tag
001A  AA9E     BTFSS PIR1, 5, ACCESS
001C  D01A     BRA 0x52
26:                    rx_char = RCREG;
001E  CFAE     MOVFF RCREG, rx_char
0020  F005     NOP
27:                    if (rx_char == 0x02) { //if it is the first character of the message
0022  0E02     MOVLW 0x2
0024  1805     XORWF rx_char, W, ACCESS
0026  A4D8     BTFSS STATUS, 2, ACCESS
0028  D002     BRA 0x2E
28:                        count = 0;
002A  0E00     MOVLW 0x0
002C  6E59     MOVWF count, ACCESS
29:                    }
30:                    if (rx_char == 0x03) { //when all the message is read
002E  0E03     MOVLW 0x3
0030  1805     XORWF rx_char, W, ACCESS
0032  A4D8     BTFSS STATUS, 2, ACCESS
0034  D003     BRA 0x3C
31:                        card_read = 1; //enter RFID reading and checksum functions
0036  0E01     MOVLW 0x1
0038  0100     MOVLB 0x0
003A  6FBE     MOVWF card_read, BANKED
32:                    }
33:                    string_rfid[count] = rx_char; //store the character read by the RFID tag into a character string
003C  5059     MOVF count, W, ACCESS
003E  0D01     MULLW 0x1
0040  0EDF     MOVLW 0xDF
0042  24F3     ADDWF PROD, W, ACCESS
0044  6ED9     MOVWF FSR2, ACCESS
0046  0E00     MOVLW 0x0
0048  20F4     ADDWFC PRODH, W, ACCESS
004A  6EDA     MOVWF FSR2H, ACCESS
004C  C005     MOVFF rx_char, INDF2
004E  FFDF     NOP
34:                    count++;
0050  2A59     INCF count, F, ACCESS
35:                }
36:                if (INTCON3bits.INT2IF) { //external interrupt flag
0052  A2F0     BTFSS INTCON3, 1, ACCESS
0054  D00A     BRA 0x6A
37:                    if (PORTCbits.RC5 == 1) { //Ask 4 times for the RC5 input to prevent button false positives
0056  BA82     BTFSC PORTC, 5, ACCESS
38:                        if (PORTCbits.RC5 == 1) {
0058  AA82     BTFSS PORTC, 5, ACCESS
005A  D006     BRA 0x68
39:                            if (PORTCbits.RC5 == 1) {
005C  BA82     BTFSC PORTC, 5, ACCESS
40:                                if (PORTCbits.RC5 == 1) {
005E  AA82     BTFSS PORTC, 5, ACCESS
0060  D003     BRA 0x68
41:                                    card_read = 0; //re-start the searching routine
0062  0E00     MOVLW 0x0
0064  0100     MOVLB 0x0
0066  6FBE     MOVWF card_read, BANKED
42:                                }
43:                            }
44:                        }
45:                    }
46:                    INTCON3bits.INT2IF = 0; //clear the interrupt flag
0068  92F0     BCF INTCON3, 1, ACCESS
47:                }
48:            
49:            }
006A  C004     MOVFF 0x4, PRODH
006C  FFF4     NOP
006E  C003     MOVFF 0x3, PROD
0070  FFF3     NOP
0072  C002     MOVFF 0x2, FSR2H
0074  FFDA     NOP
0076  C001     MOVFF __pcstackCOMRAM, FSR2
0078  FFD9     NOP
007A  925A     BCF btemp, 1, ACCESS
007C  0011     RETFIE 1
50:            
51:            int main(void) {
52:                ANSEL0 = 0; //Override start up analogue mode to digital instead
0334  0E00     MOVLW 0x0
0336  6EB8     MOVWF ANSEL0, ACCESS
53:                ANSEL1 = 0;
0338  0E00     MOVLW 0x0
033A  6EB9     MOVWF ANSEL1, ACCESS
54:                OSCCON = 0x72;
033C  0E72     MOVLW 0x72
033E  6ED3     MOVWF OSCCON, ACCESS
55:                while (!OSCCONbits.IOFS);
0340  A4D3     BTFSS OSCCON, 2, ACCESS
0342  D7FE     BRA 0x340
56:            
57:                LCD_init();
0344  ECED     CALL 0xFDA, 0
0346  F007     NOP
58:            
59:                init_TIMER5();
0348  ECE0     CALL 0x1BC0, 0
034A  F00D     NOP
60:                initPWM();
034C  ECB6     CALL 0x1B6C, 0
034E  F00D     NOP
61:                init_capture();
0350  ECD3     CALL 0x1BA6, 0
0352  F00D     NOP
62:                init_RFID();
0354  ECED     CALL 0x1BDA, 0
0356  F00D     NOP
63:            
64:            
65:            
66:                interrupt_EUSART();
0358  EC05     CALL 0x1C0A, 0
035A  F00E     NOP
67:                struct Sensor_ir Values;
68:                struct Motor mL, mR;
69:                int PWMcycle = 199;
035C  0E00     MOVLW 0x0
035E  0100     MOVLB 0x0
0360  6F99     MOVWF 0x99, BANKED
0362  0EC7     MOVLW 0xC7
0364  6F98     MOVWF PWMcycle, BANKED
70:                mL.power = 0; //zero power to start
0366  0E00     MOVLW 0x0
0368  6FA8     MOVWF mL, BANKED
71:                mL.direction = 1; //set default motor direction, forward
036A  0E01     MOVLW 0x1
036C  6FA9     MOVWF 0xA9, BANKED
72:                mL.duty_low = (unsigned char *) (&PDC0L); //store address of PWM duty low byte
036E  0E79     MOVLW 0x79
0370  6FAA     MOVWF 0xAA, BANKED
0372  0E0F     MOVLW 0xF
0374  6FAB     MOVWF 0xAB, BANKED
73:                mL.duty_high = (unsigned char *) (&PDC0H); //store address of PWM duty high byte
0376  0E78     MOVLW 0x78
0378  6FAC     MOVWF 0xAC, BANKED
037A  0E0F     MOVLW 0xF
037C  6FAD     MOVWF 0xAD, BANKED
74:                mL.dir_pin = 0; //pin RB0/PWM0 controls direction
037E  0E00     MOVLW 0x0
0380  6FAE     MOVWF 0xAE, BANKED
75:                mL.period = PWMcycle; //store PWMperiod for motor
0382  C098     MOVFF PWMcycle, 0xAF
0384  F0AF     NOP
0386  C099     MOVFF 0x99, 0xB0
0388  F0B0     NOP
76:            
77:                //same for motorR but different PWM registers and direction pin
78:                mR.power = 0;
038A  0E00     MOVLW 0x0
038C  6FB1     MOVWF mR, BANKED
79:                mR.direction = 1;
038E  0E01     MOVLW 0x1
0390  6FB2     MOVWF 0xB2, BANKED
80:                mR.duty_low = (unsigned char *) (&PDC1L);
0392  0E77     MOVLW 0x77
0394  6FB3     MOVWF 0xB3, BANKED
0396  0E0F     MOVLW 0xF
0398  6FB4     MOVWF 0xB4, BANKED
81:                mR.duty_high = (unsigned char *) (&PDC1H);
039A  0E76     MOVLW 0x76
039C  6FB5     MOVWF 0xB5, BANKED
039E  0E0F     MOVLW 0xF
03A0  6FB6     MOVWF 0xB6, BANKED
82:                mR.dir_pin = 2; //pin RB2/PWM0 controls direction
03A2  0E02     MOVLW 0x2
03A4  6FB7     MOVWF 0xB7, BANKED
83:                mR.period = PWMcycle;
03A6  C098     MOVFF PWMcycle, 0xB8
03A8  F0B8     NOP
03AA  C099     MOVFF 0x99, 0xB9
03AC  F0B9     NOP
84:            
85:                while (1) {
86:            
87:                    int direction = 0;
03AE  D0BF     BRA 0x52E
88:                    //Searching for IR emitter 
89:            
90:                    while (card_read == 0) { //Card read is set to 0 by the interrupt set by pressing the button
91:                        read_IR(&Values);
03B0  0EA0     MOVLW 0xA0
03B2  6E06     MOVWF Values, ACCESS
03B4  0E00     MOVLW 0x0
03B6  6E07     MOVWF number, ACCESS
03B8  EC2A     CALL 0x1254, 0
03BA  F009     NOP
92:                        //            Values.left = measureIRLeft();
93:                        //            Values.right = measureIRRight();
94:            
95:                        print_IR(&Values);
03BC  0EA0     MOVLW 0xA0
03BE  0100     MOVLB 0x0
03C0  6F82     MOVWF Values, BANKED
03C2  0E00     MOVLW 0x0
03C4  6F83     MOVWF 0x83, BANKED
03C6  ECC9     CALL 0x1192, 0
03C8  F008     NOP
96:                        int threshold = 50;
03CA  0E00     MOVLW 0x0
03CC  0100     MOVLB 0x0
03CE  6F9D     MOVWF 0x9D, BANKED
03D0  0E32     MOVLW 0x32
03D2  6F9C     MOVWF threshold, BANKED
97:                        int diff = Values.left - Values.right;
03D4  EE20     LFSR 2, 0xA2
03D6  F0A2     NOP
03D8  CFDE     MOVFF POSTINC2, 0x95
03DA  F095     NOP
03DC  CFDD     MOVFF POSTDEC2, 0x96
03DE  F096     NOP
03E0  1F95     COMF 0x95, F, BANKED
03E2  1F96     COMF 0x96, F, BANKED
03E4  4B95     INFSNZ 0x95, F, BANKED
03E6  2B96     INCF 0x96, F, BANKED
03E8  51A0     MOVF Values, W, BANKED
03EA  2595     ADDWF 0x95, W, BANKED
03EC  6F9A     MOVWF diff, BANKED
03EE  51A1     MOVF 0xA1, W, BANKED
03F0  2196     ADDWFC 0x96, W, BANKED
03F2  6F9B     MOVWF 0x9B, BANKED
98:                        if (Values.left > 256 | Values.right > 256) {
03F4  05A0     DECF Values, W, BANKED
03F6  0E01     MOVLW 0x1
03F8  59A1     SUBWFB 0xA1, W, BANKED
03FA  B0D8     BTFSC STATUS, 0, ACCESS
03FC  D005     BRA 0x408
03FE  05A2     DECF 0xA2, W, BANKED
0400  0E01     MOVLW 0x1
0402  59A3     SUBWFB 0xA3, W, BANKED
0404  A0D8     BTFSS STATUS, 0, ACCESS
0406  D004     BRA 0x410
99:                            threshold = 50;
0408  0E00     MOVLW 0x0
040A  6F9D     MOVWF 0x9D, BANKED
040C  0E32     MOVLW 0x32
040E  D003     BRA 0x416
100:                       } else {
101:                           threshold = 20;
0410  0E00     MOVLW 0x0
0412  6F9D     MOVWF 0x9D, BANKED
0414  0E14     MOVLW 0x14
0416  6F9C     MOVWF threshold, BANKED
102:                       }
103:           
104:                       if (diff < -threshold) {
0418  C09C     MOVFF threshold, 0x95
041A  F095     NOP
041C  C09D     MOVFF 0x9D, 0x96
041E  F096     NOP
0420  1F95     COMF 0x95, F, BANKED
0422  1F96     COMF 0x96, F, BANKED
0424  4B95     INFSNZ 0x95, F, BANKED
0426  2B96     INCF 0x96, F, BANKED
0428  5195     MOVF 0x95, W, BANKED
042A  5D9A     SUBWF diff, W, BANKED
042C  519B     MOVF 0x9B, W, BANKED
042E  0A80     XORLW 0x80
0430  6F97     MOVWF 0x97, BANKED
0432  5196     MOVF 0x96, W, BANKED
0434  0A80     XORLW 0x80
0436  5997     SUBWFB 0x97, W, BANKED
0438  B0D8     BTFSC STATUS, 0, ACCESS
043A  D026     BRA 0x488
105:                           //if (direction != 1) {
106:                           stop(&mL, &mR);
043C  0EA8     MOVLW 0xA8
043E  6E1B     MOVWF mL, ACCESS
0440  0E00     MOVLW 0x0
0442  6E1C     MOVWF 0x1C, ACCESS
0444  0EB1     MOVLW 0xB1
0446  6E1D     MOVWF i, ACCESS
0448  0E00     MOVLW 0x0
044A  6E1E     MOVWF counter, ACCESS
044C  EC64     CALL 0x18C8, 0
044E  F00C     NOP
107:                           turnLeft(&mL, &mR);
0450  0EA8     MOVLW 0xA8
0452  6E1B     MOVWF mL, ACCESS
0454  0E00     MOVLW 0x0
0456  6E1C     MOVWF 0x1C, ACCESS
0458  0EB1     MOVLW 0xB1
045A  6E1D     MOVWF i, ACCESS
045C  0E00     MOVLW 0x0
045E  6E1E     MOVWF counter, ACCESS
0460  ECC7     CALL 0x158E, 0
0462  F00A     NOP
108:                           __delay_ms(TIME);
0464  0E02     MOVLW 0x2
0466  0100     MOVLB 0x0
0468  6F96     MOVWF 0x96, BANKED
046A  0E04     MOVLW 0x4
046C  6F95     MOVWF 0x95, BANKED
046E  0EBA     MOVLW 0xBA
0470  2EE8     DECFSZ WREG, F, ACCESS
0472  D7FE     BRA 0x470
0474  2F95     DECFSZ 0x95, F, BANKED
0476  D7FC     BRA 0x470
0478  2F96     DECFSZ 0x96, F, BANKED
047A  D7FA     BRA 0x470
047C  F000     NOP
109:                           //}
110:           
111:           
112:                           direction = 1;
047E  0E00     MOVLW 0x0
0480  0100     MOVLB 0x0
0482  6F9F     MOVWF 0x9F, BANKED
0484  0E01     MOVLW 0x1
0486  D057     BRA 0x536
113:           
114:                       } else if (diff > threshold) {
0488  519A     MOVF diff, W, BANKED
048A  5D9C     SUBWF threshold, W, BANKED
048C  519D     MOVF 0x9D, W, BANKED
048E  0A80     XORLW 0x80
0490  6F95     MOVWF 0x95, BANKED
0492  519B     MOVF 0x9B, W, BANKED
0494  0A80     XORLW 0x80
0496  5995     SUBWFB 0x95, W, BANKED
0498  B0D8     BTFSC STATUS, 0, ACCESS
049A  D025     BRA 0x4E6
115:                           //if (direction != -1) {
116:                           stop(&mL, &mR);
049C  0EA8     MOVLW 0xA8
049E  6E1B     MOVWF mL, ACCESS
04A0  0E00     MOVLW 0x0
04A2  6E1C     MOVWF 0x1C, ACCESS
04A4  0EB1     MOVLW 0xB1
04A6  6E1D     MOVWF i, ACCESS
04A8  0E00     MOVLW 0x0
04AA  6E1E     MOVWF counter, ACCESS
04AC  EC64     CALL 0x18C8, 0
04AE  F00C     NOP
117:                           turnRight(&mL, &mR);
04B0  0EA8     MOVLW 0xA8
04B2  6E1B     MOVWF mL, ACCESS
04B4  0E00     MOVLW 0x0
04B6  6E1C     MOVWF 0x1C, ACCESS
04B8  0EB1     MOVLW 0xB1
04BA  6E1D     MOVWF i, ACCESS
04BC  0E00     MOVLW 0x0
04BE  6E1E     MOVWF counter, ACCESS
04C0  EC7C     CALL 0x14F8, 0
04C2  F00A     NOP
118:                           __delay_ms(TIME);
04C4  0E02     MOVLW 0x2
04C6  0100     MOVLB 0x0
04C8  6F96     MOVWF 0x96, BANKED
04CA  0E04     MOVLW 0x4
04CC  6F95     MOVWF 0x95, BANKED
04CE  0EBA     MOVLW 0xBA
04D0  2EE8     DECFSZ WREG, F, ACCESS
04D2  D7FE     BRA 0x4D0
04D4  2F95     DECFSZ 0x95, F, BANKED
04D6  D7FC     BRA 0x4D0
04D8  2F96     DECFSZ 0x96, F, BANKED
04DA  D7FA     BRA 0x4D0
04DC  F000     NOP
119:                           //}
120:           
121:                           direction = -1;
04DE  0100     MOVLB 0x0
04E0  699E     SETF direction, BANKED
04E2  699F     SETF 0x9F, BANKED
122:                       } else { //either forwards or signal lost
04E4  D052     BRA 0x58A
123:                           if ((Values.left > 100) && (Values.right > 100)) {
04E6  51A1     MOVF 0xA1, W, BANKED
04E8  E104     BNZ 0x4F2
04EA  0E65     MOVLW 0x65
04EC  5DA0     SUBWF Values, W, BANKED
04EE  A0D8     BTFSS STATUS, 0, ACCESS
04F0  D024     BRA 0x53A
04F2  51A3     MOVF 0xA3, W, BANKED
04F4  E104     BNZ 0x4FE
04F6  0E65     MOVLW 0x65
04F8  5DA2     SUBWF 0xA2, W, BANKED
04FA  A0D8     BTFSS STATUS, 0, ACCESS
04FC  D01E     BRA 0x53A
124:                               if (direction != 0) {
04FE  519E     MOVF direction, W, BANKED
0500  119F     IORWF 0x9F, W, BANKED
0502  B4D8     BTFSC STATUS, 2, ACCESS
0504  D014     BRA 0x52E
125:                                   stop(&mL, &mR);
0506  0EA8     MOVLW 0xA8
0508  6E1B     MOVWF mL, ACCESS
050A  0E00     MOVLW 0x0
050C  6E1C     MOVWF 0x1C, ACCESS
050E  0EB1     MOVLW 0xB1
0510  6E1D     MOVWF i, ACCESS
0512  0E00     MOVLW 0x0
0514  6E1E     MOVWF counter, ACCESS
0516  EC64     CALL 0x18C8, 0
0518  F00C     NOP
126:                                   forwards(&mL, &mR);
051A  0EA8     MOVLW 0xA8
051C  6E1B     MOVWF mL, ACCESS
051E  0E00     MOVLW 0x0
0520  6E1C     MOVWF 0x1C, ACCESS
0522  0EB1     MOVLW 0xB1
0524  6E1D     MOVWF i, ACCESS
0526  0E00     MOVLW 0x0
0528  6E1E     MOVWF counter, ACCESS
052A  EC5D     CALL 0x16BA, 0
052C  F00B     NOP
127:                                   //__delay_ms(TIME);
128:                               }
129:           
130:                               direction = 0;
052E  0E00     MOVLW 0x0
0530  0100     MOVLB 0x0
0532  6F9F     MOVWF 0x9F, BANKED
0534  0E00     MOVLW 0x0
0536  6F9E     MOVWF direction, BANKED
131:                           } else {
0538  D028     BRA 0x58A
132:                               if (direction != 1) {
053A  059E     DECF direction, W, BANKED
053C  119F     IORWF 0x9F, W, BANKED
053E  B4D8     BTFSC STATUS, 2, ACCESS
0540  D024     BRA 0x58A
133:           
134:                                   turnRightSlow(&mL, &mR);
0542  0EA8     MOVLW 0xA8
0544  6E1B     MOVWF mL, ACCESS
0546  0E00     MOVLW 0x0
0548  6E1C     MOVWF 0x1C, ACCESS
054A  0EB1     MOVLW 0xB1
054C  6E1D     MOVWF i, ACCESS
054E  0E00     MOVLW 0x0
0550  6E1E     MOVWF counter, ACCESS
0552  EC31     CALL 0x1462, 0
0554  F00A     NOP
135:                                   stop(&mL, &mR);
0556  0EA8     MOVLW 0xA8
0558  6E1B     MOVWF mL, ACCESS
055A  0E00     MOVLW 0x0
055C  6E1C     MOVWF 0x1C, ACCESS
055E  0EB1     MOVLW 0xB1
0560  6E1D     MOVWF i, ACCESS
0562  0E00     MOVLW 0x0
0564  6E1E     MOVWF counter, ACCESS
0566  EC64     CALL 0x18C8, 0
0568  F00C     NOP
136:                                   direction = -1;
056A  0100     MOVLB 0x0
056C  699E     SETF direction, BANKED
056E  699F     SETF 0x9F, BANKED
137:                                   __delay_ms(TIME);
0570  0E02     MOVLW 0x2
0572  0100     MOVLB 0x0
0574  6F96     MOVWF 0x96, BANKED
0576  0E04     MOVLW 0x4
0578  6F95     MOVWF 0x95, BANKED
057A  0EBA     MOVLW 0xBA
057C  2EE8     DECFSZ WREG, F, ACCESS
057E  D7FE     BRA 0x57C
0580  2F95     DECFSZ 0x95, F, BANKED
0582  D7FC     BRA 0x57C
0584  2F96     DECFSZ 0x96, F, BANKED
0586  D7FA     BRA 0x57C
0588  F000     NOP
138:                               }
058A  0100     MOVLB 0x0
058C  51BE     MOVF card_read, W, BANKED
058E  B4D8     BTFSC STATUS, 2, ACCESS
0590  D70F     BRA 0x3B0
139:           
140:           
141:                           }
142:                       }
143:                       //stop(&mL, &mR);
144:                       //            __delay_ms(100);
145:                   }
146:           
147:           
148:           
149:           
150:                   if (card_read == 1) { //the interrupt for the RFID tag sets card_read to 1 when the card is read
0592  05BE     DECF card_read, W, BANKED
0594  A4D8     BTFSS STATUS, 2, ACCESS
0596  D7CB     BRA 0x52E
151:           
152:                       print_RFID(&string_rfid[0], &string_rfid[0]); //sends the significant characters read from the RFID to the LCD
0598  0EDF     MOVLW 0xDF
059A  6E0B     MOVWF pa, ACCESS
059C  0E00     MOVLW 0x0
059E  6E0C     MOVWF dividend, ACCESS
05A0  0EDF     MOVLW 0xDF
05A2  6E0D     MOVWF dis, ACCESS
05A4  0E00     MOVLW 0x0
05A6  6E0E     MOVWF divisor, ACCESS
05A8  ECEA     CALL 0x17D4, 0
05AA  F00B     NOP
153:                       __delay_ms(10);
05AC  0E1A     MOVLW 0x1A
05AE  0100     MOVLB 0x0
05B0  6F95     MOVWF 0x95, BANKED
05B2  0EF8     MOVLW 0xF8
05B4  2EE8     DECFSZ WREG, F, ACCESS
05B6  D7FE     BRA 0x5B4
05B8  2F95     DECFSZ 0x95, F, BANKED
05BA  D7FC     BRA 0x5B4
05BC  F000     NOP
154:                       return 0;
05BE  EF3F     GOTO 0x7E
05C0  F000     NOP
155:                   }
156:               }
157:           }
158:           
159:           
160:           
161:           
162:           
163:           
164:           
165:           
166:           
---  /Users/hasan/Box Sync/me4/ecm/lcd.c  ---------------------------------------------------------------
1:             #include "lcd.h"
2:             
3:             /*To toggle enable bit on then off*/
4:             void E_TOG(void) {
5:                 PORTCbits.RC0 = 1;
1BF4  8082     BSF PORTC, 0, ACCESS
6:                 __delay_us(5);
1BF6  0E03     MOVLW 0x3
1BF8  2EE8     DECFSZ WREG, F, ACCESS
1BFA  D7FE     BRA 0x1BF8
1BFC  F000     NOP
7:                 PORTCbits.RC0 = 0;
1BFE  9082     BCF PORTC, 0, ACCESS
8:                 __delay_us(5);
1C00  0E03     MOVLW 0x3
1C02  2EE8     DECFSZ WREG, F, ACCESS
1C04  D7FE     BRA 0x1C02
1C06  F000     NOP
9:             }
0008  825A     BSF btemp, 1, ACCESS
000A  CFD9     MOVFF FSR2, __pcstackCOMRAM
000C  F001     NOP
000E  CFDA     MOVFF FSR2H, 0x2
0010  F002     NOP
0012  CFF3     MOVFF PROD, 0x3
0014  F003     NOP
0016  CFF4     MOVFF PRODH, 0x4
0018  F004     NOP
1C08  0012     RETURN 0
10:            
11:            /*remake*/
12:            void time(int t) {
13:                for (int k = 0; k < t; k++) {
14:                    __delay_ms(90);
15:                }
16:            }
17:            
18:            /*To create 4-bit data stream to the LCD*/
19:            void LCD_out(unsigned char number)
1850  6E07     MOVWF number, ACCESS
20:             {
21:            
22:                PORTCbits.RC1 = (number & 0b0001);
1852  C007     MOVFF number, Values
1854  F006     NOP
1856  0E01     MOVLW 0x1
1858  1606     ANDWF Values, F, ACCESS
185A  4606     RLNCF Values, F, ACCESS
185C  5082     MOVF PORTC, W, ACCESS
185E  1806     XORWF Values, W, ACCESS
1860  0BFD     ANDLW 0xFD
1862  1806     XORWF Values, W, ACCESS
1864  6E82     MOVWF PORTC, ACCESS
23:                PORTCbits.RC2 = (number & 0b0010) >> 1;
1866  C007     MOVFF number, Values
1868  F006     NOP
186A  90D8     BCF STATUS, 0, ACCESS
186C  3206     RRCF Values, F, ACCESS
186E  0E01     MOVLW 0x1
1870  1606     ANDWF Values, F, ACCESS
1872  4606     RLNCF Values, F, ACCESS
1874  4606     RLNCF Values, F, ACCESS
1876  5082     MOVF PORTC, W, ACCESS
1878  1806     XORWF Values, W, ACCESS
187A  0BFB     ANDLW 0xFB
187C  1806     XORWF Values, W, ACCESS
187E  6E82     MOVWF PORTC, ACCESS
24:                PORTDbits.RD0 = (number & 0b0100) >> 2;
1880  C007     MOVFF number, Values
1882  F006     NOP
1884  90D8     BCF STATUS, 0, ACCESS
1886  3206     RRCF Values, F, ACCESS
1888  90D8     BCF STATUS, 0, ACCESS
188A  3206     RRCF Values, F, ACCESS
188C  0E01     MOVLW 0x1
188E  1606     ANDWF Values, F, ACCESS
1890  5083     MOVF PORTD, W, ACCESS
1892  1806     XORWF Values, W, ACCESS
1894  0BFE     ANDLW 0xFE
1896  1806     XORWF Values, W, ACCESS
1898  6E83     MOVWF PORTD, ACCESS
25:                PORTDbits.RD1 = (number & 0b1000) >> 3;
189A  C007     MOVFF number, Values
189C  F006     NOP
189E  90D8     BCF STATUS, 0, ACCESS
18A0  3206     RRCF Values, F, ACCESS
18A2  90D8     BCF STATUS, 0, ACCESS
18A4  3206     RRCF Values, F, ACCESS
18A6  90D8     BCF STATUS, 0, ACCESS
18A8  3206     RRCF Values, F, ACCESS
18AA  0E01     MOVLW 0x1
18AC  1606     ANDWF Values, F, ACCESS
18AE  4606     RLNCF Values, F, ACCESS
18B0  5083     MOVF PORTD, W, ACCESS
18B2  1806     XORWF Values, W, ACCESS
18B4  0BFD     ANDLW 0xFD
18B6  1806     XORWF Values, W, ACCESS
18B8  6E83     MOVWF PORTD, ACCESS
26:                //toggle the enable bit to send data
27:                E_TOG();
18BA  ECFA     CALL 0x1BF4, 0
18BC  F00D     NOP
28:                __delay_us(5);
18BE  0E03     MOVLW 0x3
18C0  2EE8     DECFSZ WREG, F, ACCESS
18C2  D7FE     BRA 0x18C0
18C4  F000     NOP
29:            }
18C6  0012     RETURN 0
30:            
31:            /*
32:             * function to send data over 4 bit interface
33:             */
34:            void LCD_send(unsigned char Byte, char type) {
1AF2  6E09     MOVWF Byte, ACCESS
35:                // set RS pin whether it is a Command (0) or Data/Char (1)
36:                // using type as the argument
37:                /*TODO needs to be redone, no need for command anymore*/
38:                PORTAbits.RA6 = type;
1AF4  B008     BTFSC type, 0, ACCESS
1AF6  D002     BRA 0x1AFC
1AF8  9C80     BCF PORTA, 6, ACCESS
1AFA  D001     BRA 0x1AFE
1AFC  8C80     BSF PORTA, 6, ACCESS
39:            
40:                // send high bits of Byte using LCDout function
41:                LCD_out(Byte >> 4);
1AFE  3809     SWAPF Byte, W, ACCESS
1B00  0B0F     ANDLW 0xF
1B02  EC28     CALL 0x1850, 0
1B04  F00C     NOP
42:                __delay_us(10); //10us delay
1B06  0E06     MOVLW 0x6
1B08  2EE8     DECFSZ WREG, F, ACCESS
1B0A  D7FE     BRA 0x1B08
1B0C  D000     BRA 0x1B0E
43:                // send low bits of Byte using LCDout function
44:                LCD_out(Byte);
1B0E  5009     MOVF Byte, W, ACCESS
1B10  EC28     CALL 0x1850, 0
1B12  F00C     NOP
45:                __delay_us(50);
1B14  0E21     MOVLW 0x21
1B16  2EE8     DECFSZ WREG, F, ACCESS
1B18  D7FE     BRA 0x1B16
1B1A  F000     NOP
46:            
47:            }
1B1C  0012     RETURN 0
48:            
49:            void LCD_init(void) {
50:            
51:                /* Configuring the outputs, else unknown*/
52:                LATA = 0;
0FDA  0E00     MOVLW 0x0
0FDC  6E89     MOVWF LATA, ACCESS
53:                LATC = 0;
0FDE  0E00     MOVLW 0x0
0FE0  6E8B     MOVWF LATC, ACCESS
54:                LATD = 0;
0FE2  0E00     MOVLW 0x0
0FE4  6E8C     MOVWF LATD, ACCESS
55:            
56:                /*Initialise pins for LCD from PIC, TODO redo and move LCD*/
57:                TRISA = 0;
0FE6  0E00     MOVLW 0x0
0FE8  6E92     MOVWF TRISA, ACCESS
58:                TRISC = 0; //set the data direction registers to output on all pins
0FEA  0E00     MOVLW 0x0
0FEC  6E94     MOVWF TRISC, ACCESS
59:                TRISD = 0;
0FEE  0E00     MOVLW 0x0
0FF0  6E95     MOVWF TRISD, ACCESS
60:            
61:            
62:                /*Initialisation sequence, page TODO of datasheet*/
63:                __delay_ms(15);
0FF2  0E27     MOVLW 0x27
0FF4  6E0A     MOVWF string, ACCESS
0FF6  0EF5     MOVLW 0xF5
0FF8  2EE8     DECFSZ WREG, F, ACCESS
0FFA  D7FE     BRA 0xFF8
0FFC  2E0A     DECFSZ string, F, ACCESS
0FFE  D7FC     BRA 0xFF8
1000  F000     NOP
64:                LCD_out(0b0011);
1002  0E03     MOVLW 0x3
1004  EC28     CALL 0x1850, 0
1006  F00C     NOP
65:                __delay_ms(5);
1008  0E0D     MOVLW 0xD
100A  6E0A     MOVWF string, ACCESS
100C  0EFC     MOVLW 0xFC
100E  2EE8     DECFSZ WREG, F, ACCESS
1010  D7FE     BRA 0x100E
1012  2E0A     DECFSZ string, F, ACCESS
1014  D7FC     BRA 0x100E
66:                LCD_out(0b0011);
1016  0E03     MOVLW 0x3
1018  EC28     CALL 0x1850, 0
101A  F00C     NOP
67:                __delay_us(200);
101C  0E85     MOVLW 0x85
101E  2EE8     DECFSZ WREG, F, ACCESS
1020  D7FE     BRA 0x101E
1022  F000     NOP
68:                LCD_out(0b0011);
1024  0E03     MOVLW 0x3
1026  EC28     CALL 0x1850, 0
1028  F00C     NOP
69:                __delay_us(50);
102A  0E21     MOVLW 0x21
102C  2EE8     DECFSZ WREG, F, ACCESS
102E  D7FE     BRA 0x102C
1030  F000     NOP
70:                LCD_out(0b0010);
1032  0E02     MOVLW 0x2
1034  EC28     CALL 0x1850, 0
1036  F00C     NOP
71:                __delay_us(50);
1038  0E21     MOVLW 0x21
103A  2EE8     DECFSZ WREG, F, ACCESS
103C  D7FE     BRA 0x103A
103E  F000     NOP
72:            
73:                LCD_send(0b00101000, 0); /*4 bit mode, 2 line, 5 x 7 grid*/
1040  0E00     MOVLW 0x0
1042  6E08     MOVWF type, ACCESS
1044  0E28     MOVLW 0x28
1046  EC79     CALL 0x1AF2, 0
1048  F00D     NOP
74:                __delay_ms(2);
104A  0E06     MOVLW 0x6
104C  6E0A     MOVWF string, ACCESS
104E  0E30     MOVLW 0x30
1050  2EE8     DECFSZ WREG, F, ACCESS
1052  D7FE     BRA 0x1050
1054  2E0A     DECFSZ string, F, ACCESS
1056  D7FC     BRA 0x1050
1058  D000     BRA 0x105A
75:                LCD_send(0b00001000, 0);
105A  0E00     MOVLW 0x0
105C  6E08     MOVWF type, ACCESS
105E  0E08     MOVLW 0x8
1060  EC79     CALL 0x1AF2, 0
1062  F00D     NOP
76:                __delay_ms(2);
1064  0E06     MOVLW 0x6
1066  6E0A     MOVWF string, ACCESS
1068  0E30     MOVLW 0x30
106A  2EE8     DECFSZ WREG, F, ACCESS
106C  D7FE     BRA 0x106A
106E  2E0A     DECFSZ string, F, ACCESS
1070  D7FC     BRA 0x106A
1072  D000     BRA 0x1074
77:                LCD_send(0b00000001, 0);
1074  0E00     MOVLW 0x0
1076  6E08     MOVWF type, ACCESS
1078  0E01     MOVLW 0x1
107A  EC79     CALL 0x1AF2, 0
107C  F00D     NOP
78:                __delay_ms(2);
107E  0E06     MOVLW 0x6
1080  6E0A     MOVWF string, ACCESS
1082  0E30     MOVLW 0x30
1084  2EE8     DECFSZ WREG, F, ACCESS
1086  D7FE     BRA 0x1084
1088  2E0A     DECFSZ string, F, ACCESS
108A  D7FC     BRA 0x1084
108C  D000     BRA 0x108E
79:                LCD_send(0b00000110, 0);
108E  0E00     MOVLW 0x0
1090  6E08     MOVWF type, ACCESS
1092  0E06     MOVLW 0x6
1094  EC79     CALL 0x1AF2, 0
1096  F00D     NOP
80:                __delay_ms(2);
1098  0E06     MOVLW 0x6
109A  6E0A     MOVWF string, ACCESS
109C  0E30     MOVLW 0x30
109E  2EE8     DECFSZ WREG, F, ACCESS
10A0  D7FE     BRA 0x109E
10A2  2E0A     DECFSZ string, F, ACCESS
10A4  D7FC     BRA 0x109E
10A6  D000     BRA 0x10A8
81:                LCD_send(0b00001100, 0);
10A8  0E00     MOVLW 0x0
10AA  6E08     MOVWF type, ACCESS
10AC  0E0C     MOVLW 0xC
10AE  EC79     CALL 0x1AF2, 0
10B0  F00D     NOP
82:                __delay_ms(2);
10B2  0E06     MOVLW 0x6
10B4  6E0A     MOVWF string, ACCESS
10B6  0E30     MOVLW 0x30
10B8  2EE8     DECFSZ WREG, F, ACCESS
10BA  D7FE     BRA 0x10B8
10BC  2E0A     DECFSZ string, F, ACCESS
10BE  D7FC     BRA 0x10B8
10C0  D000     BRA 0x10C2
83:            
84:            }
10C2  0012     RETURN 0
85:            
86:            /*
87:             * To set cursor to correct line (of two)
88:             */
89:            void LCD_line(char line) {
1AC2  6E0A     MOVWF string, ACCESS
90:                if (line == 1) {
1AC4  040A     DECF string, W, ACCESS
1AC6  A4D8     BTFSS STATUS, 2, ACCESS
1AC8  D006     BRA 0x1AD6
91:                    LCD_send(0x80, 0); /*DDRAM address for line 1*/
1ACA  0E00     MOVLW 0x0
1ACC  6E08     MOVWF type, ACCESS
1ACE  0E80     MOVLW 0x80
1AD0  EC79     CALL 0x1AF2, 0
1AD2  F00D     NOP
92:                } else if (line == 2) {
1AD4  D009     BRA 0x1AE8
1AD6  0E02     MOVLW 0x2
1AD8  180A     XORWF string, W, ACCESS
1ADA  A4D8     BTFSS STATUS, 2, ACCESS
1ADC  D005     BRA 0x1AE8
93:                    LCD_send(0xC0, 0);
1ADE  0E00     MOVLW 0x0
1AE0  6E08     MOVWF type, ACCESS
1AE2  0EC0     MOVLW 0xC0
1AE4  EC79     CALL 0x1AF2, 0
1AE6  F00D     NOP
94:                }
95:                __delay_us(50); //50us delay
1AE8  0E21     MOVLW 0x21
1AEA  2EE8     DECFSZ WREG, F, ACCESS
1AEC  D7FE     BRA 0x1AEA
1AEE  F000     NOP
96:            }
1AF0  0012     RETURN 0
97:            
98:            /*
99:             * To print character by character to screen
100:            */
101:           void LCD_string(char *string) {
102:               while (*string != 0) {
1A92  D00F     BRA 0x1AB2
103:                   //Send out the current byte pointed to
104:                   //and increment the pointer
105:                   LCD_send(*string++, 1);
1A94  0E01     MOVLW 0x1
1A96  6E08     MOVWF type, ACCESS
1A98  C00A     MOVFF string, FSR2
1A9A  FFD9     NOP
1A9C  C00B     MOVFF pa, FSR2H
1A9E  FFDA     NOP
1AA0  50DF     MOVF INDF2, W, ACCESS
1AA2  EC79     CALL 0x1AF2, 0
1AA4  F00D     NOP
1AA6  4A0A     INFSNZ string, F, ACCESS
1AA8  2A0B     INCF pa, F, ACCESS
106:                   __delay_us(50); //so we can see each character
1AAA  0E21     MOVLW 0x21
1AAC  2EE8     DECFSZ WREG, F, ACCESS
1AAE  D7FE     BRA 0x1AAC
1AB0  F000     NOP
107:                   //being printed in turn (remove delay if you want
108:                   //your message to appear almost instantly)
109:               }
1AB2  C00A     MOVFF string, FSR2
1AB4  FFD9     NOP
1AB6  C00B     MOVFF pa, FSR2H
1AB8  FFDA     NOP
1ABA  50DF     MOVF INDF2, W, ACCESS
1ABC  B4D8     BTFSC STATUS, 2, ACCESS
1ABE  0012     RETURN 0
1AC0  D7E9     BRA 0x1A94
110:           }
111:           
112:           /*
113:            * To clear LCD
114:            */
115:           void LCD_clear(void) {
116:               LCD_send(0b00000001, 0);
1B8A  0E00     MOVLW 0x0
1B8C  6E08     MOVWF type, ACCESS
1B8E  0E01     MOVLW 0x1
1B90  EC79     CALL 0x1AF2, 0
1B92  F00D     NOP
117:               __delay_ms(2);
1B94  0E06     MOVLW 0x6
1B96  6E0A     MOVWF string, ACCESS
1B98  0E30     MOVLW 0x30
1B9A  2EE8     DECFSZ WREG, F, ACCESS
1B9C  D7FE     BRA 0x1B9A
1B9E  2E0A     DECFSZ string, F, ACCESS
1BA0  D7FC     BRA 0x1B9A
1BA2  D000     BRA 0x1BA4
118:           }
1BA4  0012     RETURN 0
119:           
120:           /*
121:            * To print IR values to LCD
122:            */
123:           void print_IR(struct Sensor_ir *Values) {
124:               LCD_clear();
1192  ECC5     CALL 0x1B8A, 0
1194  F00D     NOP
125:               char buf[16];
126:               LCD_line(1);
1196  0E01     MOVLW 0x1
1198  EC61     CALL 0x1AC2, 0
119A  F00D     NOP
127:               sprintf(buf, "Left: %u", Values->left);
119C  0E85     MOVLW 0x85
119E  0100     MOVLB 0x0
11A0  6F72     MOVWF s, BANKED
11A2  0E00     MOVLW 0x0
11A4  6F73     MOVWF 0x73, BANKED
11A6  0E29     MOVLW 0x29
11A8  6F74     MOVWF fmt, BANKED
11AA  0E03     MOVLW 0x3
11AC  6F75     MOVWF 0x75, BANKED
11AE  C082     MOVFF Values, FSR2
11B0  FFD9     NOP
11B2  C083     MOVFF 0x83, FSR2H
11B4  FFDA     NOP
11B6  CFDE     MOVFF POSTINC2, 0x76
11B8  F076     NOP
11BA  CFDD     MOVFF POSTDEC2, 0x77
11BC  F077     NOP
11BE  EC9F     CALL 0x193E, 0
11C0  F00C     NOP
128:               LCD_string(buf);
11C2  0E85     MOVLW 0x85
11C4  6E0A     MOVWF string, ACCESS
11C6  0E00     MOVLW 0x0
11C8  6E0B     MOVWF pa, ACCESS
11CA  EC49     CALL 0x1A92, 0
11CC  F00D     NOP
129:               LCD_line(2);
11CE  0E02     MOVLW 0x2
11D0  EC61     CALL 0x1AC2, 0
11D2  F00D     NOP
130:               sprintf(buf, "Right: %u", Values->right);
11D4  0E85     MOVLW 0x85
11D6  0100     MOVLB 0x0
11D8  6F72     MOVWF s, BANKED
11DA  0E00     MOVLW 0x0
11DC  6F73     MOVWF 0x73, BANKED
11DE  0E1F     MOVLW 0x1F
11E0  6F74     MOVWF fmt, BANKED
11E2  0E03     MOVLW 0x3
11E4  6F75     MOVWF 0x75, BANKED
11E6  EE20     LFSR 2, 0x2
11E8  F002     NOP
11EA  5182     MOVF Values, W, BANKED
11EC  26D9     ADDWF FSR2, F, ACCESS
11EE  5183     MOVF 0x83, W, BANKED
11F0  22DA     ADDWFC FSR2H, F, ACCESS
11F2  CFDE     MOVFF POSTINC2, 0x76
11F4  F076     NOP
11F6  CFDD     MOVFF POSTDEC2, 0x77
11F8  F077     NOP
11FA  EC9F     CALL 0x193E, 0
11FC  F00C     NOP
131:               LCD_string(buf);
11FE  0E85     MOVLW 0x85
1200  6E0A     MOVWF string, ACCESS
1202  0E00     MOVLW 0x0
1204  6E0B     MOVWF pa, ACCESS
1206  EC49     CALL 0x1A92, 0
1208  F00D     NOP
132:               __delay_ms(50);
120A  0E82     MOVLW 0x82
120C  0100     MOVLB 0x0
120E  6F84     MOVWF 0x84, BANKED
1210  0EDD     MOVLW 0xDD
1212  2EE8     DECFSZ WREG, F, ACCESS
1214  D7FE     BRA 0x1212
1216  2F84     DECFSZ 0x84, F, BANKED
1218  D7FC     BRA 0x1212
121A  D000     BRA 0x121C
133:               __delay_ms(50);
121C  0E82     MOVLW 0x82
121E  0100     MOVLB 0x0
1220  6F84     MOVWF 0x84, BANKED
1222  0EDD     MOVLW 0xDD
1224  2EE8     DECFSZ WREG, F, ACCESS
1226  D7FE     BRA 0x1224
1228  2F84     DECFSZ 0x84, F, BANKED
122A  D7FC     BRA 0x1224
122C  D000     BRA 0x122E
134:               __delay_ms(50);
122E  0E82     MOVLW 0x82
1230  0100     MOVLB 0x0
1232  6F84     MOVWF 0x84, BANKED
1234  0EDD     MOVLW 0xDD
1236  2EE8     DECFSZ WREG, F, ACCESS
1238  D7FE     BRA 0x1236
123A  2F84     DECFSZ 0x84, F, BANKED
123C  D7FC     BRA 0x1236
123E  D000     BRA 0x1240
135:               __delay_ms(50);
1240  0E82     MOVLW 0x82
1242  0100     MOVLB 0x0
1244  6F84     MOVWF 0x84, BANKED
1246  0EDD     MOVLW 0xDD
1248  2EE8     DECFSZ WREG, F, ACCESS
124A  D7FE     BRA 0x1248
124C  2F84     DECFSZ 0x84, F, BANKED
124E  D7FC     BRA 0x1248
1250  D000     BRA 0x1252
136:           
137:           }
1252  0012     RETURN 0
---  /Users/hasan/Box Sync/me4/ecm/ir.c  ----------------------------------------------------------------
1:             #include "ir.h"
2:             
3:             /*
4:              * Timer 5 for input capture, initialisation
5:              */
6:             void init_TIMER5(void) {
7:                 /*need to reset TMR5
8:                  *see page 139
9:                  */
10:            
11:                T5CON = 0;
1BC0  0E00     MOVLW 0x0
1BC2  6EB7     MOVWF T5CON, ACCESS
12:                T5CONbits.T5SEN = 0; /*disable during sleep            */
1BC4  9EB7     BCF T5CON, 7, ACCESS
13:                T5CONbits.RESEN = 0; /*disable special event trigger   */
1BC6  9CB7     BCF T5CON, 6, ACCESS
14:                T5CONbits.T5PS = 0b10; /*prescale, unsure TODO           */
1BC8  50B7     MOVF T5CON, W, ACCESS
1BCA  0BE7     ANDLW 0xE7
1BCC  0910     IORLW 0x10
1BCE  6EB7     MOVWF T5CON, ACCESS
15:                T5CONbits.T5MOD = 0; /*prescale, unsure TODO           */
1BD0  9AB7     BCF T5CON, 5, ACCESS
16:                T5CONbits.T5SYNC = 0; /*continuous count                */
1BD2  94B7     BCF T5CON, 2, ACCESS
17:                T5CONbits.TMR5CS = 0; /*internal clock                  */
1BD4  92B7     BCF T5CON, 1, ACCESS
18:                T5CONbits.TMR5ON = 1; /*turn on                         */
1BD6  80B7     BSF T5CON, 0, ACCESS
19:            
20:            }
1BD8  0012     RETURN 0
21:            
22:            /*
23:             * Detect falling edge to rising edge from IR detector
24:             */
25:            void init_capture(void) {
26:            
27:                LATA = 0; //Tensure all pins have same value initially
1BA6  0E00     MOVLW 0x0
1BA8  6E89     MOVWF LATA, ACCESS
28:                TRISA = 0b00001100; //Turn on CAP1 (RA2) and CAP2 (RA3) Pins.
1BAA  0E0C     MOVLW 0xC
1BAC  6E92     MOVWF TRISA, ACCESS
29:                CAP1CON = 0b01000110; //Time base enabled, measure PWM falling to rising 
1BAE  0E46     MOVLW 0x46
1BB0  6E63     MOVWF CAP1CON, ACCESS
30:                CAP2CON = 0b01000110;
1BB2  0E46     MOVLW 0x46
1BB4  6E62     MOVWF CAP2CON, ACCESS
31:                T5CON = 0b00001001; //Timer 5 prescaler 1:2, Timer on (overflow 65.536ms - max PWM is 50ms)
1BB6  0E09     MOVLW 0x9
1BB8  6EB7     MOVWF T5CON, ACCESS
32:                DFLTCON = 0b00011000; //Noise filter for CAP1 and CAP2 
1BBA  0E18     MOVLW 0x18
1BBC  6E60     MOVWF DFLTCON, ACCESS
33:            }
1BBE  0012     RETURN 0
34:            
35:            /*
36:             * Printing IR signal
37:             */
38:            void read_IR(struct Sensor_ir *Values) {
39:            //    Values->left_prev = Values->left;
40:            //    Values->right_prev = Values->right;
41:                Values->left = ((CAP2BUFH << 8) | (CAP2BUFL)); //left is cap2, i.e. lower
1254  5066     MOVF CAP2BUFL, W, ACCESS
1256  CF67     MOVFF CAP2BUFH, type
1258  F008     NOP
125A  6A09     CLRF Byte, ACCESS
125C  C008     MOVFF type, Byte
125E  F009     NOP
1260  6A08     CLRF type, ACCESS
1262  1208     IORWF type, F, ACCESS
1264  0E00     MOVLW 0x0
1266  1209     IORWF Byte, F, ACCESS
1268  C006     MOVFF Values, FSR2
126A  FFD9     NOP
126C  C007     MOVFF number, FSR2H
126E  FFDA     NOP
1270  C008     MOVFF type, POSTINC2
1272  FFDE     NOP
1274  C009     MOVFF Byte, POSTDEC2
1276  FFDD     NOP
42:                Values->right = ((CAP1BUFH << 8) | (CAP1BUFL));
1278  5068     MOVF CAP1BUFL, W, ACCESS
127A  CF69     MOVFF CAP1BUFH, type
127C  F008     NOP
127E  6A09     CLRF Byte, ACCESS
1280  C008     MOVFF type, Byte
1282  F009     NOP
1284  6A08     CLRF type, ACCESS
1286  1208     IORWF type, F, ACCESS
1288  0E00     MOVLW 0x0
128A  1209     IORWF Byte, F, ACCESS
128C  EE20     LFSR 2, 0x2
128E  F002     NOP
1290  5006     MOVF Values, W, ACCESS
1292  26D9     ADDWF FSR2, F, ACCESS
1294  5007     MOVF number, W, ACCESS
1296  22DA     ADDWFC FSR2H, F, ACCESS
1298  C008     MOVFF type, POSTINC2
129A  FFDE     NOP
129C  C009     MOVFF Byte, POSTDEC2
129E  FFDD     NOP
43:            
44:                Values->left = Values->left / 64;
12A0  C006     MOVFF Values, FSR2
12A2  FFD9     NOP
12A4  C007     MOVFF number, FSR2H
12A6  FFDA     NOP
12A8  CFDE     MOVFF POSTINC2, type
12AA  F008     NOP
12AC  CFDD     MOVFF POSTDEC2, Byte
12AE  F009     NOP
12B0  0E06     MOVLW 0x6
12B2  6E0A     MOVWF string, ACCESS
12B4  90D8     BCF STATUS, 0, ACCESS
12B6  3209     RRCF Byte, F, ACCESS
12B8  3208     RRCF type, F, ACCESS
12BA  2E0A     DECFSZ string, F, ACCESS
12BC  D7FB     BRA 0x12B4
12BE  C006     MOVFF Values, FSR2
12C0  FFD9     NOP
12C2  C007     MOVFF number, FSR2H
12C4  FFDA     NOP
12C6  C008     MOVFF type, POSTINC2
12C8  FFDE     NOP
12CA  C009     MOVFF Byte, POSTDEC2
12CC  FFDD     NOP
45:                Values->right = Values->right / 64;
12CE  EE20     LFSR 2, 0x2
12D0  F002     NOP
12D2  5006     MOVF Values, W, ACCESS
12D4  26D9     ADDWF FSR2, F, ACCESS
12D6  5007     MOVF number, W, ACCESS
12D8  22DA     ADDWFC FSR2H, F, ACCESS
12DA  CFDE     MOVFF POSTINC2, type
12DC  F008     NOP
12DE  CFDD     MOVFF POSTDEC2, Byte
12E0  F009     NOP
12E2  0E06     MOVLW 0x6
12E4  6E0A     MOVWF string, ACCESS
12E6  90D8     BCF STATUS, 0, ACCESS
12E8  3209     RRCF Byte, F, ACCESS
12EA  3208     RRCF type, F, ACCESS
12EC  2E0A     DECFSZ string, F, ACCESS
12EE  D7FB     BRA 0x12E6
12F0  EE20     LFSR 2, 0x2
12F2  F002     NOP
12F4  5006     MOVF Values, W, ACCESS
12F6  26D9     ADDWF FSR2, F, ACCESS
12F8  5007     MOVF number, W, ACCESS
12FA  22DA     ADDWFC FSR2H, F, ACCESS
12FC  C008     MOVFF type, POSTINC2
12FE  FFDE     NOP
1300  C009     MOVFF Byte, POSTDEC2
1302  FFDD     NOP
46:                __delay_ms(50);
1304  0E82     MOVLW 0x82
1306  6E08     MOVWF type, ACCESS
1308  0EDE     MOVLW 0xDE
130A  2EE8     DECFSZ WREG, F, ACCESS
130C  D7FE     BRA 0x130A
130E  2E08     DECFSZ type, F, ACCESS
1310  D7FC     BRA 0x130A
47:            //    if ((Values->left_prev = Values->left) && (Values->left < 50)) 
48:            //        {
49:            //            Values->left = 0;
50:            //        }
51:            //    if ((Values->right_prev = Values->right) && (Values->right < 50)) {
52:            //            {
53:            //                Values->right = 0;
54:            //            }
55:            
56:            //        }
57:            }
1312  0012     RETURN 0
58:            
59:            //int measureIRLeft(void)
60:            //{
61:            //    // Initialise IR level variable
62:            //    // ----------------------------------------------------------------------
63:            //    unsigned int IRlevel = 0;
64:            //
65:            //    // Take a predetermined number of readings, and sum the results
66:            //    // ----------------------------------------------------------------------
67:            //    for (char i = 0; i < 2; i++)
68:            //    {
69:            //         IRlevel += CAP1BUFL;  // Get the 8 bit LSB result
70:            //         IRlevel += ((unsigned int)CAP1BUFH << 8); // Get 2 bit MSB result
71:            //         __delay_ms(50);
72:            //    }
73:            //
74:            //    // Reset to zero
75:            //    // ----------------------------------------------------------------------
76:            //    CAP1BUFL = 0;
77:            //    CAP1BUFH = 0;
78:            //
79:            //    // Calculate the average
80:            //    // ----------------------------------------------------------------------
81:            //    IRlevel = IRlevel/3;
82:            //
83:            //    // Return the averaged value
84:            //    // ----------------------------------------------------------------------
85:            //    return IRlevel;
86:            //}
87:            //
88:            //int measureIRright(void)
89:            //{
90:            //    // Initialise IR level variable
91:            //    // ----------------------------------------------------------------------
92:            //    unsigned int IRlevel = 0;
93:            //
94:            //    // Take a predetermined number of readings, and sum the results
95:            //    // ----------------------------------------------------------------------
96:            //    for (char i = 0; i < 2; i++)
97:            //    {
98:            //         IRlevel += CAP1BUFL;  // Get the 8 bit LSB result
99:            //         IRlevel += ((unsigned int)CAP1BUFH << 8); // Get 2 bit MSB result
100:           //         __delay_ms(50);
101:           //    }
102:           //
103:           //    // Reset to zero
104:           //    // ----------------------------------------------------------------------
105:           //    CAP1BUFL = 0;
106:           //    CAP1BUFH = 0;
107:           //
108:           //    // Calculate the average
109:           //    // ----------------------------------------------------------------------
110:           //    IRlevel = IRlevel/2;
111:           //
112:           //    // Return the averaged value
113:           //    // ----------------------------------------------------------------------
114:           //    return IRlevel;
115:           //}
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/strlen.c  ---------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             #ifndef __XC8__
6:             #define ALIGN (sizeof(size_t))
7:             #define ONES ((size_t)-1/UCHAR_MAX)
8:             #define HIGHS (ONES * (UCHAR_MAX/2+1))
9:             #define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)
10:            #endif
11:            
12:            size_t strlen(const char *s)
13:            {
14:            	const char *a = s;
19EE  C006     MOVFF Values, string
19F0  F00A     NOP
19F2  C007     MOVFF number, pa
19F4  F00B     NOP
15:            #ifdef __XC8__
16:            	while(*s) {
19F6  D002     BRA 0x19FC
17:            		s++;
19F8  4A06     INFSNZ Values, F, ACCESS
19FA  2A07     INCF number, F, ACCESS
18:            	}
19FC  C006     MOVFF Values, FSR2
19FE  FFD9     NOP
1A00  C007     MOVFF number, FSR2H
1A02  FFDA     NOP
1A04  50DF     MOVF INDF2, W, ACCESS
1A06  A4D8     BTFSS STATUS, 2, ACCESS
1A08  D7F7     BRA 0x19F8
19:            #else
20:            	const size_t *w;
21:            	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
22:            	for (w = (const void *)s; !HASZERO(*w); w++);
23:            	for (s = (const void *)w; *s; s++);
24:            #endif
25:            	return s-a;
1A0A  C00A     MOVFF string, type
1A0C  F008     NOP
1A0E  C00B     MOVFF pa, Byte
1A10  F009     NOP
1A12  1E08     COMF type, F, ACCESS
1A14  1E09     COMF Byte, F, ACCESS
1A16  4A08     INFSNZ type, F, ACCESS
1A18  2A09     INCF Byte, F, ACCESS
1A1A  5006     MOVF Values, W, ACCESS
1A1C  2408     ADDWF type, W, ACCESS
1A1E  6E06     MOVWF Values, ACCESS
1A20  5007     MOVF number, W, ACCESS
1A22  2009     ADDWFC Byte, W, ACCESS
1A24  6E07     MOVWF number, ACCESS
1A26  0012     RETURN 0
26:            }
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/putch.c  ----------------------------------
1:             /*
2:              * Function: putch
3:              * Weak implementation.  User implementation may be required
4:              */
5:             
6:             void 
7:             putch(char c)
8:             {
9:             }
1C1A  0012     RETURN 0
10:            
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/nf_sprintf.c  -----------------------------
1:             #include <stdarg.h>
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             /* "No file system" sprintf */
8:             
9:             int sprintf(char *restrict s, const char *restrict fmt, ...)
10:            {
11:            	int ret;
12:            	va_list ap;
13:            	FILE f;
14:            
15:            	va_start(ap, fmt);
193E  0E76     MOVLW 0x76
1940  0100     MOVLB 0x0
1942  6F7A     MOVWF ap, BANKED
1944  0E00     MOVLW 0x0
1946  6F7B     MOVWF 0x7B, BANKED
16:            	f.buffer = s;
1948  C072     MOVFF s, f
194A  F07C     NOP
194C  C073     MOVFF 0x73, 0x7D
194E  F07D     NOP
17:            	f.count = 0;
1950  0E00     MOVLW 0x0
1952  6F7F     MOVWF 0x7F, BANKED
1954  0E00     MOVLW 0x0
1956  6F7E     MOVWF 0x7E, BANKED
18:            	f.limit = 0;
1958  0E00     MOVLW 0x0
195A  6F81     MOVWF 0x81, BANKED
195C  0E00     MOVLW 0x0
195E  6F80     MOVWF 0x80, BANKED
19:            	ret = vfprintf(&f, fmt, ap);
1960  0E7C     MOVLW 0x7C
1962  6E4F     MOVWF fp, ACCESS
1964  0E00     MOVLW 0x0
1966  6E50     MOVWF 0x50, ACCESS
1968  C074     MOVFF fmt, fmt
196A  F051     NOP
196C  C075     MOVFF 0x75, 0x52
196E  F052     NOP
1970  0E7A     MOVLW 0x7A
1972  6E53     MOVWF ap, ACCESS
1974  0E00     MOVLW 0x0
1976  6E54     MOVWF 0x54, ACCESS
1978  ECCC     CALL 0x1998, 0
197A  F00C     NOP
197C  C04F     MOVFF fp, ret
197E  F078     NOP
1980  C050     MOVFF 0x50, 0x79
1982  F079     NOP
20:            	s[f.count] = '\0';
1984  0100     MOVLB 0x0
1986  517E     MOVF 0x7E, W, BANKED
1988  2572     ADDWF s, W, BANKED
198A  6ED9     MOVWF FSR2, ACCESS
198C  517F     MOVF 0x7F, W, BANKED
198E  2173     ADDWFC 0x73, W, BANKED
1990  6EDA     MOVWF FSR2H, ACCESS
1992  0E00     MOVLW 0x0
1994  6EDF     MOVWF INDF2, ACCESS
1996  0012     RETURN 0
21:            	va_end(ap);
22:            	return ret;
23:            }
24:            
25:            #endif
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/nf_fputs.c  -------------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
1A28  0E00     MOVLW 0x0
1A2A  6E15     MOVWF 0x15, ACCESS
1A2C  0E00     MOVLW 0x0
1A2E  6E14     MOVWF i, ACCESS
14:                while ((c = *(s + i))) {
1A30  D00B     BRA 0x1A48
15:            	fputc(c,fp);
1A32  C013     MOVFF c, Values
1A34  F006     NOP
1A36  6A07     CLRF number, ACCESS
1A38  C011     MOVFF fp, type
1A3A  F008     NOP
1A3C  C012     MOVFF quotient, Byte
1A3E  F009     NOP
1A40  ECE1     CALL 0x13C2, 0
1A42  F009     NOP
16:                    ++i;
1A44  4A14     INFSNZ i, F, ACCESS
1A46  2A15     INCF 0x15, F, ACCESS
17:                }
1A48  5014     MOVF i, W, ACCESS
1A4A  240F     ADDWF s, W, ACCESS
1A4C  6ED9     MOVWF FSR2, ACCESS
1A4E  5015     MOVF 0x15, W, ACCESS
1A50  2010     ADDWFC counter, W, ACCESS
1A52  6EDA     MOVWF FSR2H, ACCESS
1A54  50DF     MOVF INDF2, W, ACCESS
1A56  6E13     MOVWF c, ACCESS
1A58  5013     MOVF c, W, ACCESS
1A5A  B4D8     BTFSC STATUS, 2, ACCESS
1A5C  0012     RETURN 0
1A5E  D7E9     BRA 0x1A32
18:                return i;
19:            }
20:            
21:            #endif
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/nf_fputc.c  -------------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
13C2  5008     MOVF type, W, ACCESS
13C4  1009     IORWF Byte, W, ACCESS
13C6  B4D8     BTFSC STATUS, 2, ACCESS
13C8  D004     BRA 0x13D2
13CA  5008     MOVF type, W, ACCESS
13CC  1009     IORWF Byte, W, ACCESS
13CE  A4D8     BTFSS STATUS, 2, ACCESS
13D0  D004     BRA 0x13DA
13:                    putch(c);
13D2  5006     MOVF Values, W, ACCESS
13D4  EC0D     CALL 0x1C1A, 0
13D6  F00E     NOP
14:                } else {
13D8  0012     RETURN 0
15:            	if((fp->limit == 0) || (fp->count < fp->limit)) {
13DA  EE20     LFSR 2, 0x4
13DC  F004     NOP
13DE  5008     MOVF type, W, ACCESS
13E0  26D9     ADDWF FSR2, F, ACCESS
13E2  5009     MOVF Byte, W, ACCESS
13E4  22DA     ADDWFC FSR2H, F, ACCESS
13E6  50DE     MOVF POSTINC2, W, ACCESS
13E8  10DE     IORWF POSTINC2, W, ACCESS
13EA  B4D8     BTFSC STATUS, 2, ACCESS
13EC  D016     BRA 0x141A
13EE  EE20     LFSR 2, 0x4
13F0  F004     NOP
13F2  5008     MOVF type, W, ACCESS
13F4  26D9     ADDWF FSR2, F, ACCESS
13F6  5009     MOVF Byte, W, ACCESS
13F8  22DA     ADDWFC FSR2H, F, ACCESS
13FA  EE10     LFSR 1, 0x2
13FC  F002     NOP
13FE  5008     MOVF type, W, ACCESS
1400  26E1     ADDWF FSR1, F, ACCESS
1402  5009     MOVF Byte, W, ACCESS
1404  22E2     ADDWFC FSR1H, F, ACCESS
1406  50DE     MOVF POSTINC2, W, ACCESS
1408  5CE6     SUBWF POSTINC1, W, ACCESS
140A  50E6     MOVF POSTINC1, W, ACCESS
140C  0A80     XORLW 0x80
140E  6E0E     MOVWF divisor, ACCESS
1410  50DE     MOVF POSTINC2, W, ACCESS
1412  0A80     XORLW 0x80
1414  580E     SUBWFB divisor, W, ACCESS
1416  B0D8     BTFSC STATUS, 0, ACCESS
1418  0012     RETURN 0
16:            	        fp->buffer[fp->count] = (char)c;
141A  EE20     LFSR 2, 0x2
141C  F002     NOP
141E  5008     MOVF type, W, ACCESS
1420  26D9     ADDWF FSR2, F, ACCESS
1422  5009     MOVF Byte, W, ACCESS
1424  22DA     ADDWFC FSR2H, F, ACCESS
1426  CFDE     MOVFF POSTINC2, string
1428  F00A     NOP
142A  CFDD     MOVFF POSTDEC2, pa
142C  F00B     NOP
142E  C008     MOVFF type, FSR2
1430  FFD9     NOP
1432  C009     MOVFF Byte, FSR2H
1434  FFDA     NOP
1436  CFDE     MOVFF POSTINC2, dividend
1438  F00C     NOP
143A  CFDD     MOVFF POSTDEC2, dis
143C  F00D     NOP
143E  500A     MOVF string, W, ACCESS
1440  240C     ADDWF dividend, W, ACCESS
1442  6ED9     MOVWF FSR2, ACCESS
1444  500B     MOVF pa, W, ACCESS
1446  200D     ADDWFC dis, W, ACCESS
1448  6EDA     MOVWF FSR2H, ACCESS
144A  C006     MOVFF Values, INDF2
144C  FFDF     NOP
17:            		++fp->count;
144E  EE20     LFSR 2, 0x2
1450  F002     NOP
1452  5008     MOVF type, W, ACCESS
1454  26D9     ADDWF FSR2, F, ACCESS
1456  5009     MOVF Byte, W, ACCESS
1458  22DA     ADDWFC FSR2H, F, ACCESS
145A  2ADE     INCF POSTINC2, F, ACCESS
145C  0E00     MOVLW 0x0
145E  22DD     ADDWFC POSTDEC2, F, ACCESS
18:            	}
19:                }
1460  0012     RETURN 0
20:                return (unsigned char)c;
21:            }
22:            
23:            #endif
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/lomod.c  ----------------------------------
1:             // long long unsigned unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lomod(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lomod(unsigned long long int dividend, unsigned long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter;
13:            
14:            	if(divisor != 0) {
1314  500E     MOVF divisor, W, ACCESS
1316  100F     IORWF s, W, ACCESS
1318  1010     IORWF counter, W, ACCESS
131A  1011     IORWF fp, W, ACCESS
131C  1012     IORWF quotient, W, ACCESS
131E  1013     IORWF c, W, ACCESS
1320  1014     IORWF i, W, ACCESS
1322  1015     IORWF 0x15, W, ACCESS
1324  B4D8     BTFSC STATUS, 2, ACCESS
1326  D03C     BRA 0x13A0
15:            		counter = 1;
1328  0E01     MOVLW 0x1
132A  6E16     MOVWF fp, ACCESS
16:            		while((divisor & 0x8000000000000000ULL) == 0) {
132C  D00A     BRA 0x1342
17:            			divisor <<= 1;
132E  90D8     BCF STATUS, 0, ACCESS
1330  360E     RLCF divisor, F, ACCESS
1332  360F     RLCF s, F, ACCESS
1334  3610     RLCF counter, F, ACCESS
1336  3611     RLCF fp, F, ACCESS
1338  3612     RLCF quotient, F, ACCESS
133A  3613     RLCF c, F, ACCESS
133C  3614     RLCF i, F, ACCESS
133E  3615     RLCF 0x15, F, ACCESS
18:            			counter++;
1340  2A16     INCF fp, F, ACCESS
19:            		}
1342  AE15     BTFSS 0x15, 7, ACCESS
1344  D7F4     BRA 0x132E
20:            		do {
21:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
1346  500E     MOVF divisor, W, ACCESS
1348  5C06     SUBWF Values, W, ACCESS
134A  500F     MOVF s, W, ACCESS
134C  5807     SUBWFB number, W, ACCESS
134E  5010     MOVF counter, W, ACCESS
1350  5808     SUBWFB type, W, ACCESS
1352  5011     MOVF fp, W, ACCESS
1354  5809     SUBWFB Byte, W, ACCESS
1356  5012     MOVF quotient, W, ACCESS
1358  580A     SUBWFB string, W, ACCESS
135A  5013     MOVF c, W, ACCESS
135C  580B     SUBWFB pa, W, ACCESS
135E  5014     MOVF i, W, ACCESS
1360  580C     SUBWFB dividend, W, ACCESS
1362  5015     MOVF 0x15, W, ACCESS
1364  580D     SUBWFB dis, W, ACCESS
1366  A0D8     BTFSS STATUS, 0, ACCESS
1368  D010     BRA 0x138A
22:            				dividend -= divisor;
136A  500E     MOVF divisor, W, ACCESS
136C  5E06     SUBWF Values, F, ACCESS
136E  500F     MOVF s, W, ACCESS
1370  5A07     SUBWFB number, F, ACCESS
1372  5010     MOVF counter, W, ACCESS
1374  5A08     SUBWFB type, F, ACCESS
1376  5011     MOVF fp, W, ACCESS
1378  5A09     SUBWFB Byte, F, ACCESS
137A  5012     MOVF quotient, W, ACCESS
137C  5A0A     SUBWFB string, F, ACCESS
137E  5013     MOVF c, W, ACCESS
1380  5A0B     SUBWFB pa, F, ACCESS
1382  5014     MOVF i, W, ACCESS
1384  5A0C     SUBWFB dividend, F, ACCESS
1386  5015     MOVF 0x15, W, ACCESS
1388  5A0D     SUBWFB dis, F, ACCESS
23:            			*(unsigned long long int *)&divisor >>= 1;
138A  90D8     BCF STATUS, 0, ACCESS
138C  3215     RRCF 0x15, F, ACCESS
138E  3214     RRCF i, F, ACCESS
1390  3213     RRCF c, F, ACCESS
1392  3212     RRCF quotient, F, ACCESS
1394  3211     RRCF fp, F, ACCESS
1396  3210     RRCF counter, F, ACCESS
1398  320F     RRCF s, F, ACCESS
139A  320E     RRCF divisor, F, ACCESS
24:            		} while(--counter != 0);
139C  2E16     DECFSZ fp, F, ACCESS
139E  D7D3     BRA 0x1346
25:            	}
26:            	return dividend;
13A0  C006     MOVFF Values, Values
13A2  F006     NOP
13A4  C007     MOVFF number, number
13A6  F007     NOP
13A8  C008     MOVFF type, type
13AA  F008     NOP
13AC  C009     MOVFF Byte, Byte
13AE  F009     NOP
13B0  C00A     MOVFF string, string
13B2  F00A     NOP
13B4  C00B     MOVFF pa, pa
13B6  F00B     NOP
13B8  C00C     MOVFF dividend, dividend
13BA  F00C     NOP
13BC  C00D     MOVFF dis, dis
13BE  F00D     NOP
27:            }
13C0  0012     RETURN 0
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/lodiv.c  ----------------------------------
1:             // long long unsigned unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lodiv(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lodiv(unsigned long long int dividend, unsigned long long int divisor)
10:            #endif
11:            {
12:            	unsigned long long int	quotient;
13:            	unsigned char	counter;
14:            
15:            	quotient = 0;
10C4  EE20     LFSR 2, 0x16
10C6  F016     NOP
10C8  0E07     MOVLW 0x7
10CA  6ADE     CLRF POSTINC2, ACCESS
10CC  06E8     DECF WREG, F, ACCESS
10CE  E2FD     BC 0x10CA
16:            	if(divisor != 0) {
10D0  500E     MOVF divisor, W, ACCESS
10D2  100F     IORWF s, W, ACCESS
10D4  1010     IORWF counter, W, ACCESS
10D6  1011     IORWF fp, W, ACCESS
10D8  1012     IORWF quotient, W, ACCESS
10DA  1013     IORWF c, W, ACCESS
10DC  1014     IORWF i, W, ACCESS
10DE  1015     IORWF 0x15, W, ACCESS
10E0  B4D8     BTFSC STATUS, 2, ACCESS
10E2  D046     BRA 0x1170
17:            		counter = 1;
10E4  0E01     MOVLW 0x1
10E6  6E1E     MOVWF counter, ACCESS
18:            		while((divisor & 0x8000000000000000ULL) == 0) {
10E8  D00A     BRA 0x10FE
19:            			divisor <<= 1;
10EA  90D8     BCF STATUS, 0, ACCESS
10EC  360E     RLCF divisor, F, ACCESS
10EE  360F     RLCF s, F, ACCESS
10F0  3610     RLCF counter, F, ACCESS
10F2  3611     RLCF fp, F, ACCESS
10F4  3612     RLCF quotient, F, ACCESS
10F6  3613     RLCF c, F, ACCESS
10F8  3614     RLCF i, F, ACCESS
10FA  3615     RLCF 0x15, F, ACCESS
20:            			counter++;
10FC  2A1E     INCF counter, F, ACCESS
21:            		}
10FE  AE15     BTFSS 0x15, 7, ACCESS
1100  D7F4     BRA 0x10EA
22:            		do {
23:            			quotient <<= 1;
1102  90D8     BCF STATUS, 0, ACCESS
1104  3616     RLCF fp, F, ACCESS
1106  3617     RLCF sign, F, ACCESS
1108  3618     RLCF buf, F, ACCESS
110A  3619     RLCF PWMduty, F, ACCESS
110C  361A     RLCF p, F, ACCESS
110E  361B     RLCF mL, F, ACCESS
1110  361C     RLCF 0x1C, F, ACCESS
1112  361D     RLCF i, F, ACCESS
24:            			if(divisor <= dividend) {
1114  500E     MOVF divisor, W, ACCESS
1116  5C06     SUBWF Values, W, ACCESS
1118  500F     MOVF s, W, ACCESS
111A  5807     SUBWFB number, W, ACCESS
111C  5010     MOVF counter, W, ACCESS
111E  5808     SUBWFB type, W, ACCESS
1120  5011     MOVF fp, W, ACCESS
1122  5809     SUBWFB Byte, W, ACCESS
1124  5012     MOVF quotient, W, ACCESS
1126  580A     SUBWFB string, W, ACCESS
1128  5013     MOVF c, W, ACCESS
112A  580B     SUBWFB pa, W, ACCESS
112C  5014     MOVF i, W, ACCESS
112E  580C     SUBWFB dividend, W, ACCESS
1130  5015     MOVF 0x15, W, ACCESS
1132  580D     SUBWFB dis, W, ACCESS
1134  A0D8     BTFSS STATUS, 0, ACCESS
1136  D011     BRA 0x115A
25:            				dividend -= divisor;
1138  500E     MOVF divisor, W, ACCESS
113A  5E06     SUBWF Values, F, ACCESS
113C  500F     MOVF s, W, ACCESS
113E  5A07     SUBWFB number, F, ACCESS
1140  5010     MOVF counter, W, ACCESS
1142  5A08     SUBWFB type, F, ACCESS
1144  5011     MOVF fp, W, ACCESS
1146  5A09     SUBWFB Byte, F, ACCESS
1148  5012     MOVF quotient, W, ACCESS
114A  5A0A     SUBWFB string, F, ACCESS
114C  5013     MOVF c, W, ACCESS
114E  5A0B     SUBWFB pa, F, ACCESS
1150  5014     MOVF i, W, ACCESS
1152  5A0C     SUBWFB dividend, F, ACCESS
1154  5015     MOVF 0x15, W, ACCESS
1156  5A0D     SUBWFB dis, F, ACCESS
26:            				quotient |= 1;
1158  8016     BSF fp, 0, ACCESS
27:            			}
28:            			divisor >>= 1;
115A  90D8     BCF STATUS, 0, ACCESS
115C  3215     RRCF 0x15, F, ACCESS
115E  3214     RRCF i, F, ACCESS
1160  3213     RRCF c, F, ACCESS
1162  3212     RRCF quotient, F, ACCESS
1164  3211     RRCF fp, F, ACCESS
1166  3210     RRCF counter, F, ACCESS
1168  320F     RRCF s, F, ACCESS
116A  320E     RRCF divisor, F, ACCESS
29:            		} while(--counter != 0);
116C  2E1E     DECFSZ counter, F, ACCESS
116E  D7C9     BRA 0x1102
30:            	}
31:            	return quotient;
1170  C016     MOVFF fp, Values
1172  F006     NOP
1174  C017     MOVFF sign, number
1176  F007     NOP
1178  C018     MOVFF buf, type
117A  F008     NOP
117C  C019     MOVFF PWMduty, Byte
117E  F009     NOP
1180  C01A     MOVFF p, string
1182  F00A     NOP
1184  C01B     MOVFF mL, pa
1186  F00B     NOP
1188  C01C     MOVFF 0x1C, dividend
118A  F00C     NOP
118C  C01D     MOVFF i, dis
118E  F00D     NOP
32:            }
1190  0012     RETURN 0
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/doprnt.c  ---------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
1624  A057     BTFSS flags, 0, ACCESS
78:                    fputs((const char *)buf, fp);
1628  C018     MOVFF buf, s
162A  F00F     NOP
162C  C019     MOVFF PWMduty, counter
162E  F010     NOP
1630  C016     MOVFF fp, fp
1632  F011     NOP
1634  C017     MOVFF sign, quotient
1636  F012     NOP
1638  EC14     CALL 0x1A28, 0
163A  F00D     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
163C  BE1B     BTFSC mL, 7, ACCESS
163E  D005     BRA 0x164A
1640  C01A     MOVFF p, w
1642  F01F     NOP
1644  C01B     MOVFF mL, 0x20
1646  F020     NOP
1648  D004     BRA 0x1652
164A  0E00     MOVLW 0x0
164C  6E20     MOVWF 0x20, ACCESS
164E  0E00     MOVLW 0x0
1650  6E1F     MOVWF w, ACCESS
83:                i = 0;
1652  0E00     MOVLW 0x0
1654  6E1E     MOVWF counter, ACCESS
1656  0E00     MOVLW 0x0
1658  6E1D     MOVWF i, ACCESS
84:                while (i < w) {
165A  D00C     BRA 0x1674
85:                    fputc(' ', fp);
165C  0E00     MOVLW 0x0
165E  6E07     MOVWF number, ACCESS
1660  0E20     MOVLW 0x20
1662  6E06     MOVWF Values, ACCESS
1664  C016     MOVFF fp, type
1666  F008     NOP
1668  C017     MOVFF sign, Byte
166A  F009     NOP
166C  ECE1     CALL 0x13C2, 0
166E  F009     NOP
86:                    ++i;
1670  4A1D     INFSNZ i, F, ACCESS
1672  2A1E     INCF counter, F, ACCESS
87:                }
1674  501F     MOVF w, W, ACCESS
1676  5C1D     SUBWF i, W, ACCESS
1678  501E     MOVF counter, W, ACCESS
167A  0A80     XORLW 0x80
167C  6E1C     MOVWF 0x1C, ACCESS
167E  5020     MOVF 0x20, W, ACCESS
1680  0A80     XORLW 0x80
1682  581C     SUBWFB 0x1C, W, ACCESS
1684  A0D8     BTFSS STATUS, 0, ACCESS
1686  D7EA     BRA 0x165C
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
1688  B057     BTFSC flags, 0, ACCESS
168A  D00A     BRA 0x16A0
91:                    fputs((const char *)buf, fp);
168C  C018     MOVFF buf, s
168E  F00F     NOP
1690  C019     MOVFF PWMduty, counter
1692  F010     NOP
1694  C016     MOVFF fp, fp
1696  F011     NOP
1698  C017     MOVFF sign, quotient
169A  F012     NOP
169C  EC14     CALL 0x1A28, 0
169E  F00D     NOP
92:                }
93:            
94:                return strlen(buf) + w;
16A0  C018     MOVFF buf, Values
16A2  F006     NOP
16A4  C019     MOVFF PWMduty, number
16A6  F007     NOP
16A8  ECF7     CALL 0x19EE, 0
16AA  F00C     NOP
16AC  501F     MOVF w, W, ACCESS
16AE  2406     ADDWF Values, W, ACCESS
16B0  6E16     MOVWF fp, ACCESS
16B2  5020     MOVF 0x20, W, ACCESS
16B4  2007     ADDWFC number, W, ACCESS
16B6  6E17     MOVWF sign, ACCESS
16B8  0012     RETURN 0
95:            }
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? '0' + d : 'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Put out padded string */
267:               dbuf[0] = c;
268:               dbuf[1] = '\0';
269:               return pad(fp, &dbuf[0], w);
270:           }
271:           #endif
272:           
273:           #ifdef _VFPF_D
274:           static _INLINE int dtoa(FILE *fp, long long d)
275:           {
276:               int i, p, s, w;
277:               long long n;
278:           
279:               /* Record sign, get absolute value */
280:               n = d;
05C2  C023     MOVFF d, n
281:               s = n < 0 ? 1 : 0;
05E2  AE42     BTFSS 0x42, 7, ACCESS
05E4  D002     BRA 0x5EA
05E6  0E01     MOVLW 0x1
05E8  D001     BRA 0x5EC
05EA  0E00     MOVLW 0x0
05EC  6E39     MOVWF s, ACCESS
05EE  6A3A     CLRF 0x3A, ACCESS
282:               if (s) {
05F0  5039     MOVF s, W, ACCESS
05F2  103A     IORWF 0x3A, W, ACCESS
05F4  B4D8     BTFSC STATUS, 2, ACCESS
05F6  D010     BRA 0x618
283:                   n = -n;
05F8  1E42     COMF 0x42, F, ACCESS
05FA  1E41     COMF 0x41, F, ACCESS
05FC  1E40     COMF 0x40, F, ACCESS
05FE  1E3F     COMF i, F, ACCESS
0600  1E3E     COMF 0x3E, F, ACCESS
0602  1E3D     COMF 0x3D, F, ACCESS
0604  1E3C     COMF 0x3C, F, ACCESS
0606  6C3B     NEGF n, ACCESS
0608  0E00     MOVLW 0x0
060A  223C     ADDWFC 0x3C, F, ACCESS
060C  223D     ADDWFC 0x3D, F, ACCESS
060E  223E     ADDWFC 0x3E, F, ACCESS
0610  223F     ADDWFC i, F, ACCESS
0612  2240     ADDWFC 0x40, F, ACCESS
0614  2241     ADDWFC 0x41, F, ACCESS
0616  2242     ADDWFC 0x42, F, ACCESS
284:               }
285:           
286:               /* Adjust flags, precision, width */
287:               if (!(prec < 0)) {
0618  AE56     BTFSS 0x56, 7, ACCESS
288:                   flags &= ~ZERO_FLAG;
061A  9257     BCF flags, 1, ACCESS
289:               }
290:               p = (0 < prec) ? prec : 1;
061C  BE56     BTFSC 0x56, 7, ACCESS
061E  D005     BRA 0x62A
0620  5056     MOVF 0x56, W, ACCESS
0622  E108     BNZ 0x634
0624  0455     DECF prec, W, ACCESS
0626  B0D8     BTFSC STATUS, 0, ACCESS
0628  D005     BRA 0x634
062A  0E00     MOVLW 0x0
062C  6E36     MOVWF 0x36, ACCESS
062E  0E01     MOVLW 0x1
0630  6E35     MOVWF p, ACCESS
0632  D004     BRA 0x63C
0634  C055     MOVFF prec, p
0636  F035     NOP
0638  C056     MOVFF 0x56, 0x36
063A  F036     NOP
291:               w = width;
063C  C0BC     MOVFF width, w
063E  F037     NOP
0640  C0BD     MOVFF 0xBD, 0x38
0642  F038     NOP
292:               if (s || (flags & PLUS_FLAG)) {
0644  5039     MOVF s, W, ACCESS
0646  103A     IORWF 0x3A, W, ACCESS
0648  A4D8     BTFSS STATUS, 2, ACCESS
064A  D002     BRA 0x650
064C  A457     BTFSS flags, 2, ACCESS
064E  D003     BRA 0x656
293:                   --w;
0650  0637     DECF w, F, ACCESS
0652  A0D8     BTFSS STATUS, 0, ACCESS
0654  0638     DECF 0x38, F, ACCESS
294:               }
295:           
296:               /* Convert to decimal, possibly filling on the left with zeroes */
297:               i = sizeof(dbuf) - 1;
0656  0E00     MOVLW 0x0
0658  6E44     MOVWF 0x44, ACCESS
065A  0E1F     MOVLW 0x1F
065C  6E43     MOVWF i, ACCESS
298:               dbuf[i] = '\0';
065E  0EBF     MOVLW 0xBF
0660  2443     ADDWF i, W, ACCESS
0662  6ED9     MOVWF FSR2, ACCESS
0664  0E00     MOVLW 0x0
0666  2044     ADDWFC 0x44, W, ACCESS
0668  6EDA     MOVWF FSR2H, ACCESS
066A  0E00     MOVLW 0x0
066C  6EDF     MOVWF INDF2, ACCESS
299:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
066E  D07C     BRA 0x768
300:                   --i;
0670  0643     DECF i, F, ACCESS
0672  A0D8     BTFSS STATUS, 0, ACCESS
0674  0644     DECF 0x44, F, ACCESS
301:                   dbuf[i] = '0' + abs(n % 10);
0676  0EBF     MOVLW 0xBF
0678  2443     ADDWF i, W, ACCESS
067A  6ED9     MOVWF FSR2, ACCESS
067C  0E00     MOVLW 0x0
067E  2044     ADDWFC 0x44, W, ACCESS
0680  6EDA     MOVWF FSR2H, ACCESS
0682  C03B     MOVFF n, Values
0684  F006     NOP
0686  C03C     MOVFF 0x3C, number
0688  F007     NOP
068A  C03D     MOVFF 0x3D, type
068C  F008     NOP
068E  C03E     MOVFF 0x3E, Byte
0690  F009     NOP
0692  C03F     MOVFF i, string
0694  F00A     NOP
0696  C040     MOVFF 0x40, pa
0698  F00B     NOP
069A  C041     MOVFF 0x41, dividend
069C  F00C     NOP
069E  C042     MOVFF 0x42, dis
06A0  F00D     NOP
06A2  0E0A     MOVLW 0xA
06A4  6E0E     MOVWF divisor, ACCESS
06A6  0E00     MOVLW 0x0
06A8  6E0F     MOVWF s, ACCESS
06AA  0E00     MOVLW 0x0
06AC  6E10     MOVWF counter, ACCESS
06AE  0E00     MOVLW 0x0
06B0  6E11     MOVWF fp, ACCESS
06B2  0E00     MOVLW 0x0
06B4  6E12     MOVWF quotient, ACCESS
06B6  0E00     MOVLW 0x0
06B8  6E13     MOVWF c, ACCESS
06BA  0E00     MOVLW 0x0
06BC  6E14     MOVWF i, ACCESS
06BE  0E00     MOVLW 0x0
06C0  6E15     MOVWF 0x15, ACCESS
06C2  EC5B     CALL 0xEB6, 0
06C4  F007     NOP
06C6  C006     MOVFF Values, 0x2B
06C8  F02B     NOP
06CA  C007     MOVFF number, 0x2C
06CC  F02C     NOP
06CE  C008     MOVFF type, 0x2D
06D0  F02D     NOP
06D2  C009     MOVFF Byte, 0x2E
06D4  F02E     NOP
06D6  C00A     MOVFF string, 0x2F
06D8  F02F     NOP
06DA  C00B     MOVFF pa, 0x30
06DC  F030     NOP
06DE  C00C     MOVFF dividend, 0x31
06E0  F031     NOP
06E2  C00D     MOVFF dis, 0x32
06E4  F032     NOP
06E6  C02B     MOVFF 0x2B, buf
06E8  F018     NOP
06EA  C02D     MOVFF 0x2D, PWMduty
06EC  F019     NOP
06EE  EC30     CALL 0x1A60, 0
06F0  F00D     NOP
06F2  5018     MOVF buf, W, ACCESS
06F4  0F30     ADDLW 0x30
06F6  6EDF     MOVWF INDF2, ACCESS
302:                   --p;
06F8  0635     DECF p, F, ACCESS
06FA  A0D8     BTFSS STATUS, 0, ACCESS
06FC  0636     DECF 0x36, F, ACCESS
303:                   --w;
06FE  0637     DECF w, F, ACCESS
0700  A0D8     BTFSS STATUS, 0, ACCESS
0702  0638     DECF 0x38, F, ACCESS
304:                   n = n / 10;
0704  C03B     MOVFF n, Values
0706  F006     NOP
0708  C03C     MOVFF 0x3C, number
070A  F007     NOP
070C  C03D     MOVFF 0x3D, type
070E  F008     NOP
0710  C03E     MOVFF 0x3E, Byte
0712  F009     NOP
0714  C03F     MOVFF i, string
0716  F00A     NOP
0718  C040     MOVFF 0x40, pa
071A  F00B     NOP
071C  C041     MOVFF 0x41, dividend
071E  F00C     NOP
0720  C042     MOVFF 0x42, dis
0722  F00D     NOP
0724  0E0A     MOVLW 0xA
0726  6E0E     MOVWF divisor, ACCESS
0728  0E00     MOVLW 0x0
072A  6E0F     MOVWF s, ACCESS
072C  0E00     MOVLW 0x0
072E  6E10     MOVWF counter, ACCESS
0730  0E00     MOVLW 0x0
0732  6E11     MOVWF fp, ACCESS
0734  0E00     MOVLW 0x0
0736  6E12     MOVWF quotient, ACCESS
0738  0E00     MOVLW 0x0
073A  6E13     MOVWF c, ACCESS
073C  0E00     MOVLW 0x0
073E  6E14     MOVWF i, ACCESS
0740  0E00     MOVLW 0x0
0742  6E15     MOVWF 0x15, ACCESS
0744  ECB7     CALL 0xD6E, 0
0746  F006     NOP
0748  C006     MOVFF Values, n
074A  F03B     NOP
074C  C007     MOVFF number, 0x3C
074E  F03C     NOP
0750  C008     MOVFF type, 0x3D
0752  F03D     NOP
0754  C009     MOVFF Byte, 0x3E
0756  F03E     NOP
0758  C00A     MOVFF string, i
075A  F03F     NOP
075C  C00B     MOVFF pa, 0x40
075E  F040     NOP
0760  C00C     MOVFF dividend, 0x41
0762  F041     NOP
0764  C00D     MOVFF dis, 0x42
0766  F042     NOP
305:               }
0768  BE44     BTFSC 0x44, 7, ACCESS
076A  D01F     BRA 0x7AA
076C  5044     MOVF 0x44, W, ACCESS
076E  E103     BNZ 0x776
0770  0443     DECF i, W, ACCESS
0772  A0D8     BTFSS STATUS, 0, ACCESS
0774  D01A     BRA 0x7AA
0776  503B     MOVF n, W, ACCESS
0778  103C     IORWF 0x3C, W, ACCESS
077A  103D     IORWF 0x3D, W, ACCESS
077C  103E     IORWF 0x3E, W, ACCESS
077E  103F     IORWF i, W, ACCESS
0780  1040     IORWF 0x40, W, ACCESS
0782  1041     IORWF 0x41, W, ACCESS
0784  1042     IORWF 0x42, W, ACCESS
0786  A4D8     BTFSS STATUS, 2, ACCESS
0788  D773     BRA 0x670
078A  BE36     BTFSC 0x36, 7, ACCESS
078C  D005     BRA 0x798
078E  5036     MOVF 0x36, W, ACCESS
0790  E102     BNZ 0x796
0792  0435     DECF p, W, ACCESS
0794  B0D8     BTFSC STATUS, 0, ACCESS
0796  D76C     BRA 0x670
0798  BE38     BTFSC 0x38, 7, ACCESS
079A  D007     BRA 0x7AA
079C  5038     MOVF 0x38, W, ACCESS
079E  E103     BNZ 0x7A6
07A0  0437     DECF w, W, ACCESS
07A2  A0D8     BTFSS STATUS, 0, ACCESS
07A4  D002     BRA 0x7AA
07A6  B257     BTFSC flags, 1, ACCESS
07A8  D763     BRA 0x670
306:           
307:               /* Display sign if required */
308:               if (s || (flags & PLUS_FLAG)) {
07AA  5039     MOVF s, W, ACCESS
07AC  103A     IORWF 0x3A, W, ACCESS
07AE  A4D8     BTFSS STATUS, 2, ACCESS
07B0  D002     BRA 0x7B6
07B2  A457     BTFSS flags, 2, ACCESS
07B4  D017     BRA 0x7E4
309:                   --i;
07B6  0643     DECF i, F, ACCESS
07B8  A0D8     BTFSS STATUS, 0, ACCESS
07BA  0644     DECF 0x44, F, ACCESS
310:                   dbuf[i] = s ? '-' : '+';
07BC  5039     MOVF s, W, ACCESS
07BE  103A     IORWF 0x3A, W, ACCESS
07C0  A4D8     BTFSS STATUS, 2, ACCESS
07C2  D004     BRA 0x7CC
07C4  0E00     MOVLW 0x0
07C6  6E34     MOVWF 0x34, ACCESS
07C8  0E2B     MOVLW 0x2B
07CA  D003     BRA 0x7D2
07CC  0E00     MOVLW 0x0
07CE  6E34     MOVWF 0x34, ACCESS
07D0  0E2D     MOVLW 0x2D
07D2  6E33     MOVWF p, ACCESS
07D4  0EBF     MOVLW 0xBF
07D6  2443     ADDWF i, W, ACCESS
07D8  6ED9     MOVWF FSR2, ACCESS
07DA  0E00     MOVLW 0x0
07DC  2044     ADDWFC 0x44, W, ACCESS
07DE  6EDA     MOVWF FSR2H, ACCESS
07E0  C033     MOVFF p, INDF2
07E2  FFDF     NOP
311:               }
312:           
313:               /* Put out padded string */
314:               return pad(fp, &dbuf[i], w);
07E4  C021     MOVFF fp, fp
07E6  F016     NOP
07E8  C022     MOVFF 0x22, sign
07EA  F017     NOP
07EC  0EBF     MOVLW 0xBF
07EE  2443     ADDWF i, W, ACCESS
07F0  6E18     MOVWF buf, ACCESS
07F2  0E00     MOVLW 0x0
07F4  2044     ADDWFC 0x44, W, ACCESS
07F6  6E19     MOVWF PWMduty, ACCESS
07F8  C037     MOVFF w, p
07FA  F01A     NOP
07FC  C038     MOVFF 0x38, mL
07FE  F01B     NOP
0800  EC12     CALL 0x1624, 0
0802  F00B     NOP
0804  C016     MOVFF fp, fp
0806  F021     NOP
0808  C017     MOVFF sign, 0x22
080A  F022     NOP
080C  0012     RETURN 0
315:           }
316:           #endif
317:           
318:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
319:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
320:           {
321:               char mode, nmode;
322:               int d, e, i, m, n, ne, p, pp, sign, t, w;
323:               long double g, h, l, ou, u;
324:           
325:               /* Record sign, get absolute value */
326:               sign = 0;
327:               g = f;
328:               if (g < 0.0) {
329:                   sign = 1;
330:                   g = -g;
331:               }
332:           
333:               /* Print sign */
334:               n = 0;
335:               w = width;
336:               if (sign || (flags & PLUS_FLAG)) {
337:                   dbuf[n] = sign ? '-' : '+';
338:                   ++n;
339:                   --w;
340:               }
341:           
342:               /* Catch infinities, NaNs here */
343:               if (isinf(g)) {
344:                   if (isupper((int)c)) {
345:                       strcpy(&dbuf[n], "INF");
346:                   } else {
347:                       strcpy(&dbuf[n], "inf");
348:                   }
349:                   w -= CSTRLEN("inf");
350:                   return pad(fp, &dbuf[0], w);
351:               }
352:               if (isnan(g)) {
353:                   if (isupper((int)c)) {
354:                       strcpy(&dbuf[n], "NAN");
355:                   } else {
356:                       strcpy(&dbuf[n], "nan");
357:                   }
358:                   w -= CSTRLEN("inf");
359:                   return pad(fp, &dbuf[0], w);
360:               }
361:           
362:               /* First find the largest power of 10 not larger than number to print */
363:               u = 1.0;
364:               e = 0;
365:               if (!(g == 0.0)) {
366:                   while (!(g < (u*10.0))) {
367:                       u = u*10.0;
368:                       ++e;
369:                   }
370:                   while (g < u) {
371:                       u = u/10.0;
372:                       --e;
373:                   }
374:               }
375:           
376:               /* Get mode, precision */
377:               mode = tolower((int)c);
378:               nmode = mode;
379:               if (mode == 'g') {
380:           		if (prec == 0) {
381:           			prec = 1;
382:           		}
383:                   p = (0 < prec) ? prec : 6;
384:               } else {
385:                   p = (prec < 0) ? 6 : prec;
386:               }
387:           
388:               /* Choose e or f mode from g mode */
389:               if (mode == 'g') {
390:                   if (!(e < -4) && !((p - 1) < e)) {
391:                       nmode = 'f';
392:                   } else {
393:                       nmode = 'e';
394:                   }
395:               }
396:           
397:               /* Decimal places or significant digits */
398:               m = p;
399:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
400:                   ++m;
401:               }
402:           
403:               /* Adjust starting exponent, string length for 'f' conversions */
404:               if (nmode == 'f') {
405:                   if (e < 0) {
406:                       u = 1.0;
407:                       e = 0;
408:                   }
409:                   if (!(mode == 'g')) {
410:                       m += e;
411:                   }
412:               }
413:           
414:               /* Go through the conversion once to get to the rounding step */
415:               i = 0;
416:               h = g;
417:               ou = u;
418:               while (i < m) {
419:                   l = floor(h/u);
420:                   d = (int)l;
421:                   h -= l*u;
422:                   u = u/10.0;
423:                   ++i;
424:               }
425:               
426:               /* Remainder >= halfway ? */
427:               l = u*5.0;
428:               if (h < l) {
429:                   l = 0.0;
430:               } else {
431:                   /* On tie choose even number */
432:                   if ((h == l) && !(d % 2)) {
433:                       l = 0.0;
434:                   }
435:               }
436:           
437:               /* Round */
438:               h = g + l;
439:               
440:               /* Convert again, after rounding */
441:               u = ou;
442:               ne = (nmode == 'e') ? 0 : e;
443:               pp = 0;
444:               t = 0;
445:               i = 0;
446:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
447:                   l = floor(h/u);
448:                   d = (int)l;
449:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
450:                       ++t;
451:                   } else {
452:                       if (!pp && (ne < 0)) {
453:                           dbuf[n++] = '.';
454:                           --w;
455:                           pp = 1;
456:                       }
457:                       while (t) {
458:                           dbuf[n++] = '0';
459:                           --w;
460:                           --t;
461:                       }
462:                       dbuf[n++] = '0' + d;
463:                       --w;
464:                   }
465:                   h -= l*u;
466:                   u = u/10.0;
467:                   --ne;
468:                   ++i;
469:               }
470:               if (!pp && (flags & POUND_FLAG)) {
471:                   dbuf[n++] = '.';
472:               }
473:               dbuf[n] = '\0';
474:           
475:               /* Convert exponent */
476:               if (nmode == 'e') {
477:                   i = sizeof(dbuf) - 1;
478:                   dbuf[i] = '\0';
479:                   sign = 0;
480:                   if (e < 0) {
481:                       sign = 1;
482:                       e = -e;
483:                   }
484:                   p = 2;
485:                   while (e || (0 < p)) {
486:                       --i;
487:                       dbuf[i] = '0' + (e % 10);
488:                       e = e / 10;
489:                       --p;
490:                       --w;
491:                   }
492:                   --i;
493:                   dbuf[i] = sign ? '-' : '+';
494:                   --w;
495:                   --i;
496:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
497:                   --w;
498:                   strcpy(&dbuf[n], &dbuf[i]);
499:               }
500:           
501:               /* Put out padded string */
502:               return pad(fp, &dbuf[0], w);
503:           }
504:           #endif
505:           
506:           #ifdef _VFPF_O
507:           static _INLINE int otoa(FILE *fp, unsigned long long d)
508:           {
509:               int i, p, t, w;
510:               unsigned long long n;
511:           
512:               /* Adjust flags, precision, width */
513:               if (!(prec < 0)) {
514:                   flags &= ~ZERO_FLAG;
515:               }
516:               p = (0 < prec) ? prec : 1;
517:               w = width;
518:           
519:               /* Convert to octal, possibly filling on the left with zeroes */
520:               n = d;
521:               i = sizeof(dbuf) - 1;
522:               dbuf[i] = '\0';
523:               t = 0;
524:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
525:                   --i;
526:                   t = n & 07;
527:                   dbuf[i] = '0' + t;
528:                   --p;
529:                   --w;
530:                   n = n >> 3;
531:               }
532:           
533:               /* Display prefix if required */
534:               if ((flags & POUND_FLAG) && t) {
535:                   --i;
536:                   dbuf[i] = '0';
537:                   --w;
538:               }
539:           
540:               /* Put out padded string */
541:               return pad(fp, &dbuf[i], w);
542:           }
543:           #endif
544:           
545:           #ifdef _VFPF_S
546:           static _INLINE int stoa(FILE *fp, char *s)
547:           {
548:               char *cp, nuls[] = "(null)";
549:               int i, l, p, w;
550:           
551:               /* Check for null string */
552:               cp = s;
553:               if (!cp) {
554:                   cp = nuls;
555:               }
556:           
557:               /* Get length, precision, width */
558:               l = strlen(cp);
559:               p = prec;
560:               l = (!(p < 0) && (p < l)) ? p : l;
561:               p = l;
562:               w = width;
563:           
564:               /* Right justify, pad on left ? */
565:               if (!(flags & MINUS_FLAG)) {
566:                   while (l < w) {
567:                       fputc(' ', fp);
568:                       ++l;
569:                   }
570:               }
571:           
572:               /* Put out string */
573:               i = 0;
574:               while (i < p) {
575:                   fputc(*cp, fp);
576:                   ++cp;
577:                   ++i;
578:               }
579:           
580:               /* Left justify, pad on right ? */
581:               if (flags & MINUS_FLAG) {
582:                   while (l < w) {
583:                       fputc(' ', fp);
584:                       ++l;
585:                   }
586:               }
587:           
588:               return l;
589:           }
590:           #endif
591:           
592:           #ifdef _VFPF_U
593:           static _INLINE int utoa(FILE *fp, unsigned long long d)
594:           {
595:               int i, p, w;
596:               unsigned long long n;
597:           
598:               /* Adjust flags, precision, width */
599:               if (!(prec < 0)) {
0A34  AE56     BTFSS 0x56, 7, ACCESS
600:                   flags &= ~ZERO_FLAG;
0A36  9257     BCF flags, 1, ACCESS
601:               }
602:               p = (0 < prec) ? prec : 1;
0A38  BE56     BTFSC 0x56, 7, ACCESS
0A3A  D005     BRA 0xA46
0A3C  5056     MOVF 0x56, W, ACCESS
0A3E  E108     BNZ 0xA50
0A40  0455     DECF prec, W, ACCESS
0A42  B0D8     BTFSC STATUS, 0, ACCESS
0A44  D005     BRA 0xA50
0A46  0E00     MOVLW 0x0
0A48  6E34     MOVWF 0x34, ACCESS
0A4A  0E01     MOVLW 0x1
0A4C  6E33     MOVWF p, ACCESS
0A4E  D004     BRA 0xA58
0A50  C055     MOVFF prec, p
0A52  F033     NOP
0A54  C056     MOVFF 0x56, 0x34
0A56  F034     NOP
603:               w = width;
0A58  C0BC     MOVFF width, p
0A5A  F035     NOP
0A5C  C0BD     MOVFF 0xBD, 0x36
0A5E  F036     NOP
604:           
605:               /* Convert to decimal, possibly filling on the left with zeroes */
606:               n = d;
0A60  C023     MOVFF d, w
0A62  F037     NOP
0A64  C024     MOVFF 0x24, 0x38
0A66  F038     NOP
0A68  C025     MOVFF 0x25, s
0A6A  F039     NOP
0A6C  C026     MOVFF 0x26, 0x3A
0A6E  F03A     NOP
0A70  C027     MOVFF 0x27, n
0A72  F03B     NOP
0A74  C028     MOVFF 0x28, 0x3C
0A76  F03C     NOP
0A78  C029     MOVFF 0x29, 0x3D
0A7A  F03D     NOP
0A7C  C02A     MOVFF 0x2A, 0x3E
0A7E  F03E     NOP
607:               i = sizeof(dbuf) - 1;
0A80  0E00     MOVLW 0x0
0A82  6E40     MOVWF 0x40, ACCESS
0A84  0E1F     MOVLW 0x1F
0A86  6E3F     MOVWF i, ACCESS
608:               dbuf[i] = '\0';
0A88  0EBF     MOVLW 0xBF
0A8A  243F     ADDWF i, W, ACCESS
0A8C  6ED9     MOVWF FSR2, ACCESS
0A8E  0E00     MOVLW 0x0
0A90  2040     ADDWFC 0x40, W, ACCESS
0A92  6EDA     MOVWF FSR2H, ACCESS
0A94  0E00     MOVLW 0x0
0A96  6EDF     MOVWF INDF2, ACCESS
609:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
0A98  D076     BRA 0xB86
610:                   --i;
0A9A  063F     DECF i, F, ACCESS
0A9C  A0D8     BTFSS STATUS, 0, ACCESS
0A9E  0640     DECF 0x40, F, ACCESS
611:                   dbuf[i] = '0' + (n % 10);
0AA0  0EBF     MOVLW 0xBF
0AA2  243F     ADDWF i, W, ACCESS
0AA4  6ED9     MOVWF FSR2, ACCESS
0AA6  0E00     MOVLW 0x0
0AA8  2040     ADDWFC 0x40, W, ACCESS
0AAA  6EDA     MOVWF FSR2H, ACCESS
0AAC  C037     MOVFF w, Values
0AAE  F006     NOP
0AB0  C038     MOVFF 0x38, number
0AB2  F007     NOP
0AB4  C039     MOVFF s, type
0AB6  F008     NOP
0AB8  C03A     MOVFF 0x3A, Byte
0ABA  F009     NOP
0ABC  C03B     MOVFF n, string
0ABE  F00A     NOP
0AC0  C03C     MOVFF 0x3C, pa
0AC2  F00B     NOP
0AC4  C03D     MOVFF 0x3D, dividend
0AC6  F00C     NOP
0AC8  C03E     MOVFF 0x3E, dis
0ACA  F00D     NOP
0ACC  0E0A     MOVLW 0xA
0ACE  6E0E     MOVWF divisor, ACCESS
0AD0  0E00     MOVLW 0x0
0AD2  6E0F     MOVWF s, ACCESS
0AD4  0E00     MOVLW 0x0
0AD6  6E10     MOVWF counter, ACCESS
0AD8  0E00     MOVLW 0x0
0ADA  6E11     MOVWF fp, ACCESS
0ADC  0E00     MOVLW 0x0
0ADE  6E12     MOVWF quotient, ACCESS
0AE0  0E00     MOVLW 0x0
0AE2  6E13     MOVWF c, ACCESS
0AE4  0E00     MOVLW 0x0
0AE6  6E14     MOVWF i, ACCESS
0AE8  0E00     MOVLW 0x0
0AEA  6E15     MOVWF 0x15, ACCESS
0AEC  EC8A     CALL 0x1314, 0
0AEE  F009     NOP
0AF0  C006     MOVFF Values, 0x2B
0AF2  F02B     NOP
0AF4  C007     MOVFF number, 0x2C
0AF6  F02C     NOP
0AF8  C008     MOVFF type, 0x2D
0AFA  F02D     NOP
0AFC  C009     MOVFF Byte, 0x2E
0AFE  F02E     NOP
0B00  C00A     MOVFF string, 0x2F
0B02  F02F     NOP
0B04  C00B     MOVFF pa, 0x30
0B06  F030     NOP
0B08  C00C     MOVFF dividend, 0x31
0B0A  F031     NOP
0B0C  C00D     MOVFF dis, 0x32
0B0E  F032     NOP
0B10  502B     MOVF 0x2B, W, ACCESS
0B12  0F30     ADDLW 0x30
0B14  6EDF     MOVWF INDF2, ACCESS
612:                   --p;
0B16  0633     DECF p, F, ACCESS
0B18  A0D8     BTFSS STATUS, 0, ACCESS
0B1A  0634     DECF 0x34, F, ACCESS
613:                   --w;
0B1C  0635     DECF p, F, ACCESS
0B1E  A0D8     BTFSS STATUS, 0, ACCESS
0B20  0636     DECF 0x36, F, ACCESS
614:                   n = n / 10;
0B22  C037     MOVFF w, Values
0B24  F006     NOP
0B26  C038     MOVFF 0x38, number
0B28  F007     NOP
0B2A  C039     MOVFF s, type
0B2C  F008     NOP
0B2E  C03A     MOVFF 0x3A, Byte
0B30  F009     NOP
0B32  C03B     MOVFF n, string
0B34  F00A     NOP
0B36  C03C     MOVFF 0x3C, pa
0B38  F00B     NOP
0B3A  C03D     MOVFF 0x3D, dividend
0B3C  F00C     NOP
0B3E  C03E     MOVFF 0x3E, dis
0B40  F00D     NOP
0B42  0E0A     MOVLW 0xA
0B44  6E0E     MOVWF divisor, ACCESS
0B46  0E00     MOVLW 0x0
0B48  6E0F     MOVWF s, ACCESS
0B4A  0E00     MOVLW 0x0
0B4C  6E10     MOVWF counter, ACCESS
0B4E  0E00     MOVLW 0x0
0B50  6E11     MOVWF fp, ACCESS
0B52  0E00     MOVLW 0x0
0B54  6E12     MOVWF quotient, ACCESS
0B56  0E00     MOVLW 0x0
0B58  6E13     MOVWF c, ACCESS
0B5A  0E00     MOVLW 0x0
0B5C  6E14     MOVWF i, ACCESS
0B5E  0E00     MOVLW 0x0
0B60  6E15     MOVWF 0x15, ACCESS
0B62  EC62     CALL 0x10C4, 0
0B64  F008     NOP
0B66  C006     MOVFF Values, w
0B68  F037     NOP
0B6A  C007     MOVFF number, 0x38
0B6C  F038     NOP
0B6E  C008     MOVFF type, s
0B70  F039     NOP
0B72  C009     MOVFF Byte, 0x3A
0B74  F03A     NOP
0B76  C00A     MOVFF string, n
0B78  F03B     NOP
0B7A  C00B     MOVFF pa, 0x3C
0B7C  F03C     NOP
0B7E  C00C     MOVFF dividend, 0x3D
0B80  F03D     NOP
0B82  C00D     MOVFF dis, 0x3E
0B84  F03E     NOP
615:               }
0B86  503F     MOVF i, W, ACCESS
0B88  1040     IORWF 0x40, W, ACCESS
0B8A  B4D8     BTFSC STATUS, 2, ACCESS
0B8C  D01A     BRA 0xBC2
0B8E  5037     MOVF w, W, ACCESS
0B90  1038     IORWF 0x38, W, ACCESS
0B92  1039     IORWF s, W, ACCESS
0B94  103A     IORWF 0x3A, W, ACCESS
0B96  103B     IORWF n, W, ACCESS
0B98  103C     IORWF 0x3C, W, ACCESS
0B9A  103D     IORWF 0x3D, W, ACCESS
0B9C  103E     IORWF 0x3E, W, ACCESS
0B9E  A4D8     BTFSS STATUS, 2, ACCESS
0BA0  D77C     BRA 0xA9A
0BA2  BE34     BTFSC 0x34, 7, ACCESS
0BA4  D005     BRA 0xBB0
0BA6  5034     MOVF 0x34, W, ACCESS
0BA8  E102     BNZ 0xBAE
0BAA  0433     DECF p, W, ACCESS
0BAC  B0D8     BTFSC STATUS, 0, ACCESS
0BAE  D775     BRA 0xA9A
0BB0  BE36     BTFSC 0x36, 7, ACCESS
0BB2  D007     BRA 0xBC2
0BB4  5036     MOVF 0x36, W, ACCESS
0BB6  E103     BNZ 0xBBE
0BB8  0435     DECF p, W, ACCESS
0BBA  A0D8     BTFSS STATUS, 0, ACCESS
0BBC  D002     BRA 0xBC2
0BBE  B257     BTFSC flags, 1, ACCESS
0BC0  D76C     BRA 0xA9A
616:           
617:               /* Put out padded string */
618:               return pad(fp, &dbuf[i], w);
0BC2  C021     MOVFF fp, fp
0BC4  F016     NOP
0BC6  C022     MOVFF 0x22, sign
0BC8  F017     NOP
0BCA  0EBF     MOVLW 0xBF
0BCC  243F     ADDWF i, W, ACCESS
0BCE  6E18     MOVWF buf, ACCESS
0BD0  0E00     MOVLW 0x0
0BD2  2040     ADDWFC 0x40, W, ACCESS
0BD4  6E19     MOVWF PWMduty, ACCESS
0BD6  C035     MOVFF p, p
0BD8  F01A     NOP
0BDA  C036     MOVFF 0x36, mL
0BDC  F01B     NOP
0BDE  EC12     CALL 0x1624, 0
0BE0  F00B     NOP
0BE2  C016     MOVFF fp, fp
0BE4  F021     NOP
0BE6  C017     MOVFF sign, 0x22
0BE8  F022     NOP
0BEA  0012     RETURN 0
619:           }
620:           #endif
621:           
622:           #if defined(_VFPF_X) || defined(_VFPF_P)
623:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
624:           {
625:               int c, i, p, w;
626:               unsigned long long n;
627:           
628:               /* Adjust, flags, precision, width */
629:               if (!(prec < 0)) {
630:                   flags &= ~ZERO_FLAG;
631:               }
632:               p = (0 < prec) ? prec : 1;
633:               w = width;
634:               if (flags & POUND_FLAG) {
635:                   w -= 2;
636:               }
637:           
638:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
639:               n = d;
640:               i = sizeof(dbuf) - 1;
641:               dbuf[i] = '\0';
642:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
643:                   --i;
644:                   c = n & 0x0f;
645:                   c = (c < 10) ? '0' + c : 'a' + (c - 10);
646:                   if (isupper((int)x) && isalpha(c)) {
647:                       c = toupper(c);
648:                   }
649:                   dbuf[i] = (char)c;
650:                   --p;
651:                   --w;
652:                   n = n >> 4;
653:               }
654:           
655:               /* Display prefix if required */
656:               if (flags & POUND_FLAG) {
657:                   --i;
658:                   dbuf[i] = x;
659:                   --i;
660:                   dbuf[i] = '0';
661:               }
662:           
663:               /* Put out padded string */
664:               return pad(fp, &dbuf[i], w);
665:           }
666:           #endif
667:           
668:           /* Consume and convert the next part of the format string */
669:           #ifdef _VFPF_CONVERT
670:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
671:           {
672:               char c, *cp, ct[3];
673:               int done, i;
674:               long long ll;
675:               unsigned long long llu;
676:               long double f;
677:               void *vp;
678:           
679:               /* Conversion ? */
680:               if ((*fmt)[0] == '%') {
080E  C047     MOVFF fmt, FSR2
681:                   ++*fmt;
0828  C047     MOVFF fmt, FSR2
082A  FFD9     NOP
082C  C048     MOVFF 0x48, FSR2H
082E  FFDA     NOP
0830  2ADE     INCF POSTINC2, F, ACCESS
0832  0E00     MOVLW 0x0
0834  22DD     ADDWFC POSTDEC2, F, ACCESS
682:           
683:                   flags = width = 0;
0836  0E00     MOVLW 0x0
0838  0100     MOVLB 0x0
083A  6FBD     MOVWF 0xBD, BANKED
083C  0E00     MOVLW 0x0
083E  6FBC     MOVWF width, BANKED
0840  C0BC     MOVFF width, flags
0842  F057     NOP
0844  C0BD     MOVFF 0xBD, 0x58
0846  F058     NOP
684:                   prec = -1;
0848  6855     SETF prec, ACCESS
084A  6856     SETF 0x56, ACCESS
685:           
686:           #ifdef _VFPF_FLAGS
687:                   /* Get flags */
688:                   done = 0;
689:                   while (!done) {
690:                       switch ((*fmt)[0]) {
691:                           case '-' :
692:                               flags |= MINUS_FLAG;
693:                               ++*fmt;
694:                               break;
695:                           case '0' :
696:                               flags |= ZERO_FLAG;
697:                               ++*fmt;
698:                               break;
699:                           case '+' :
700:                               flags |= PLUS_FLAG;
701:                               ++*fmt;
702:                               break;
703:                           case ' ' :
704:                               flags |= SPACE_FLAG;
705:                               ++*fmt;
706:                               break;
707:                           case '#' :
708:                               flags |= POUND_FLAG;
709:                               ++*fmt;
710:                               break;
711:                           default:
712:                               done = 1;
713:                               break;
714:                       }
715:                   }
716:                   if (flags & MINUS_FLAG) {
717:                       flags &= ~ZERO_FLAG;
718:                   }
719:           #endif
720:           
721:           #ifdef _VFPF_WIDTH
722:                   /* Get field width */
723:                   if ((*fmt)[0] == '*') {
724:                       ++*fmt;
725:                       width = va_arg(ap, int);
726:                       if (width < 0) {
727:                           flags |= MINUS_FLAG;
728:                           width = -width;
729:                       }
730:                   } else {
731:                       width = atoi(*fmt);
732:                       while (isdigit((*fmt)[0])) {
733:                           ++*fmt;
734:                       }
735:                   }
736:           #endif
737:           
738:           #ifdef _VFPF_PRECISION
739:                   /* Get precision */
740:                   if ((*fmt)[0] == '.') {
741:                       prec = 0;
742:                       ++*fmt;
743:                       if ((*fmt)[0] == '*') {
744:                           ++*fmt;
745:                           prec = va_arg(ap, int);
746:                       } else {
747:                           prec = atoi(*fmt);
748:                           while (isdigit((*fmt)[0])) {
749:                               ++*fmt;
750:                           }
751:                       }
752:                   }
753:           #endif
754:           
755:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
756:                   /* Case-folded conversion types */
757:                   ct[0] = tolower((int)(*fmt)[0]);
758:                   if (ct[0]) {
759:                       ct[1] = tolower((int)(*fmt)[1]);
760:                       if (ct[1]) {
761:                           ct[2] = tolower((int)(*fmt)[2]);
762:                       }
763:                   }
764:           #endif
765:           
766:           #ifdef _VFPF_A
767:                   /* 'a' style (hex) floating point */
768:                   if (ct[0] == 'a') {
769:           
770:                       c = (*fmt)[0];
771:                       ++*fmt;
772:                       f = (long double)va_arg(ap, double);
773:                                   
774:                       return atoa(fp, f, c);
775:                   }
776:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
777:           
778:                       c = (*fmt)[1];
779:                       if (isupper((int)(*fmt)[0])) {
780:                           f = va_arg(ap, long double);
781:                       } else {
782:                           f = (long double)va_arg(ap, double);
783:                       }
784:                       *fmt += CSTRLEN("la");
785:                                   
786:                       return atoa(fp, f, c);
787:                   }
788:           #endif
789:           
790:           #ifdef _VFPF_C
791:                   /* Character */
792:                   if (*fmt[0] == 'c') {
793:                       ++*fmt;
794:                       c = (unsigned char)va_arg(ap, int);
795:                       return ctoa(fp, c);
796:                   }
797:           #endif
798:           
799:           #ifdef _VFPF_D
800:           #ifdef _VFPF_HH
801:                   /* Character decimal integer */
802:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
803:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
804:           
805:                       *fmt += CSTRLEN("hhd");
806:                       ll = (long long)(signed char)va_arg(ap, int);
807:                                   
808:                       return dtoa(fp, ll);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_H
813:                   /* Short decimal integer */
814:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
815:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
816:           
817:                       *fmt += CSTRLEN("hd");
818:                       ll = (long long)(short)va_arg(ap, int);
819:                                   
820:                       return dtoa(fp, ll);
821:                   }
822:           #endif
823:           
824:                   /* Decimal integer */
825:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
084C  C047     MOVFF fmt, FSR2
084E  FFD9     NOP
0850  C048     MOVFF 0x48, FSR2H
0852  FFDA     NOP
0854  CFDE     MOVFF POSTINC2, TBLPTR
0856  FFF6     NOP
0858  CFDD     MOVFF POSTDEC2, TBLPTRH
085A  FFF7     NOP
085C  0008     TBLRD*
085E  50F5     MOVF TABLAT, W, ACCESS
0860  0A64     XORLW 0x64
0862  B4D8     BTFSC STATUS, 2, ACCESS
0864  D00D     BRA 0x880
0866  C047     MOVFF fmt, FSR2
0868  FFD9     NOP
086A  C048     MOVFF 0x48, FSR2H
086C  FFDA     NOP
086E  CFDE     MOVFF POSTINC2, TBLPTR
0870  FFF6     NOP
0872  CFDD     MOVFF POSTDEC2, TBLPTRH
0874  FFF7     NOP
0876  0008     TBLRD*
0878  50F5     MOVF TABLAT, W, ACCESS
087A  0A69     XORLW 0x69
087C  A4D8     BTFSS STATUS, 2, ACCESS
087E  D03F     BRA 0x8FE
826:           
827:                       ++*fmt;
0880  C047     MOVFF fmt, FSR2
0882  FFD9     NOP
0884  C048     MOVFF 0x48, FSR2H
0886  FFDA     NOP
0888  2ADE     INCF POSTINC2, F, ACCESS
088A  0E00     MOVLW 0x0
088C  22DD     ADDWFC POSTDEC2, F, ACCESS
828:                       ll = (long long)va_arg(ap, int);
088E  C049     MOVFF ap, FSR2
0890  FFD9     NOP
0892  C04A     MOVFF 0x4A, FSR2H
0894  FFDA     NOP
0896  CFDF     MOVFF INDF2, 0x4B
0898  F04B     NOP
089A  0E02     MOVLW 0x2
089C  26DE     ADDWF POSTINC2, F, ACCESS
089E  CFDF     MOVFF INDF2, 0x4C
08A0  F04C     NOP
08A2  0E00     MOVLW 0x0
08A4  22DD     ADDWFC POSTDEC2, F, ACCESS
08A6  C04B     MOVFF 0x4B, FSR2
08A8  FFD9     NOP
08AA  C04C     MOVFF 0x4C, FSR2H
08AC  FFDA     NOP
08AE  CFDE     MOVFF POSTINC2, __pcstackBANK0
08B0  F060     NOP
08B2  CFDD     MOVFF POSTDEC2, 0x61
08B4  F061     NOP
08B6  0E00     MOVLW 0x0
08B8  BF61     BTFSC 0x61, 7, BANKED
08BA  0EFF     MOVLW 0xFF
08BC  6F62     MOVWF ttemp7, BANKED
08BE  6F63     MOVWF 0x63, BANKED
08C0  6F64     MOVWF 0x64, BANKED
08C2  6F65     MOVWF 0x65, BANKED
08C4  6F66     MOVWF 0x66, BANKED
08C6  6F67     MOVWF 0x67, BANKED
829:                                   
830:                       return dtoa(fp, ll);
08C8  C045     MOVFF fp, fp
08CA  F021     NOP
08CC  C046     MOVFF 0x46, 0x22
08CE  F022     NOP
08D0  C060     MOVFF __pcstackBANK0, d
08D2  F023     NOP
08D4  C061     MOVFF 0x61, 0x24
08D6  F024     NOP
08D8  C062     MOVFF ttemp7, 0x25
08DA  F025     NOP
08DC  C063     MOVFF 0x63, 0x26
08DE  F026     NOP
08E0  C064     MOVFF 0x64, 0x27
08E2  F027     NOP
08E4  C065     MOVFF 0x65, 0x28
08E6  F028     NOP
08E8  C066     MOVFF 0x66, 0x29
08EA  F029     NOP
08EC  C067     MOVFF 0x67, 0x2A
08EE  F02A     NOP
08F0  ECE1     CALL 0x5C2, 0
08F2  F002     NOP
08F4  C021     MOVFF fp, fp
08F6  F045     NOP
08F8  C022     MOVFF 0x22, 0x46
08FA  F046     NOP
08FC  0012     RETURN 0
831:                   }
832:           
833:           #ifdef _VFPF_L
834:                   /* Long decimal integer */
835:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
836:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
837:           
838:                       *fmt += CSTRLEN("ld");
839:                       ll = (long long)va_arg(ap, long);
840:                                   
841:                       return dtoa(fp, ll);
842:                   }
843:           #endif
844:           
845:           #ifdef _VFPF_LL
846:                   /* Long long decimal integer */
847:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
848:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
849:           
850:                       *fmt += CSTRLEN("lld");
851:                       ll = va_arg(ap, long long);
852:                                   
853:                       return dtoa(fp, ll);
854:                   }
855:           #endif
856:           
857:           #ifdef _VFPF_J
858:                   /* intmax_t decimal integer */
859:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
860:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
861:           
862:                       *fmt += CSTRLEN("jd");
863:                       ll = (long long)va_arg(ap, intmax_t);
864:                                   
865:                       return dtoa(fp, ll);
866:                   }
867:           #endif
868:           
869:           #ifdef _VFPF_T
870:                   /* ptrdiff_t decimal integer */
871:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
872:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
873:           
874:                       *fmt += CSTRLEN("td");
875:                       ll = (long long)va_arg(ap, ptrdiff_t);
876:                                   
877:                       return dtoa(fp, ll);
878:                   }
879:           #endif
880:           
881:           #ifdef _VFPF_Z
882:                   /* size_t decimal integer */
883:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
884:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
885:           
886:                       *fmt += CSTRLEN("zd");
887:                       ll = (long long)va_arg(ap, size_t);
888:                                   
889:                       return dtoa(fp, ll);
890:                   }
891:           #endif
892:           #endif
893:           
894:           #ifdef _VFPF_E
895:                   /* 'e' style floating point */
896:                   if (ct[0] == 'e') {
897:           
898:                       c = (*fmt)[0];
899:                       ++*fmt;
900:                       f = (long double)va_arg(ap, double);
901:                                   
902:                       return efgtoa(fp, f, c);
903:                   }
904:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
905:           
906:                       c = (*fmt)[1];
907:                       if (isupper((int)(*fmt)[0])) {
908:                           f = va_arg(ap, long double);
909:                       } else {
910:                           f = (long double)va_arg(ap, double);
911:                       }
912:                       *fmt += CSTRLEN("lf");
913:                                   
914:                       return efgtoa(fp, f, c);
915:                   }
916:           #endif
917:           
918:           #ifdef _VFPF_F
919:                   /* 'f' style floating point */
920:                   if (ct[0] == 'f') {
921:           
922:                       c = (*fmt)[0];
923:                       ++*fmt;
924:                       f = (long double)va_arg(ap, double);
925:                                   
926:                       return efgtoa(fp, f, c);
927:                   }
928:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
929:           
930:                       c = (*fmt)[1];
931:                       if (isupper((int)(*fmt)[0])) {
932:                           f = va_arg(ap, long double);
933:                       } else {
934:                           f = (long double)va_arg(ap, double);
935:                       }
936:                       *fmt += CSTRLEN("lf");
937:                                   
938:                       return efgtoa(fp, f, c);
939:                   }
940:           #endif
941:           
942:           #ifdef _VFPF_G
943:                   /* 'g' style floating point */
944:                   if (ct[0] == 'g') {
945:           
946:                       c = (*fmt)[0];
947:                       ++*fmt;
948:                       f = (long double)va_arg(ap, double);
949:                                   
950:                       return efgtoa(fp, f, c);
951:                   }
952:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
953:           
954:                       c = (*fmt)[1];
955:                       if (isupper((int)(*fmt)[0])) {
956:                           f = va_arg(ap, long double);
957:                       } else {
958:                           f = (long double)va_arg(ap, double);
959:                       }
960:                       *fmt += CSTRLEN("lg");
961:                                   
962:                       return efgtoa(fp, f, c);
963:                   }
964:           #endif
965:           
966:           #ifdef _VFPF_O
967:           #ifdef _VFPF_HH
968:                   /* Character octal integer */
969:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
970:           
971:                       *fmt += CSTRLEN("hho");
972:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
973:                                   
974:                       return otoa(fp, llu);
975:                   }
976:           #endif
977:           
978:           #ifdef _VFPF_H
979:                   /* Short octal integer */
980:                   if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
981:           
982:                       *fmt += CSTRLEN("ho");
983:                       llu = (unsigned long long)(unsigned short)va_arg(ap, int);
984:                                   
985:                       return otoa(fp, llu);
986:                   }
987:           #endif
988:           
989:                   /* Octal integer */
990:                   if (*fmt[0] == 'o') {
991:           
992:                       ++*fmt;
993:                       llu = (unsigned long long)va_arg(ap, unsigned int);
994:                                   
995:                       return otoa(fp, llu);
996:                   }
997:           
998:           #ifdef _VFPF_L
999:                   /* Long octal integer */
1000:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1001:          
1002:                      *fmt += CSTRLEN("lo");
1003:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1004:                                  
1005:                      return otoa(fp, llu);
1006:                  }
1007:          #endif
1008:          
1009:          #ifdef _VFPF_LL
1010:                  /* Long long octal integer */
1011:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1012:          
1013:                      *fmt += CSTRLEN("llo");
1014:                      llu = va_arg(ap, unsigned long long);
1015:                                  
1016:                      return otoa(fp, llu);
1017:                  }
1018:          #endif
1019:          
1020:          #ifdef _VFPF_J
1021:                  /* uintmax_t octal integer */
1022:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1023:          
1024:                      *fmt += CSTRLEN("jo");
1025:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_T
1032:                  /* ptrdiff_t octal integer */
1033:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1034:          
1035:                      *fmt += CSTRLEN("to");
1036:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_Z
1043:                  /* size_t octal integer */
1044:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1045:          
1046:                      *fmt += CSTRLEN("zo");
1047:                      llu = (unsigned long long)va_arg(ap, size_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          #endif
1053:          
1054:                  /* Character count */
1055:          #ifdef _VFPF_N
1056:          
1057:          #ifdef _VFPF_HH
1058:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1059:          
1060:                      *fmt += CSTRLEN("hhn");
1061:                      vp = (void *)va_arg(ap, char *);
1062:                      *(char *)vp = (char)nout;
1063:                      return 0;
1064:                  }
1065:          #endif
1066:          
1067:          #ifdef _VFPF_H
1068:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1069:          
1070:                      *fmt += CSTRLEN("hn");
1071:                      vp = (void *)va_arg(ap, short *);
1072:                      *(short *)vp = (short)nout;
1073:                      return 0;
1074:                  }
1075:          #endif
1076:          
1077:                  if (*fmt[0] == 'n') {
1078:                      ++*fmt;
1079:                      vp = (void *)va_arg(ap, int *);
1080:                      *(int *)vp = nout;
1081:                      return 0;
1082:                  }
1083:          
1084:          #ifdef _VFPF_L
1085:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1086:          
1087:                      *fmt += CSTRLEN("ln");
1088:                      vp = (void *)va_arg(ap, long *);
1089:                      *(long *)vp = (long)nout;
1090:                      return 0;
1091:                  }
1092:          #endif
1093:          
1094:          #ifdef _VFPF_LL
1095:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1096:          
1097:                      *fmt += CSTRLEN("lln");
1098:                      vp = (void *)va_arg(ap, long long *);
1099:                      *(long long *)vp = (long long)nout;
1100:                      return 0;
1101:                  }
1102:          #endif
1103:          
1104:          #ifdef _VFPF_J
1105:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1106:          
1107:                      *fmt += CSTRLEN("jn");
1108:                      vp = (void *)va_arg(ap, uintmax_t *);
1109:                      *(uintmax_t *)vp = (uintmax_t)nout;
1110:                      return 0;
1111:                  }
1112:          #endif
1113:          
1114:          #ifdef _VFPF_T
1115:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1116:          
1117:                      *fmt += CSTRLEN("tn");
1118:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1119:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1120:                      return 0;
1121:                  }
1122:          #endif
1123:          
1124:          #ifdef _VFPF_Z
1125:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1126:          
1127:                      *fmt += CSTRLEN("zn");
1128:                      vp = (void *)va_arg(ap, size_t *);
1129:                      *(size_t *)vp = (size_t)nout;
1130:                      return 0;
1131:                  }
1132:          #endif
1133:          
1134:          #endif
1135:          
1136:          #ifdef _VFPF_P
1137:                  /* Pointer */
1138:                  if (*fmt[0] == 'p') {
1139:          
1140:                      ++*fmt;
1141:                      llu = (unsigned long long)(size_t)va_arg(ap, void *);
1142:                                  
1143:                      return xtoa(fp, llu, 'x');
1144:                  }
1145:          #endif
1146:          
1147:          #ifdef _VFPF_S
1148:                  /* String */
1149:                  if (*fmt[0] == 's') {
1150:          
1151:                      ++*fmt;
1152:                      cp = va_arg(ap, char *);
1153:          
1154:                      return stoa(fp, cp);
1155:                  }
1156:          #endif
1157:          
1158:          #ifdef _VFPF_U
1159:          #ifdef _VFPF_HH
1160:                  /* Unsigned character decimal integer */
1161:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1162:          
1163:                      *fmt += CSTRLEN("hhu");
1164:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1165:                                  
1166:                      return utoa(fp, llu);
1167:                  }
1168:          #endif
1169:          
1170:          #ifdef _VFPF_H
1171:                  /* Unsigned short decimal integer */
1172:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1173:          
1174:                      *fmt += CSTRLEN("hu");
1175:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1176:                                  
1177:                      return utoa(fp, llu);
1178:                  }
1179:          #endif
1180:          
1181:                  /* Unsigned decimal integer */
1182:                  if (*fmt[0] == 'u') {
08FE  C047     MOVFF fmt, FSR2
0900  FFD9     NOP
0902  C048     MOVFF 0x48, FSR2H
0904  FFDA     NOP
0906  CFDE     MOVFF POSTINC2, TBLPTR
0908  FFF6     NOP
090A  CFDD     MOVFF POSTDEC2, TBLPTRH
090C  FFF7     NOP
090E  0008     TBLRD*
0910  50F5     MOVF TABLAT, W, ACCESS
0912  0A75     XORLW 0x75
0914  A4D8     BTFSS STATUS, 2, ACCESS
0916  D041     BRA 0x99A
1183:          
1184:                      ++*fmt;
0918  C047     MOVFF fmt, FSR2
091A  FFD9     NOP
091C  C048     MOVFF 0x48, FSR2H
091E  FFDA     NOP
0920  2ADE     INCF POSTINC2, F, ACCESS
0922  0E00     MOVLW 0x0
0924  22DD     ADDWFC POSTDEC2, F, ACCESS
1185:                      llu = (unsigned long long)va_arg(ap, unsigned int);
0926  C049     MOVFF ap, FSR2
0928  FFD9     NOP
092A  C04A     MOVFF 0x4A, FSR2H
092C  FFDA     NOP
092E  CFDF     MOVFF INDF2, 0x4B
0930  F04B     NOP
0932  0E02     MOVLW 0x2
0934  26DE     ADDWF POSTINC2, F, ACCESS
0936  CFDF     MOVFF INDF2, 0x4C
0938  F04C     NOP
093A  0E00     MOVLW 0x0
093C  22DD     ADDWFC POSTDEC2, F, ACCESS
093E  C04B     MOVFF 0x4B, FSR2
0940  FFD9     NOP
0942  C04C     MOVFF 0x4C, FSR2H
0944  FFDA     NOP
0946  CFDE     MOVFF POSTINC2, 0x4D
0948  F04D     NOP
094A  CFDD     MOVFF POSTDEC2, 0x4E
094C  F04E     NOP
094E  C04D     MOVFF 0x4D, llu
0950  F068     NOP
0952  C04E     MOVFF 0x4E, 0x69
0954  F069     NOP
0956  0100     MOVLB 0x0
0958  6B6A     CLRF 0x6A, BANKED
095A  6B6B     CLRF 0x6B, BANKED
095C  6B6C     CLRF 0x6C, BANKED
095E  6B6D     CLRF 0x6D, BANKED
0960  6B6E     CLRF 0x6E, BANKED
0962  6B6F     CLRF 0x6F, BANKED
1186:                                  
1187:                      return utoa(fp, llu);
0964  C045     MOVFF fp, fp
0966  F021     NOP
0968  C046     MOVFF 0x46, 0x22
096A  F022     NOP
096C  C068     MOVFF llu, d
096E  F023     NOP
0970  C069     MOVFF 0x69, 0x24
0972  F024     NOP
0974  C06A     MOVFF 0x6A, 0x25
0976  F025     NOP
0978  C06B     MOVFF 0x6B, 0x26
097A  F026     NOP
097C  C06C     MOVFF 0x6C, 0x27
097E  F027     NOP
0980  C06D     MOVFF 0x6D, 0x28
0982  F028     NOP
0984  C06E     MOVFF 0x6E, 0x29
0986  F029     NOP
0988  C06F     MOVFF 0x6F, 0x2A
098A  F02A     NOP
098C  EC1A     CALL 0xA34, 0
098E  F005     NOP
0990  C021     MOVFF fp, fp
0992  F045     NOP
0994  C022     MOVFF 0x22, 0x46
0996  F046     NOP
0998  0012     RETURN 0
1188:                  }
1189:          
1190:          #ifdef _VFPF_L
1191:                  /* Unsigned long decimal integer */
1192:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1193:          
1194:                      *fmt += CSTRLEN("lu");
1195:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1196:                                  
1197:                      return utoa(fp, llu);
1198:                  }
1199:          #endif
1200:          
1201:          #ifdef _VFPF_LL
1202:                  /* Unsigned long long decimal integer */
1203:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1204:          
1205:                      *fmt += CSTRLEN("llu");
1206:                      llu = va_arg(ap, unsigned long long);
1207:                                  
1208:                      return utoa(fp, llu);
1209:                  }
1210:          #endif
1211:          
1212:          #ifdef _VFPF_J
1213:                  /* uintmax_t decimal integer */
1214:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1215:          
1216:                      *fmt += CSTRLEN("ju");
1217:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_T
1224:                  /* ptrdiff_t decimal integer */
1225:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1226:          
1227:                      *fmt += CSTRLEN("tu");
1228:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_Z
1235:                  /* size_t decimal integer */
1236:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1237:          
1238:                      *fmt += CSTRLEN("zu");
1239:                      llu = (unsigned long long)va_arg(ap, size_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          #endif
1245:          
1246:          #ifdef _VFPF_X
1247:          #ifdef _VFPF_HH
1248:                  /* Character hexadecimal integer */
1249:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1250:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1251:          
1252:                      c = (*fmt)[2];
1253:                      *fmt += CSTRLEN("hhx");
1254:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1255:                                  
1256:                      return xtoa(fp, llu, c);
1257:                  }
1258:          #endif
1259:          
1260:          #ifdef _VFPF_H
1261:                  /* Short hexadecimal integer */
1262:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1263:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1264:          
1265:                      c = (*fmt)[1];
1266:                      *fmt += CSTRLEN("hx");
1267:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1268:                                  
1269:                      return xtoa(fp, llu, c);
1270:                  }
1271:          #endif
1272:          
1273:                  /* Hexadecimal integer */
1274:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1275:          
1276:                      c = (*fmt)[0];
1277:                      ++*fmt;
1278:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1279:                                  
1280:                      return xtoa(fp, llu, c);
1281:                  }
1282:          
1283:          #ifdef _VFPF_L
1284:                  /* Long hexadecimal integer */
1285:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1286:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1287:          
1288:                      c = (*fmt)[1];
1289:                      *fmt += CSTRLEN("lx");
1290:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1291:                                  
1292:                      return xtoa(fp, llu, c);
1293:                  }
1294:          #endif
1295:          
1296:          #ifdef _VFPF_LL
1297:                  /* Long long hexadecimal integer */
1298:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1299:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1300:          
1301:                      c = (*fmt)[2];
1302:                      *fmt += CSTRLEN("llx");
1303:                      llu = va_arg(ap, unsigned long long);
1304:                                  
1305:                      return xtoa(fp, llu, c);
1306:                  }
1307:          #endif
1308:          
1309:          #ifdef _VFPF_J
1310:                  /* uintmax_t hexadecimal integer */
1311:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1312:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1313:          
1314:                      c = (*fmt)[1];
1315:                      *fmt += CSTRLEN("jx");
1316:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1317:                                  
1318:                      return xtoa(fp, llu, c);
1319:                  }
1320:          #endif
1321:          
1322:          #ifdef _VFPF_T
1323:                  /* ptrdiff_t hexadecimal integer */
1324:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1325:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1326:          
1327:                      c = (*fmt)[1];
1328:                      *fmt += CSTRLEN("tx");
1329:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1330:                                  
1331:                      return xtoa(fp, llu, c);
1332:                  }
1333:          #endif
1334:          
1335:          #ifdef _VFPF_Z
1336:                  /* size_t hexadecimal integer */
1337:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1338:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1339:          
1340:                      c = (*fmt)[1];
1341:                      *fmt += CSTRLEN("zx");
1342:                      llu = (unsigned long long)va_arg(ap, size_t);
1343:                                  
1344:                      return xtoa(fp, llu, c);
1345:                  }
1346:          #endif
1347:          #endif
1348:          
1349:                  /* 'Escaped' '%' character */
1350:                  if ((*fmt)[0] == '%') {
099A  C047     MOVFF fmt, FSR2
099C  FFD9     NOP
099E  C048     MOVFF 0x48, FSR2H
09A0  FFDA     NOP
09A2  CFDE     MOVFF POSTINC2, TBLPTR
09A4  FFF6     NOP
09A6  CFDD     MOVFF POSTDEC2, TBLPTRH
09A8  FFF7     NOP
09AA  0008     TBLRD*
09AC  50F5     MOVF TABLAT, W, ACCESS
09AE  0A25     XORLW 0x25
09B0  A4D8     BTFSS STATUS, 2, ACCESS
09B2  D016     BRA 0x9E0
1351:                      ++*fmt;
09B4  C047     MOVFF fmt, FSR2
09B6  FFD9     NOP
09B8  C048     MOVFF 0x48, FSR2H
09BA  FFDA     NOP
09BC  2ADE     INCF POSTINC2, F, ACCESS
09BE  0E00     MOVLW 0x0
09C0  22DD     ADDWFC POSTDEC2, F, ACCESS
1352:                      fputc((int)'%', fp);
09C2  0E00     MOVLW 0x0
09C4  6E07     MOVWF number, ACCESS
09C6  0E25     MOVLW 0x25
09C8  6E06     MOVWF Values, ACCESS
09CA  C045     MOVFF fp, type
09CC  F008     NOP
09CE  C046     MOVFF 0x46, Byte
09D0  F009     NOP
09D2  ECE1     CALL 0x13C2, 0
09D4  F009     NOP
1353:                      return 1;
09D6  0E00     MOVLW 0x0
09D8  6E46     MOVWF 0x46, ACCESS
09DA  0E01     MOVLW 0x1
09DC  6E45     MOVWF fp, ACCESS
09DE  0012     RETURN 0
1354:                  }
1355:          
1356:                  /* Unrecognized conversion */
1357:                  ++*fmt;
09E0  C047     MOVFF fmt, FSR2
09E2  FFD9     NOP
09E4  C048     MOVFF 0x48, FSR2H
09E6  FFDA     NOP
09E8  2ADE     INCF POSTINC2, F, ACCESS
09EA  0E00     MOVLW 0x0
09EC  22DD     ADDWFC POSTDEC2, F, ACCESS
1358:                  return 0;
09EE  0E00     MOVLW 0x0
09F0  6E46     MOVWF 0x46, ACCESS
09F2  0E00     MOVLW 0x0
09F4  6E45     MOVWF fp, ACCESS
09F6  0012     RETURN 0
1359:              }
1360:          
1361:              /* No conversion, just intervening text */
1362:              fputc((int)(*fmt)[0], fp);
09F8  C047     MOVFF fmt, FSR2
09FA  FFD9     NOP
09FC  C048     MOVFF 0x48, FSR2H
09FE  FFDA     NOP
0A00  CFDE     MOVFF POSTINC2, TBLPTR
0A02  FFF6     NOP
0A04  CFDD     MOVFF POSTDEC2, TBLPTRH
0A06  FFF7     NOP
0A08  0008     TBLRD*
0A0A  50F5     MOVF TABLAT, W, ACCESS
0A0C  6E06     MOVWF Values, ACCESS
0A0E  6A07     CLRF number, ACCESS
0A10  C045     MOVFF fp, type
0A12  F008     NOP
0A14  C046     MOVFF 0x46, Byte
0A16  F009     NOP
0A18  ECE1     CALL 0x13C2, 0
0A1A  F009     NOP
1363:              ++*fmt;
0A1C  C047     MOVFF fmt, FSR2
0A1E  FFD9     NOP
0A20  C048     MOVFF 0x48, FSR2H
0A22  FFDA     NOP
0A24  2ADE     INCF POSTINC2, F, ACCESS
0A26  0E00     MOVLW 0x0
0A28  22DD     ADDWFC POSTDEC2, F, ACCESS
1364:              return 1;
0A2A  0E00     MOVLW 0x0
0A2C  6E46     MOVWF 0x46, ACCESS
0A2E  0E01     MOVLW 0x1
0A30  6E45     MOVWF fp, ACCESS
0A32  0012     RETURN 0
1365:          }
1366:          #endif
1367:          
1368:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1369:          {
1370:          #ifdef _VFPF_CONVERT
1371:              char *cfmt;
1372:          
1373:              cfmt = (char *)fmt;
1998  C051     MOVFF fmt, cfmt
199A  F070     NOP
199C  C052     MOVFF 0x52, 0x71
199E  F071     NOP
1374:              nout = 0;
19A0  0E00     MOVLW 0x0
19A2  0100     MOVLB 0x0
19A4  6FBB     MOVWF 0xBB, BANKED
19A6  0E00     MOVLW 0x0
19A8  6FBA     MOVWF nout, BANKED
1375:              while (*cfmt) {
19AA  D013     BRA 0x19D2
1376:                  nout += vfpfcnvrt(fp, &cfmt, ap);
19AC  C04F     MOVFF fp, fp
19AE  F045     NOP
19B0  C050     MOVFF 0x50, 0x46
19B2  F046     NOP
19B4  0E70     MOVLW 0x70
19B6  6E47     MOVWF fmt, ACCESS
19B8  0E00     MOVLW 0x0
19BA  6E48     MOVWF 0x48, ACCESS
19BC  C053     MOVFF ap, ap
19BE  F049     NOP
19C0  C054     MOVFF 0x54, 0x4A
19C2  F04A     NOP
19C4  EC07     CALL 0x80E, 0
19C6  F004     NOP
19C8  5045     MOVF fp, W, ACCESS
19CA  0100     MOVLB 0x0
19CC  27BA     ADDWF nout, F, BANKED
19CE  5046     MOVF 0x46, W, ACCESS
19D0  23BB     ADDWFC 0xBB, F, BANKED
1377:              }
19D2  C070     MOVFF cfmt, TBLPTR
19D4  FFF6     NOP
19D6  C071     MOVFF 0x71, TBLPTRH
19D8  FFF7     NOP
19DA  0008     TBLRD*
19DC  50F5     MOVF TABLAT, W, ACCESS
19DE  0900     IORLW 0x0
19E0  A4D8     BTFSS STATUS, 2, ACCESS
19E2  D7E4     BRA 0x19AC
1378:              return nout;
19E4  C0BA     MOVFF nout, fp
19E6  F04F     NOP
19E8  C0BB     MOVFF 0xBB, 0x50
19EA  F050     NOP
1379:          #else
1380:              return fputs(fmt, fp);
1381:          #endif
1382:          }
19EC  0012     RETURN 0
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/awdiv.c  ----------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awdiv(signed int divisor, signed int dividend)
6:             #else
7:             __awdiv(signed int dividend, signed int divisor)
8:             #endif
9:             {
10:            	signed int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
1750  0E00     MOVLW 0x0
1752  6E11     MOVWF fp, ACCESS
14:            	if(divisor < 0) {
1754  AE0F     BTFSS s, 7, ACCESS
1756  D006     BRA 0x1764
15:            		divisor = -divisor;
1758  6C0E     NEGF divisor, ACCESS
175A  1E0F     COMF s, F, ACCESS
175C  B0D8     BTFSC STATUS, 0, ACCESS
175E  2A0F     INCF s, F, ACCESS
16:            		sign = 1;
1760  0E01     MOVLW 0x1
1762  6E11     MOVWF fp, ACCESS
17:            	}
18:            	if(dividend < 0) {
1764  AE0D     BTFSS dis, 7, ACCESS
1766  D006     BRA 0x1774
19:            		dividend = -dividend;
1768  6C0C     NEGF dividend, ACCESS
176A  1E0D     COMF dis, F, ACCESS
176C  B0D8     BTFSC STATUS, 0, ACCESS
176E  2A0D     INCF dis, F, ACCESS
20:            		sign ^= 1;
1770  0E01     MOVLW 0x1
1772  1A11     XORWF fp, F, ACCESS
21:            	}
22:            	quotient = 0;
1774  0E00     MOVLW 0x0
1776  6E13     MOVWF c, ACCESS
1778  0E00     MOVLW 0x0
177A  6E12     MOVWF quotient, ACCESS
23:            	if(divisor != 0) {
177C  500E     MOVF divisor, W, ACCESS
177E  100F     IORWF s, W, ACCESS
1780  B4D8     BTFSC STATUS, 2, ACCESS
1782  D01C     BRA 0x17BC
24:            		counter = 1;
1784  0E01     MOVLW 0x1
1786  6E10     MOVWF counter, ACCESS
25:            		while((divisor & 0x8000U) == 0) {
1788  D004     BRA 0x1792
26:            			divisor <<= 1;
178A  90D8     BCF STATUS, 0, ACCESS
178C  360E     RLCF divisor, F, ACCESS
178E  360F     RLCF s, F, ACCESS
27:            			counter++;
1790  2A10     INCF counter, F, ACCESS
28:            		}
1792  AE0F     BTFSS s, 7, ACCESS
1794  D7FA     BRA 0x178A
29:            		do {
30:            			quotient <<= 1;
1796  90D8     BCF STATUS, 0, ACCESS
1798  3612     RLCF quotient, F, ACCESS
179A  3613     RLCF c, F, ACCESS
31:            			if((unsigned int)divisor <= (unsigned int)dividend) {
179C  500E     MOVF divisor, W, ACCESS
179E  5C0C     SUBWF dividend, W, ACCESS
17A0  500F     MOVF s, W, ACCESS
17A2  580D     SUBWFB dis, W, ACCESS
17A4  A0D8     BTFSS STATUS, 0, ACCESS
17A6  D005     BRA 0x17B2
32:            				dividend -= divisor;
17A8  500E     MOVF divisor, W, ACCESS
17AA  5E0C     SUBWF dividend, F, ACCESS
17AC  500F     MOVF s, W, ACCESS
17AE  5A0D     SUBWFB dis, F, ACCESS
33:            				quotient |= 1;
17B0  8012     BSF quotient, 0, ACCESS
34:            			}
35:            			*(unsigned int *)&divisor >>= 1;
17B2  90D8     BCF STATUS, 0, ACCESS
17B4  320F     RRCF s, F, ACCESS
17B6  320E     RRCF divisor, F, ACCESS
36:            		} while(--counter != 0);
17B8  2E10     DECFSZ counter, F, ACCESS
17BA  D7ED     BRA 0x1796
37:            	}
38:            	if(sign)
17BC  5011     MOVF fp, W, ACCESS
17BE  B4D8     BTFSC STATUS, 2, ACCESS
17C0  D004     BRA 0x17CA
39:            		quotient = -quotient;
17C2  6C12     NEGF quotient, ACCESS
17C4  1E13     COMF c, F, ACCESS
17C6  B0D8     BTFSC STATUS, 0, ACCESS
17C8  2A13     INCF c, F, ACCESS
40:            	return quotient;
17CA  C012     MOVFF quotient, dividend
17CC  F00C     NOP
17CE  C013     MOVFF c, dis
17D0  F00D     NOP
17D2  0012     RETURN 0
41:            }
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/aomod.c  ----------------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
0EB6  0E00     MOVLW 0x0
0EB8  6E17     MOVWF sign, ACCESS
15:            	if(dividend < 0) {
0EBA  AE0D     BTFSS dis, 7, ACCESS
0EBC  D012     BRA 0xEE2
16:            		dividend = -dividend;
0EBE  1E0D     COMF dis, F, ACCESS
0EC0  1E0C     COMF dividend, F, ACCESS
0EC2  1E0B     COMF pa, F, ACCESS
0EC4  1E0A     COMF string, F, ACCESS
0EC6  1E09     COMF Byte, F, ACCESS
0EC8  1E08     COMF type, F, ACCESS
0ECA  1E07     COMF number, F, ACCESS
0ECC  6C06     NEGF Values, ACCESS
0ECE  0E00     MOVLW 0x0
0ED0  2207     ADDWFC number, F, ACCESS
0ED2  2208     ADDWFC type, F, ACCESS
0ED4  2209     ADDWFC Byte, F, ACCESS
0ED6  220A     ADDWFC string, F, ACCESS
0ED8  220B     ADDWFC pa, F, ACCESS
0EDA  220C     ADDWFC dividend, F, ACCESS
0EDC  220D     ADDWFC dis, F, ACCESS
17:            		sign = 1;
0EDE  0E01     MOVLW 0x1
0EE0  6E17     MOVWF sign, ACCESS
18:            	}
19:            	if(divisor < 0)
0EE2  AE15     BTFSS 0x15, 7, ACCESS
0EE4  D010     BRA 0xF06
20:            		divisor = -divisor;
0EE6  1E15     COMF 0x15, F, ACCESS
0EE8  1E14     COMF i, F, ACCESS
0EEA  1E13     COMF c, F, ACCESS
0EEC  1E12     COMF quotient, F, ACCESS
0EEE  1E11     COMF fp, F, ACCESS
0EF0  1E10     COMF counter, F, ACCESS
0EF2  1E0F     COMF s, F, ACCESS
0EF4  6C0E     NEGF divisor, ACCESS
0EF6  0E00     MOVLW 0x0
0EF8  220F     ADDWFC s, F, ACCESS
0EFA  2210     ADDWFC counter, F, ACCESS
0EFC  2211     ADDWFC fp, F, ACCESS
0EFE  2212     ADDWFC quotient, F, ACCESS
0F00  2213     ADDWFC c, F, ACCESS
0F02  2214     ADDWFC i, F, ACCESS
0F04  2215     ADDWFC 0x15, F, ACCESS
21:            	if(divisor != 0) {
0F06  500E     MOVF divisor, W, ACCESS
0F08  100F     IORWF s, W, ACCESS
0F0A  1010     IORWF counter, W, ACCESS
0F0C  1011     IORWF fp, W, ACCESS
0F0E  1012     IORWF quotient, W, ACCESS
0F10  1013     IORWF c, W, ACCESS
0F12  1014     IORWF i, W, ACCESS
0F14  1015     IORWF 0x15, W, ACCESS
0F16  B4D8     BTFSC STATUS, 2, ACCESS
0F18  D03C     BRA 0xF92
22:            		counter = 1;
0F1A  0E01     MOVLW 0x1
0F1C  6E16     MOVWF fp, ACCESS
23:            		while((divisor & 0x8000000000000000ULL) == 0) {
0F1E  D00A     BRA 0xF34
24:            			divisor <<= 1;
0F20  90D8     BCF STATUS, 0, ACCESS
0F22  360E     RLCF divisor, F, ACCESS
0F24  360F     RLCF s, F, ACCESS
0F26  3610     RLCF counter, F, ACCESS
0F28  3611     RLCF fp, F, ACCESS
0F2A  3612     RLCF quotient, F, ACCESS
0F2C  3613     RLCF c, F, ACCESS
0F2E  3614     RLCF i, F, ACCESS
0F30  3615     RLCF 0x15, F, ACCESS
25:            			counter++;
0F32  2A16     INCF fp, F, ACCESS
26:            		}
0F34  AE15     BTFSS 0x15, 7, ACCESS
0F36  D7F4     BRA 0xF20
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
0F38  500E     MOVF divisor, W, ACCESS
0F3A  5C06     SUBWF Values, W, ACCESS
0F3C  500F     MOVF s, W, ACCESS
0F3E  5807     SUBWFB number, W, ACCESS
0F40  5010     MOVF counter, W, ACCESS
0F42  5808     SUBWFB type, W, ACCESS
0F44  5011     MOVF fp, W, ACCESS
0F46  5809     SUBWFB Byte, W, ACCESS
0F48  5012     MOVF quotient, W, ACCESS
0F4A  580A     SUBWFB string, W, ACCESS
0F4C  5013     MOVF c, W, ACCESS
0F4E  580B     SUBWFB pa, W, ACCESS
0F50  5014     MOVF i, W, ACCESS
0F52  580C     SUBWFB dividend, W, ACCESS
0F54  5015     MOVF 0x15, W, ACCESS
0F56  580D     SUBWFB dis, W, ACCESS
0F58  A0D8     BTFSS STATUS, 0, ACCESS
0F5A  D010     BRA 0xF7C
29:            				dividend -= divisor;
0F5C  500E     MOVF divisor, W, ACCESS
0F5E  5E06     SUBWF Values, F, ACCESS
0F60  500F     MOVF s, W, ACCESS
0F62  5A07     SUBWFB number, F, ACCESS
0F64  5010     MOVF counter, W, ACCESS
0F66  5A08     SUBWFB type, F, ACCESS
0F68  5011     MOVF fp, W, ACCESS
0F6A  5A09     SUBWFB Byte, F, ACCESS
0F6C  5012     MOVF quotient, W, ACCESS
0F6E  5A0A     SUBWFB string, F, ACCESS
0F70  5013     MOVF c, W, ACCESS
0F72  5A0B     SUBWFB pa, F, ACCESS
0F74  5014     MOVF i, W, ACCESS
0F76  5A0C     SUBWFB dividend, F, ACCESS
0F78  5015     MOVF 0x15, W, ACCESS
0F7A  5A0D     SUBWFB dis, F, ACCESS
30:            			*(unsigned long long int *)&divisor >>= 1;
0F7C  90D8     BCF STATUS, 0, ACCESS
0F7E  3215     RRCF 0x15, F, ACCESS
0F80  3214     RRCF i, F, ACCESS
0F82  3213     RRCF c, F, ACCESS
0F84  3212     RRCF quotient, F, ACCESS
0F86  3211     RRCF fp, F, ACCESS
0F88  3210     RRCF counter, F, ACCESS
0F8A  320F     RRCF s, F, ACCESS
0F8C  320E     RRCF divisor, F, ACCESS
31:            		} while(--counter != 0);
0F8E  2E16     DECFSZ fp, F, ACCESS
0F90  D7D3     BRA 0xF38
32:            	}
33:            	if(sign)
0F92  5017     MOVF sign, W, ACCESS
0F94  B4D8     BTFSC STATUS, 2, ACCESS
0F96  D010     BRA 0xFB8
34:            		dividend = -dividend;
0F98  1E0D     COMF dis, F, ACCESS
0F9A  1E0C     COMF dividend, F, ACCESS
0F9C  1E0B     COMF pa, F, ACCESS
0F9E  1E0A     COMF string, F, ACCESS
0FA0  1E09     COMF Byte, F, ACCESS
0FA2  1E08     COMF type, F, ACCESS
0FA4  1E07     COMF number, F, ACCESS
0FA6  6C06     NEGF Values, ACCESS
0FA8  0E00     MOVLW 0x0
0FAA  2207     ADDWFC number, F, ACCESS
0FAC  2208     ADDWFC type, F, ACCESS
0FAE  2209     ADDWFC Byte, F, ACCESS
0FB0  220A     ADDWFC string, F, ACCESS
0FB2  220B     ADDWFC pa, F, ACCESS
0FB4  220C     ADDWFC dividend, F, ACCESS
0FB6  220D     ADDWFC dis, F, ACCESS
35:            	return dividend;
0FB8  C006     MOVFF Values, Values
0FBA  F006     NOP
0FBC  C007     MOVFF number, number
0FBE  F007     NOP
0FC0  C008     MOVFF type, type
0FC2  F008     NOP
0FC4  C009     MOVFF Byte, Byte
0FC6  F009     NOP
0FC8  C00A     MOVFF string, string
0FCA  F00A     NOP
0FCC  C00B     MOVFF pa, pa
0FCE  F00B     NOP
0FD0  C00C     MOVFF dividend, dividend
0FD2  F00C     NOP
0FD4  C00D     MOVFF dis, dis
0FD6  F00D     NOP
0FD8  0012     RETURN 0
36:            }
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/aodiv.c  ----------------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
0D6E  0E00     MOVLW 0x0
0D70  6E17     MOVWF sign, ACCESS
16:            	if(divisor < 0) {
0D72  AE15     BTFSS 0x15, 7, ACCESS
0D74  D012     BRA 0xD9A
17:            		divisor = -divisor;
0D76  1E15     COMF 0x15, F, ACCESS
0D78  1E14     COMF i, F, ACCESS
0D7A  1E13     COMF c, F, ACCESS
0D7C  1E12     COMF quotient, F, ACCESS
0D7E  1E11     COMF fp, F, ACCESS
0D80  1E10     COMF counter, F, ACCESS
0D82  1E0F     COMF s, F, ACCESS
0D84  6C0E     NEGF divisor, ACCESS
0D86  0E00     MOVLW 0x0
0D88  220F     ADDWFC s, F, ACCESS
0D8A  2210     ADDWFC counter, F, ACCESS
0D8C  2211     ADDWFC fp, F, ACCESS
0D8E  2212     ADDWFC quotient, F, ACCESS
0D90  2213     ADDWFC c, F, ACCESS
0D92  2214     ADDWFC i, F, ACCESS
0D94  2215     ADDWFC 0x15, F, ACCESS
18:            		sign = 1;
0D96  0E01     MOVLW 0x1
0D98  6E17     MOVWF sign, ACCESS
19:            	}
20:            	if(dividend < 0) {
0D9A  AE0D     BTFSS dis, 7, ACCESS
0D9C  D012     BRA 0xDC2
21:            		dividend = -dividend;
0D9E  1E0D     COMF dis, F, ACCESS
0DA0  1E0C     COMF dividend, F, ACCESS
0DA2  1E0B     COMF pa, F, ACCESS
0DA4  1E0A     COMF string, F, ACCESS
0DA6  1E09     COMF Byte, F, ACCESS
0DA8  1E08     COMF type, F, ACCESS
0DAA  1E07     COMF number, F, ACCESS
0DAC  6C06     NEGF Values, ACCESS
0DAE  0E00     MOVLW 0x0
0DB0  2207     ADDWFC number, F, ACCESS
0DB2  2208     ADDWFC type, F, ACCESS
0DB4  2209     ADDWFC Byte, F, ACCESS
0DB6  220A     ADDWFC string, F, ACCESS
0DB8  220B     ADDWFC pa, F, ACCESS
0DBA  220C     ADDWFC dividend, F, ACCESS
0DBC  220D     ADDWFC dis, F, ACCESS
22:            		sign ^= 1;
0DBE  0E01     MOVLW 0x1
0DC0  1A17     XORWF sign, F, ACCESS
23:            	}
24:            	quotient = 0;
0DC2  EE20     LFSR 2, 0x18
0DC4  F018     NOP
0DC6  0E07     MOVLW 0x7
0DC8  6ADE     CLRF POSTINC2, ACCESS
0DCA  06E8     DECF WREG, F, ACCESS
0DCC  E2FD     BC 0xDC8
25:            	if(divisor != 0) {
0DCE  500E     MOVF divisor, W, ACCESS
0DD0  100F     IORWF s, W, ACCESS
0DD2  1010     IORWF counter, W, ACCESS
0DD4  1011     IORWF fp, W, ACCESS
0DD6  1012     IORWF quotient, W, ACCESS
0DD8  1013     IORWF c, W, ACCESS
0DDA  1014     IORWF i, W, ACCESS
0DDC  1015     IORWF 0x15, W, ACCESS
0DDE  B4D8     BTFSC STATUS, 2, ACCESS
0DE0  D046     BRA 0xE6E
26:            		counter = 1;
0DE2  0E01     MOVLW 0x1
0DE4  6E16     MOVWF fp, ACCESS
27:            		while((divisor & 0x8000000000000000ULL) == 0) {
0DE6  D00A     BRA 0xDFC
28:            			divisor <<= 1;
0DE8  90D8     BCF STATUS, 0, ACCESS
0DEA  360E     RLCF divisor, F, ACCESS
0DEC  360F     RLCF s, F, ACCESS
0DEE  3610     RLCF counter, F, ACCESS
0DF0  3611     RLCF fp, F, ACCESS
0DF2  3612     RLCF quotient, F, ACCESS
0DF4  3613     RLCF c, F, ACCESS
0DF6  3614     RLCF i, F, ACCESS
0DF8  3615     RLCF 0x15, F, ACCESS
29:            			counter++;
0DFA  2A16     INCF fp, F, ACCESS
30:            		}
0DFC  AE15     BTFSS 0x15, 7, ACCESS
0DFE  D7F4     BRA 0xDE8
31:            		do {
32:            			quotient <<= 1;
0E00  90D8     BCF STATUS, 0, ACCESS
0E02  3618     RLCF buf, F, ACCESS
0E04  3619     RLCF PWMduty, F, ACCESS
0E06  361A     RLCF p, F, ACCESS
0E08  361B     RLCF mL, F, ACCESS
0E0A  361C     RLCF 0x1C, F, ACCESS
0E0C  361D     RLCF i, F, ACCESS
0E0E  361E     RLCF counter, F, ACCESS
0E10  361F     RLCF w, F, ACCESS
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
0E12  500E     MOVF divisor, W, ACCESS
0E14  5C06     SUBWF Values, W, ACCESS
0E16  500F     MOVF s, W, ACCESS
0E18  5807     SUBWFB number, W, ACCESS
0E1A  5010     MOVF counter, W, ACCESS
0E1C  5808     SUBWFB type, W, ACCESS
0E1E  5011     MOVF fp, W, ACCESS
0E20  5809     SUBWFB Byte, W, ACCESS
0E22  5012     MOVF quotient, W, ACCESS
0E24  580A     SUBWFB string, W, ACCESS
0E26  5013     MOVF c, W, ACCESS
0E28  580B     SUBWFB pa, W, ACCESS
0E2A  5014     MOVF i, W, ACCESS
0E2C  580C     SUBWFB dividend, W, ACCESS
0E2E  5015     MOVF 0x15, W, ACCESS
0E30  580D     SUBWFB dis, W, ACCESS
0E32  A0D8     BTFSS STATUS, 0, ACCESS
0E34  D011     BRA 0xE58
34:            				dividend -= divisor;
0E36  500E     MOVF divisor, W, ACCESS
0E38  5E06     SUBWF Values, F, ACCESS
0E3A  500F     MOVF s, W, ACCESS
0E3C  5A07     SUBWFB number, F, ACCESS
0E3E  5010     MOVF counter, W, ACCESS
0E40  5A08     SUBWFB type, F, ACCESS
0E42  5011     MOVF fp, W, ACCESS
0E44  5A09     SUBWFB Byte, F, ACCESS
0E46  5012     MOVF quotient, W, ACCESS
0E48  5A0A     SUBWFB string, F, ACCESS
0E4A  5013     MOVF c, W, ACCESS
0E4C  5A0B     SUBWFB pa, F, ACCESS
0E4E  5014     MOVF i, W, ACCESS
0E50  5A0C     SUBWFB dividend, F, ACCESS
0E52  5015     MOVF 0x15, W, ACCESS
0E54  5A0D     SUBWFB dis, F, ACCESS
35:            				quotient |= 1;
0E56  8018     BSF buf, 0, ACCESS
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
0E58  90D8     BCF STATUS, 0, ACCESS
0E5A  3215     RRCF 0x15, F, ACCESS
0E5C  3214     RRCF i, F, ACCESS
0E5E  3213     RRCF c, F, ACCESS
0E60  3212     RRCF quotient, F, ACCESS
0E62  3211     RRCF fp, F, ACCESS
0E64  3210     RRCF counter, F, ACCESS
0E66  320F     RRCF s, F, ACCESS
0E68  320E     RRCF divisor, F, ACCESS
38:            		} while(--counter != 0);
0E6A  2E16     DECFSZ fp, F, ACCESS
0E6C  D7C9     BRA 0xE00
39:            	}
40:            	if(sign)
0E6E  5017     MOVF sign, W, ACCESS
0E70  B4D8     BTFSC STATUS, 2, ACCESS
0E72  D010     BRA 0xE94
41:            		quotient = -quotient;
0E74  1E1F     COMF w, F, ACCESS
0E76  1E1E     COMF counter, F, ACCESS
0E78  1E1D     COMF i, F, ACCESS
0E7A  1E1C     COMF 0x1C, F, ACCESS
0E7C  1E1B     COMF mL, F, ACCESS
0E7E  1E1A     COMF p, F, ACCESS
0E80  1E19     COMF PWMduty, F, ACCESS
0E82  6C18     NEGF buf, ACCESS
0E84  0E00     MOVLW 0x0
0E86  2219     ADDWFC PWMduty, F, ACCESS
0E88  221A     ADDWFC p, F, ACCESS
0E8A  221B     ADDWFC mL, F, ACCESS
0E8C  221C     ADDWFC 0x1C, F, ACCESS
0E8E  221D     ADDWFC i, F, ACCESS
0E90  221E     ADDWFC counter, F, ACCESS
0E92  221F     ADDWFC w, F, ACCESS
42:            	return quotient;
0E94  C018     MOVFF buf, Values
0E96  F006     NOP
0E98  C019     MOVFF PWMduty, number
0E9A  F007     NOP
0E9C  C01A     MOVFF p, type
0E9E  F008     NOP
0EA0  C01B     MOVFF mL, Byte
0EA2  F009     NOP
0EA4  C01C     MOVFF 0x1C, string
0EA6  F00A     NOP
0EA8  C01D     MOVFF i, pa
0EAA  F00B     NOP
0EAC  C01E     MOVFF counter, dividend
0EAE  F00C     NOP
0EB0  C01F     MOVFF w, dis
0EB2  F00D     NOP
0EB4  0012     RETURN 0
43:            }
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/abs.c  ------------------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
1A60  BE19     BTFSC PWMduty, 7, ACCESS
1A62  D005     BRA 0x1A6E
1A64  5019     MOVF PWMduty, W, ACCESS
1A66  E110     BNZ 0x1A88
1A68  0418     DECF buf, W, ACCESS
1A6A  B0D8     BTFSC STATUS, 0, ACCESS
1A6C  D00D     BRA 0x1A88
1A6E  C018     MOVFF buf, p
1A70  F01A     NOP
1A72  C019     MOVFF PWMduty, mL
1A74  F01B     NOP
1A76  1E1A     COMF p, F, ACCESS
1A78  1E1B     COMF mL, F, ACCESS
1A7A  4A1A     INFSNZ p, F, ACCESS
1A7C  2A1B     INCF mL, F, ACCESS
1A7E  C01A     MOVFF p, buf
1A80  F018     NOP
1A82  C01B     MOVFF mL, PWMduty
1A84  F019     NOP
1A86  0012     RETURN 0
1A88  C018     MOVFF buf, buf
1A8A  F018     NOP
1A8C  C019     MOVFF PWMduty, PWMduty
1A8E  F019     NOP
1A90  0012     RETURN 0
4:             }
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/Umul16.c  ---------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
1B46  5006     MOVF Values, W, ACCESS
1B48  0208     MULWF type, ACCESS
1B4A  CFF3     MOVFF PROD, string
1B4C  F00A     NOP
1B4E  CFF4     MOVFF PRODH, pa
1B50  F00B     NOP
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
1B52  5006     MOVF Values, W, ACCESS
1B54  0209     MULWF Byte, ACCESS
1B56  50F3     MOVF PROD, W, ACCESS
1B58  260B     ADDWF pa, F, ACCESS
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
1B5A  5007     MOVF number, W, ACCESS
1B5C  0208     MULWF type, ACCESS
1B5E  50F3     MOVF PROD, W, ACCESS
1B60  260B     ADDWF pa, F, ACCESS
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
1B62  C00A     MOVFF string, Values
1B64  F006     NOP
1B66  C00B     MOVFF pa, number
1B68  F007     NOP
1B6A  0012     RETURN 0
53:            }
