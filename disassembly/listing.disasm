Disassembly Listing for final
Generated From:
/Users/hasan/Box Sync/me4/ecm/dist/default/debug/ecm.debug.elf
Dec 5, 2018 9:55:06 AM

---  /Users/hasan/Box Sync/me4/ecm/rfid.c  --------------------------------------------------------------
1:             #include "rfid.h"
2:             
3:             void init_RFID(void) {
4:                 TRISC = TRISC | 0b11000000; //set data direction registers to the TRGIF tag
1CE8  5094     MOVF TRISC, W, ACCESS
1CEA  09C0     IORLW 0xC0
1CEC  6E94     MOVWF TRISC, ACCESS
5:                 SPBRG = 204; //set baud rate to 9600
1CEE  0ECC     MOVLW 0xCC
1CF0  6EAF     MOVWF SPBRG, ACCESS
6:                 SPBRGH = 0;
1CF2  0E00     MOVLW 0x0
1CF4  6EB0     MOVWF SPBRGH, ACCESS
7:                 BAUDCONbits.BRG16 = 1; //set baud rate scaling to 16 bit mode
1CF6  86AA     BSF BAUDCON, 3, ACCESS
8:                 TXSTAbits.BRGH = 1; //high baud rate select bit
1CF8  84AC     BSF TXSTA, 2, ACCESS
9:                 RCSTAbits.CREN = 1; //continous receive mode
1CFA  88AB     BSF RCSTA, 4, ACCESS
10:                RCSTAbits.SPEN = 1; //enable serial port, other settings default
1CFC  8EAB     BSF RCSTA, 7, ACCESS
11:                TXSTAbits.TXEN = 1; //enable transmitter, other settings default
1CFE  8AAC     BSF TXSTA, 5, ACCESS
12:            }
1D00  0012     RETURN 0
13:            
14:            void interrupt_EUSART(void) {
15:                RCREG;
1D18  50AE     MOVF RCREG, W, ACCESS
16:                RCREG;
1D1A  50AE     MOVF RCREG, W, ACCESS
17:                RCREG; //Calling RCREG to clear any previous data
1D1C  50AE     MOVF RCREG, W, ACCESS
18:                PIE1bits.RCIE = 1; //Enable EUSART interrupt
1D1E  8A9D     BSF PIE1, 5, ACCESS
19:                INTCONbits.GIEL = 1; //enable peripheral interrupts
1D20  8CF2     BSF INTCON, 6, ACCESS
20:                INTCONbits.GIEH = 1; //enable global interrupts
1D22  8EF2     BSF INTCON, 7, ACCESS
21:                INTCON3bits.INT2IE = 1; //enable external interrupts
1D24  88F0     BSF INTCON3, 4, ACCESS
22:            }
1D26  0012     RETURN 0
23:            //this functions inputs the address of the RFID string array. Values in the LCD displaying ir readings are cleared and the RFID string is sent to the LCD
24:            
25:            void print_RFID(char *pa, char *dis) {
26:            
27:                LCD_clear(); //Remove the current data displayed in the LCD
18E2  EC4C     CALL 0x1C98, 0
18E4  F00E     NOP
28:                LCD_line(1);
18E6  0E01     MOVLW 0x1
18E8  ECE8     CALL 0x1BD0, 0
18EA  F00D     NOP
29:                while (*pa != 0x03) { //Finds the address at the last RFID character
18EC  D002     BRA 0x18F2
30:                    pa++;
18EE  4A0B     INFSNZ pa, F, ACCESS
18F0  2A0C     INCF dividend, F, ACCESS
31:                }
18F2  C00B     MOVFF pa, FSR2
18F4  FFD9     NOP
18F6  C00C     MOVFF dividend, FSR2H
18F8  FFDA     NOP
18FA  0E03     MOVLW 0x3
18FC  18DE     XORWF POSTINC2, W, ACCESS
18FE  B4D8     BTFSC STATUS, 2, ACCESS
1900  D012     BRA 0x1926
1902  D7F5     BRA 0x18EE
32:            
33:                //Send ASCII characters read from the RFID string to the LCD
34:                while ((dis + 1) < (pa - 2)) { //dis is the address at the first value of the rfid string array. Starting at dis + 1 and finishing at pa - 2 removes undesired ASCII characters read by the RFID.
35:            
36:                    LCD_send(*(dis + 1), 1);
1904  0E01     MOVLW 0x1
1906  6E08     MOVWF type, ACCESS
1908  EE20     LFSR 2, 0x1
190A  F001     NOP
190C  500D     MOVF dis, W, ACCESS
190E  26D9     ADDWF FSR2, F, ACCESS
1910  500E     MOVF divisor, W, ACCESS
1912  22DA     ADDWFC FSR2H, F, ACCESS
1914  50DF     MOVF INDF2, W, ACCESS
1916  EC00     CALL 0x1C00, 0
1918  F00E     NOP
37:                    __delay_us(50);
191A  0E21     MOVLW 0x21
191C  2EE8     DECFSZ WREG, F, ACCESS
191E  D7FE     BRA 0x191C
1920  F000     NOP
38:            
39:                    dis++;
1922  4A0D     INFSNZ dis, F, ACCESS
1924  2A0E     INCF divisor, F, ACCESS
40:                }
1926  0EFE     MOVLW 0xFE
1928  6E0F     MOVWF s, ACCESS
192A  0EFF     MOVLW 0xFF
192C  6E10     MOVWF counter, ACCESS
192E  C00B     MOVFF pa, fp
1930  F011     NOP
1932  C00C     MOVFF dividend, quotient
1934  F012     NOP
1936  500F     MOVF s, W, ACCESS
1938  2611     ADDWF fp, F, ACCESS
193A  5010     MOVF counter, W, ACCESS
193C  2212     ADDWFC quotient, F, ACCESS
193E  0E01     MOVLW 0x1
1940  240D     ADDWF dis, W, ACCESS
1942  6E13     MOVWF c, ACCESS
1944  0E00     MOVLW 0x0
1946  200E     ADDWFC divisor, W, ACCESS
1948  6E14     MOVWF i, ACCESS
194A  5011     MOVF fp, W, ACCESS
194C  5C13     SUBWF c, W, ACCESS
194E  5012     MOVF quotient, W, ACCESS
1950  5814     SUBWFB i, W, ACCESS
1952  A0D8     BTFSS STATUS, 0, ACCESS
1954  D7D7     BRA 0x1904
41:                LCD_line(2); // Set next line for the checksum display function
1956  0E02     MOVLW 0x2
1958  ECE8     CALL 0x1BD0, 0
195A  F00D     NOP
42:            }
195C  0012     RETURN 0
43:            
44:            
45:            // This function calls the stored RFID string initial value address. The stores RFID string has 12 valuable characters in ASCII format. These are transformed into hexadecimal and stored in the array_check array. low and high bits are combined to form 16 bit integers in the bit_16 array, where the first 5 values are XORed and compared to the 6th value. If satisfied, checksum is correct.
46:            
47:            void check_sum(char *str, char *arr_check, int *bit16, int btc) {
48:            
49:                //Conversion of the string from ASCII to Hexadecimal
50:                int i = 0;
51:                while (i < 12) { // store the 12 valuable characters of the RFID called with the *str address into the array_check array
52:                    if ((*(str + 1) >> 6) == 1) { //If the (str + 1)th character in the RFID string is an ASCII letter, subtract 55 and move to the next character
53:                        *(arr_check) = *(str + 1) - 55;
54:                        str++;
55:                        arr_check++;
56:                        i++;
57:                    } else { //else if it is an ASCII number, subtract 48 and move to the next character
58:                        *(arr_check) = *(str + 1) - 48;
59:                        str++;
60:                        arr_check++;
61:                        i++;
62:                    }
63:                }
64:            
65:                for (char j = 0; j < 6; j++) { //bit_16(count) is written with overlaid low and high bits from the array_check array, compressing a 12 dimensional array into a 6 dimensional array 
66:                    *bit16 = (*(arr_check + 2 * j - 12) << 8) | *(arr_check + 2 * j + 1 - 12); //previous arr_check stopped at 12th position, thus - 12 is necessary to start at the first position of array_check
67:                    bit16++; //move to the next address in the bit_16 array
68:                }
69:            
70:                int xor_value = ((*(bit16 - 6))^(*(bit16 - 5))^(*(bit16 - 4))^(*(bit16 - 3))^(*(bit16 - 2))); // calculate the XOR value of the first 5 entries of the bit_16 array (starts at -6 instead of -5 because the bit16 address is increased in the last iteration above).
71:            
72:                char buf_cs[16];
73:                if (xor_value == *(bit16 - 1)) { //check if the calculated XOR value is identical to the RFID string checksum value and display condition in the LCD display
74:                    sprintf(buf_cs, "CS CORRECT %d", btc); //Also displaying the value of back trace counter to see the number of steps
75:                    LCD_string(buf_cs);
76:                } else {
77:                    sprintf(buf_cs, "CS INCORRECT %d", btc);
78:                    LCD_string(buf_cs);
79:                }
80:            
81:            }
82:            
83:            
84:            
85:            
86:            
---  /Users/hasan/Box Sync/me4/ecm/reverse.c  -----------------------------------------------------------
1:             #include <xc.h>
2:             #include "reverse.h"
3:             #include "motor.h"
4:             
5:             void initTimer0(void) {
6:                 T0CONbits.TMR0ON = 1; //turn on timer0
7:                 T0CONbits.T016BIT = 0; // 16bit mode
8:                 T0CONbits.T0CS = 1; // Transition on T0CKI pin input edge
9:                 T0CONbits.PSA = 0; //Enable prescaler
10:                T0CONbits.T0PS = 0b001; // set prescaler value to 4
11:                T0CONbits.T0SE = 0; // Increment on low-to-high transition on T0CKI pin
12:                TMR0L = 0; //Initialise TMR0L and TMR0H to 0, these are re-set to 0 every time the back_trace_counter step increases
13:                TMR0H = 0;
14:            }
15:            
16:            void initEncoder(void) {
17:                /*
18:                 *Enable interrupt and set as high priority 
19:                 */
20:                INTCON3bits.INT2IE = 1;
1D28  88F0     BSF INTCON3, 4, ACCESS
21:                INTCON3bits.INT2IP = 1;
1D2A  8EF0     BSF INTCON3, 7, ACCESS
22:                INTCON2bits.INTEDG2 = 1; /* driven by rising edge */
1D2C  88F1     BSF INTCON2, 4, ACCESS
23:                INTCON3bits.INT2IF = 0; /*flag set to 0*/
1D2E  92F0     BCF INTCON3, 1, ACCESS
24:                /*
25:                 * Set LAT and TRIS
26:                 */
27:                LATCbits.LATC5 = 0;
1D30  9A8B     BCF LATC, 5, ACCESS
28:                TRISCbits.RC5 = 0;
1D32  9A94     BCF TRISC, 5, ACCESS
29:            }
1D34  0012     RETURN 0
30:            
31:            //void reverse_routine{
32:            //    switch () {
33:            //            // If action was forwards, reverse
34:            //        case Direction.forwards:
35:            //            reverse(mL, mR);
36:            //
37:            //            break;
38:            //
39:            //            // If action was a left turn, turn right
40:            //        case Direction.left:
41:            //            turnRight(mL, mR); // Adjust power to compensate
42:            //            // for tendency of base to turn
43:            //            break;
44:            //
45:            //            // If action was a right turn, turn left
46:            //        case Direction.right:
47:            //            turnLeft(mL, mR); // Adjust power to compensate
48:            //            // for tendency of base to turn
49:            //            break;
50:            //
51:            //            // Otherwise, stop the motors
52:            //        default:
53:            //            stop(mL, mR);
54:            //
55:            //            break;
56:            //    }
57:            //}
58:            //
59:            //int reverse_store(struct Direction *reverseDirection, char forwardDirection, int forwardTime,  ) 
60:            //counter++;
61:            //return counter;
---  /Users/hasan/Box Sync/me4/ecm/motor.c  -------------------------------------------------------------
1:             #include "motor.h"
2:             #define POWER 100
3:             #define POWER2 60
4:             #define POWER3 60
5:             
6:             
7:             
8:             /*
9:              * To initialise motor PWM
10:             */
11:            void initPWM(void) {
12:                TRISB = 0; //setting port as output TODO remove 
1C7A  0E00     MOVLW 0x0
1C7C  6E93     MOVWF TRISB, ACCESS
13:            
14:                PTCON0 = 0b00000000;
1C7E  0E00     MOVLW 0x0
1C80  6E7F     MOVWF PTCON0, ACCESS
15:                PTCON1 = 0b10000000;
1C82  0E80     MOVLW 0x80
1C84  6E7E     MOVWF PTCON1, ACCESS
16:            
17:                PWMCON0 = 0b01111111;
1C86  0E7F     MOVLW 0x7F
1C88  6E6F     MOVWF PWMCON0, ACCESS
18:                PWMCON1 = 0x00;
1C8A  0E00     MOVLW 0x0
1C8C  6E6E     MOVWF PWMCON1, ACCESS
19:            
20:                /*base period low and high bytes*/
21:                PTPERL = 0b11000111;
1C8E  0EC7     MOVLW 0xC7
1C90  6E7B     MOVWF PTPERL, ACCESS
22:                PTPERH = 0b0000;
1C92  0E00     MOVLW 0x0
1C94  6E7A     MOVWF PTPERH, ACCESS
23:            }
1C96  0012     RETURN 0
24:            
25:            void setMotorPWM(struct Motor *m) {
26:                int PWMduty; //tmp variable to store PWM duty cycle
27:                if (m->direction) { //if forward
0DCC  EE20     LFSR 2, 0x1
0DCE  F001     NOP
0DD0  5014     MOVF i, W, ACCESS
0DD2  26D9     ADDWF FSR2, F, ACCESS
0DD4  5015     MOVF 0x15, W, ACCESS
0DD6  22DA     ADDWFC FSR2H, F, ACCESS
0DD8  50DF     MOVF INDF2, W, ACCESS
0DDA  B4D8     BTFSC STATUS, 2, ACCESS
0DDC  D034     BRA 0xE46
28:                    // low time increases with power
29:                    PWMduty = m->period - ((int) (m->power)*(m->period)) / 100;
0DDE  EE20     LFSR 2, 0x7
0DE0  F007     NOP
0DE2  5014     MOVF i, W, ACCESS
0DE4  26D9     ADDWF FSR2, F, ACCESS
0DE6  5015     MOVF 0x15, W, ACCESS
0DE8  22DA     ADDWFC FSR2H, F, ACCESS
0DEA  CFDE     MOVFF POSTINC2, fp
0DEC  F016     NOP
0DEE  CFDD     MOVFF POSTDEC2, sign
0DF0  F017     NOP
0DF2  C014     MOVFF i, FSR2
0DF4  FFD9     NOP
0DF6  C015     MOVFF 0x15, FSR2H
0DF8  FFDA     NOP
0DFA  50DF     MOVF INDF2, W, ACCESS
0DFC  6E18     MOVWF buf, ACCESS
0DFE  5018     MOVF buf, W, ACCESS
0E00  6E06     MOVWF Values, ACCESS
0E02  6A07     CLRF number, ACCESS
0E04  EE20     LFSR 2, 0x7
0E06  F007     NOP
0E08  5014     MOVF i, W, ACCESS
0E0A  26D9     ADDWF FSR2, F, ACCESS
0E0C  5015     MOVF 0x15, W, ACCESS
0E0E  22DA     ADDWFC FSR2H, F, ACCESS
0E10  CFDE     MOVFF POSTINC2, type
0E12  F008     NOP
0E14  CFDD     MOVFF POSTDEC2, Byte
0E16  F009     NOP
0E18  EC2A     CALL 0x1C54, 0
0E1A  F00E     NOP
0E1C  C006     MOVFF Values, dividend
0E1E  F00C     NOP
0E20  C007     MOVFF number, dis
0E22  F00D     NOP
0E24  0E00     MOVLW 0x0
0E26  6E0F     MOVWF s, ACCESS
0E28  0E64     MOVLW 0x64
0E2A  6E0E     MOVWF divisor, ACCESS
0E2C  EC2F     CALL 0x185E, 0
0E2E  F00C     NOP
0E30  1E0C     COMF dividend, F, ACCESS
0E32  1E0D     COMF dis, F, ACCESS
0E34  4A0C     INFSNZ dividend, F, ACCESS
0E36  2A0D     INCF dis, F, ACCESS
0E38  5016     MOVF fp, W, ACCESS
0E3A  240C     ADDWF dividend, W, ACCESS
0E3C  6E19     MOVWF PWMduty, ACCESS
0E3E  5017     MOVF sign, W, ACCESS
0E40  200D     ADDWFC dis, W, ACCESS
0E42  6E1A     MOVWF p, ACCESS
30:                } else { //if reverse
0E44  D023     BRA 0xE8C
31:                    // high time increases with power
32:                    PWMduty = ((int) (m->power)*(m->period)) / 100;
0E46  C014     MOVFF i, FSR2
0E48  FFD9     NOP
0E4A  C015     MOVFF 0x15, FSR2H
0E4C  FFDA     NOP
0E4E  50DF     MOVF INDF2, W, ACCESS
0E50  6E16     MOVWF fp, ACCESS
0E52  5016     MOVF fp, W, ACCESS
0E54  6E06     MOVWF Values, ACCESS
0E56  6A07     CLRF number, ACCESS
0E58  EE20     LFSR 2, 0x7
0E5A  F007     NOP
0E5C  5014     MOVF i, W, ACCESS
0E5E  26D9     ADDWF FSR2, F, ACCESS
0E60  5015     MOVF 0x15, W, ACCESS
0E62  22DA     ADDWFC FSR2H, F, ACCESS
0E64  CFDE     MOVFF POSTINC2, type
0E66  F008     NOP
0E68  CFDD     MOVFF POSTDEC2, Byte
0E6A  F009     NOP
0E6C  EC2A     CALL 0x1C54, 0
0E6E  F00E     NOP
0E70  C006     MOVFF Values, dividend
0E72  F00C     NOP
0E74  C007     MOVFF number, dis
0E76  F00D     NOP
0E78  0E00     MOVLW 0x0
0E7A  6E0F     MOVWF s, ACCESS
0E7C  0E64     MOVLW 0x64
0E7E  6E0E     MOVWF divisor, ACCESS
0E80  EC2F     CALL 0x185E, 0
0E82  F00C     NOP
0E84  C00C     MOVFF dividend, PWMduty
0E86  F019     NOP
0E88  C00D     MOVFF dis, p
0E8A  F01A     NOP
33:                }
34:                PWMduty = (PWMduty << 2); // two LSBs are reserved for other things
0E8C  C019     MOVFF PWMduty, fp
0E8E  F016     NOP
0E90  C01A     MOVFF p, sign
0E92  F017     NOP
0E94  90D8     BCF STATUS, 0, ACCESS
0E96  3616     RLCF fp, F, ACCESS
0E98  3617     RLCF sign, F, ACCESS
0E9A  90D8     BCF STATUS, 0, ACCESS
0E9C  3616     RLCF fp, F, ACCESS
0E9E  3617     RLCF sign, F, ACCESS
0EA0  C016     MOVFF fp, PWMduty
0EA2  F019     NOP
0EA4  C017     MOVFF sign, p
0EA6  F01A     NOP
35:                *(m->duty_low) = PWMduty & 0xFF; //set low duty cycle byte
0EA8  EE20     LFSR 2, 0x2
0EAA  F002     NOP
0EAC  5014     MOVF i, W, ACCESS
0EAE  26D9     ADDWF FSR2, F, ACCESS
0EB0  5015     MOVF 0x15, W, ACCESS
0EB2  22DA     ADDWFC FSR2H, F, ACCESS
0EB4  CFDE     MOVFF POSTINC2, fp
0EB6  F016     NOP
0EB8  CFDD     MOVFF POSTDEC2, sign
0EBA  F017     NOP
0EBC  C016     MOVFF fp, FSR2
0EBE  FFD9     NOP
0EC0  C017     MOVFF sign, FSR2H
0EC2  FFDA     NOP
0EC4  C019     MOVFF PWMduty, INDF2
0EC6  FFDF     NOP
36:                *(m->duty_high) = (PWMduty >> 8) & 0x3F; //set high duty cycle byte
0EC8  EE20     LFSR 2, 0x4
0ECA  F004     NOP
0ECC  5014     MOVF i, W, ACCESS
0ECE  26D9     ADDWF FSR2, F, ACCESS
0ED0  5015     MOVF 0x15, W, ACCESS
0ED2  22DA     ADDWFC FSR2H, F, ACCESS
0ED4  CFDE     MOVFF POSTINC2, fp
0ED6  F016     NOP
0ED8  CFDD     MOVFF POSTDEC2, sign
0EDA  F017     NOP
0EDC  C016     MOVFF fp, FSR2
0EDE  FFD9     NOP
0EE0  C017     MOVFF sign, FSR2H
0EE2  FFDA     NOP
0EE4  501A     MOVF p, W, ACCESS
0EE6  0B3F     ANDLW 0x3F
0EE8  6EDF     MOVWF INDF2, ACCESS
37:            
38:                if (m->direction) { // if direction is high,
0EEA  EE20     LFSR 2, 0x1
0EEC  F001     NOP
0EEE  5014     MOVF i, W, ACCESS
0EF0  26D9     ADDWF FSR2, F, ACCESS
0EF2  5015     MOVF 0x15, W, ACCESS
0EF4  22DA     ADDWFC FSR2H, F, ACCESS
0EF6  50DF     MOVF INDF2, W, ACCESS
0EF8  B4D8     BTFSC STATUS, 2, ACCESS
0EFA  D014     BRA 0xF24
39:                    LATB = LATB | (1 << (m->dir_pin)); // set dir_pin bit in LATB to high
0EFC  EE20     LFSR 2, 0x6
0EFE  F006     NOP
0F00  5014     MOVF i, W, ACCESS
0F02  26D9     ADDWF FSR2, F, ACCESS
0F04  5015     MOVF 0x15, W, ACCESS
0F06  22DA     ADDWFC FSR2H, F, ACCESS
0F08  50DF     MOVF INDF2, W, ACCESS
0F0A  6E16     MOVWF fp, ACCESS
0F0C  0E01     MOVLW 0x1
0F0E  6E17     MOVWF sign, ACCESS
0F10  2A16     INCF fp, F, ACCESS
0F12  D002     BRA 0xF18
0F14  90D8     BCF STATUS, 0, ACCESS
0F16  3617     RLCF sign, F, ACCESS
0F18  2E16     DECFSZ fp, F, ACCESS
0F1A  D7FC     BRA 0xF14
0F1C  5017     MOVF sign, W, ACCESS
0F1E  108A     IORWF LATB, W, ACCESS
0F20  6E8A     MOVWF LATB, ACCESS
40:                } else { // if direction is low,
0F22  0012     RETURN 0
41:                    LATB = LATB & (~(1 << (m->dir_pin))); // set dir_pin bit in LATB to low
0F24  EE20     LFSR 2, 0x6
0F26  F006     NOP
0F28  5014     MOVF i, W, ACCESS
0F2A  26D9     ADDWF FSR2, F, ACCESS
0F2C  5015     MOVF 0x15, W, ACCESS
0F2E  22DA     ADDWFC FSR2H, F, ACCESS
0F30  50DF     MOVF INDF2, W, ACCESS
0F32  6E16     MOVWF fp, ACCESS
0F34  0E01     MOVLW 0x1
0F36  6E17     MOVWF sign, ACCESS
0F38  2A16     INCF fp, F, ACCESS
0F3A  D002     BRA 0xF40
0F3C  90D8     BCF STATUS, 0, ACCESS
0F3E  3617     RLCF sign, F, ACCESS
0F40  2E16     DECFSZ fp, F, ACCESS
0F42  D7FC     BRA 0xF3C
0F44  5017     MOVF sign, W, ACCESS
0F46  0AFF     XORLW 0xFF
0F48  148A     ANDWF LATB, W, ACCESS
0F4A  6E8A     MOVWF LATB, ACCESS
0F4C  0012     RETURN 0
42:                }
43:            }
44:            
45:            //Control which motor turns on and which direction it rotates
46:            
47:            void accelerate(struct Motor *m) {
48:                for (m->power; (m->power) <= POWER; m->power++) { //increase motor power until 100
49:                    setMotorPWM(m); //pass pointer to setMotorSpeed function (not &m here)
50:                    __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
51:                }
52:            }
53:            
54:            void accelerate2(struct Motor *m) {
55:                for (m->power; (m->power) <= POWER2; m->power++) { //increase motor power until 100
56:                    setMotorPWM(m); //pass pointer to setMotorSpeed function (not &m here)
57:                    __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
58:                }
59:            }
60:            
61:            void decelerate(struct Motor *m) {
62:                for (m->power; (m->power) > 0; m->power--) { //increase motor power until 100
63:                    setMotorPWM(m); //pass pointer to setMotorSpeed function (not &m here)
64:                    __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
65:                }
66:            }
67:            
68:            // high level functions to control left and right motor
69:            // use setMotorPWM to perform low level update
70:            // bring the robot base to a stop
71:            
72:            void stop(struct Motor *mL, struct Motor *mR) {
73:                // mL->direction = 0;
74:                // mR->direction = 0;
75:                while (mL->power > 0 || mR->power > 0) {
19D6  D02B     BRA 0x1A2E
76:                    if (mL->power > 0) {
19D8  C01B     MOVFF mL, FSR2
19DA  FFD9     NOP
19DC  C01C     MOVFF 0x1C, FSR2H
19DE  FFDA     NOP
19E0  50DF     MOVF INDF2, W, ACCESS
19E2  B4D8     BTFSC STATUS, 2, ACCESS
19E4  D005     BRA 0x19F0
77:                        mL->power--;
19E6  C01B     MOVFF mL, FSR2
19E8  FFD9     NOP
19EA  C01C     MOVFF 0x1C, FSR2H
19EC  FFDA     NOP
19EE  06DF     DECF INDF2, F, ACCESS
78:                    }
79:                    if (mR->power > 0) {
19F0  C01D     MOVFF i, FSR2
19F2  FFD9     NOP
19F4  C01E     MOVFF counter, FSR2H
19F6  FFDA     NOP
19F8  50DF     MOVF INDF2, W, ACCESS
19FA  B4D8     BTFSC STATUS, 2, ACCESS
19FC  D005     BRA 0x1A08
80:                        mR->power--;
19FE  C01D     MOVFF i, FSR2
1A00  FFD9     NOP
1A02  C01E     MOVFF counter, FSR2H
1A04  FFDA     NOP
1A06  06DF     DECF INDF2, F, ACCESS
81:                    }
82:                    setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
1A08  C01B     MOVFF mL, i
1A0A  F014     NOP
1A0C  C01C     MOVFF 0x1C, 0x15
1A0E  F015     NOP
1A10  ECE6     CALL 0xDCC, 0
1A12  F006     NOP
83:                    setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
1A14  C01D     MOVFF i, i
1A16  F014     NOP
1A18  C01E     MOVFF counter, 0x15
1A1A  F015     NOP
1A1C  ECE6     CALL 0xDCC, 0
1A1E  F006     NOP
84:                    __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
1A20  0E0D     MOVLW 0xD
1A22  6E1F     MOVWF w, ACCESS
1A24  0EFC     MOVLW 0xFC
1A26  2EE8     DECFSZ WREG, F, ACCESS
1A28  D7FE     BRA 0x1A26
1A2A  2E1F     DECFSZ w, F, ACCESS
1A2C  D7FC     BRA 0x1A26
85:                }
1A2E  C01B     MOVFF mL, FSR2
1A30  FFD9     NOP
1A32  C01C     MOVFF 0x1C, FSR2H
1A34  FFDA     NOP
1A36  50DF     MOVF INDF2, W, ACCESS
1A38  A4D8     BTFSS STATUS, 2, ACCESS
1A3A  D7CE     BRA 0x19D8
1A3C  C01D     MOVFF i, FSR2
1A3E  FFD9     NOP
1A40  C01E     MOVFF counter, FSR2H
1A42  FFDA     NOP
1A44  50DF     MOVF INDF2, W, ACCESS
1A46  B4D8     BTFSC STATUS, 2, ACCESS
1A48  0012     RETURN 0
1A4A  D7C6     BRA 0x19D8
86:            }
87:            
88:            void turnLeft(struct Motor *mL, struct Motor *mR) {
89:                //setMotorStop(mL);
90:                //setMotorStop(mR);
91:                mL->direction = 0;
1732  EE20     LFSR 2, 0x1
1734  F001     NOP
1736  501B     MOVF mL, W, ACCESS
1738  26D9     ADDWF FSR2, F, ACCESS
173A  501C     MOVF 0x1C, W, ACCESS
173C  22DA     ADDWFC FSR2H, F, ACCESS
173E  0E00     MOVLW 0x0
1740  6EDF     MOVWF INDF2, ACCESS
92:                mR->direction = 1;
1742  EE20     LFSR 2, 0x1
1744  F001     NOP
1746  501D     MOVF i, W, ACCESS
1748  26D9     ADDWF FSR2, F, ACCESS
174A  501E     MOVF counter, W, ACCESS
174C  22DA     ADDWFC FSR2H, F, ACCESS
174E  0E01     MOVLW 0x1
1750  6EDF     MOVWF INDF2, ACCESS
93:                while (mL->power < POWER2 || mR->power < POWER2) {
1752  D02B     BRA 0x17AA
94:                    if (mL->power < POWER2) {
1754  C01B     MOVFF mL, FSR2
1756  FFD9     NOP
1758  C01C     MOVFF 0x1C, FSR2H
175A  FFDA     NOP
175C  0E3C     MOVLW 0x3C
175E  60DF     CPFSLT INDF2, ACCESS
1760  D005     BRA 0x176C
95:                        mL->power++;
1762  C01B     MOVFF mL, FSR2
1764  FFD9     NOP
1766  C01C     MOVFF 0x1C, FSR2H
1768  FFDA     NOP
176A  2ADF     INCF INDF2, F, ACCESS
96:                    }
97:                    if (mR->power < POWER2) {
176C  C01D     MOVFF i, FSR2
176E  FFD9     NOP
1770  C01E     MOVFF counter, FSR2H
1772  FFDA     NOP
1774  0E3C     MOVLW 0x3C
1776  60DF     CPFSLT INDF2, ACCESS
1778  D005     BRA 0x1784
98:                        mR->power++;
177A  C01D     MOVFF i, FSR2
177C  FFD9     NOP
177E  C01E     MOVFF counter, FSR2H
1780  FFDA     NOP
1782  2ADF     INCF INDF2, F, ACCESS
99:                    }
100:                   setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
1784  C01B     MOVFF mL, i
1786  F014     NOP
1788  C01C     MOVFF 0x1C, 0x15
178A  F015     NOP
178C  ECE6     CALL 0xDCC, 0
178E  F006     NOP
101:                   setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
1790  C01D     MOVFF i, i
1792  F014     NOP
1794  C01E     MOVFF counter, 0x15
1796  F015     NOP
1798  ECE6     CALL 0xDCC, 0
179A  F006     NOP
102:                   __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
179C  0E0D     MOVLW 0xD
179E  6E1F     MOVWF w, ACCESS
17A0  0EFC     MOVLW 0xFC
17A2  2EE8     DECFSZ WREG, F, ACCESS
17A4  D7FE     BRA 0x17A2
17A6  2E1F     DECFSZ w, F, ACCESS
17A8  D7FC     BRA 0x17A2
103:               }
17AA  C01B     MOVFF mL, FSR2
17AC  FFD9     NOP
17AE  C01C     MOVFF 0x1C, FSR2H
17B0  FFDA     NOP
17B2  0E3B     MOVLW 0x3B
17B4  64DF     CPFSGT INDF2, ACCESS
17B6  D7CE     BRA 0x1754
17B8  C01D     MOVFF i, FSR2
17BA  FFD9     NOP
17BC  C01E     MOVFF counter, FSR2H
17BE  FFDA     NOP
17C0  0E3B     MOVLW 0x3B
17C2  64DF     CPFSGT INDF2, ACCESS
17C4  D7C7     BRA 0x1754
17C6  0012     RETURN 0
104:           }
105:           
106:           void turnRight(struct Motor *mL, struct Motor *mR) {
107:               //setMotorStop(mL);
108:               //setMotorStop(mR);
109:               mL->direction = 1;
169C  EE20     LFSR 2, 0x1
169E  F001     NOP
16A0  501B     MOVF mL, W, ACCESS
16A2  26D9     ADDWF FSR2, F, ACCESS
16A4  501C     MOVF 0x1C, W, ACCESS
16A6  22DA     ADDWFC FSR2H, F, ACCESS
16A8  0E01     MOVLW 0x1
16AA  6EDF     MOVWF INDF2, ACCESS
110:               mR->direction = 0;
16AC  EE20     LFSR 2, 0x1
16AE  F001     NOP
16B0  501D     MOVF i, W, ACCESS
16B2  26D9     ADDWF FSR2, F, ACCESS
16B4  501E     MOVF counter, W, ACCESS
16B6  22DA     ADDWFC FSR2H, F, ACCESS
16B8  0E00     MOVLW 0x0
16BA  6EDF     MOVWF INDF2, ACCESS
111:               while (mL->power < POWER2 || mR->power < POWER2) {
16BC  D02B     BRA 0x1714
112:                   if (mL->power < POWER2) {
16BE  C01B     MOVFF mL, FSR2
16C0  FFD9     NOP
16C2  C01C     MOVFF 0x1C, FSR2H
16C4  FFDA     NOP
16C6  0E3C     MOVLW 0x3C
16C8  60DF     CPFSLT INDF2, ACCESS
16CA  D005     BRA 0x16D6
113:                       mL->power++;
16CC  C01B     MOVFF mL, FSR2
16CE  FFD9     NOP
16D0  C01C     MOVFF 0x1C, FSR2H
16D2  FFDA     NOP
16D4  2ADF     INCF INDF2, F, ACCESS
114:                   }
115:                   if (mR->power < POWER2) {
16D6  C01D     MOVFF i, FSR2
16D8  FFD9     NOP
16DA  C01E     MOVFF counter, FSR2H
16DC  FFDA     NOP
16DE  0E3C     MOVLW 0x3C
16E0  60DF     CPFSLT INDF2, ACCESS
16E2  D005     BRA 0x16EE
116:                       mR->power++;
16E4  C01D     MOVFF i, FSR2
16E6  FFD9     NOP
16E8  C01E     MOVFF counter, FSR2H
16EA  FFDA     NOP
16EC  2ADF     INCF INDF2, F, ACCESS
117:                   }
118:                   setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
16EE  C01B     MOVFF mL, i
16F0  F014     NOP
16F2  C01C     MOVFF 0x1C, 0x15
16F4  F015     NOP
16F6  ECE6     CALL 0xDCC, 0
16F8  F006     NOP
119:                   setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
16FA  C01D     MOVFF i, i
16FC  F014     NOP
16FE  C01E     MOVFF counter, 0x15
1700  F015     NOP
1702  ECE6     CALL 0xDCC, 0
1704  F006     NOP
120:                   __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
1706  0E0D     MOVLW 0xD
1708  6E1F     MOVWF w, ACCESS
170A  0EFC     MOVLW 0xFC
170C  2EE8     DECFSZ WREG, F, ACCESS
170E  D7FE     BRA 0x170C
1710  2E1F     DECFSZ w, F, ACCESS
1712  D7FC     BRA 0x170C
121:               }
1714  C01B     MOVFF mL, FSR2
1716  FFD9     NOP
1718  C01C     MOVFF 0x1C, FSR2H
171A  FFDA     NOP
171C  0E3B     MOVLW 0x3B
171E  64DF     CPFSGT INDF2, ACCESS
1720  D7CE     BRA 0x16BE
1722  C01D     MOVFF i, FSR2
1724  FFD9     NOP
1726  C01E     MOVFF counter, FSR2H
1728  FFDA     NOP
172A  0E3B     MOVLW 0x3B
172C  64DF     CPFSGT INDF2, ACCESS
172E  D7C7     BRA 0x16BE
1730  0012     RETURN 0
122:           }
123:           
124:           void turnRightSlow(struct Motor *mL, struct Motor *mR) {
125:               //setMotorStop(mL);
126:               //setMotorStop(mR);
127:               mL->direction = 1;
128:               mR->direction = 0;
129:               while (mL->power < POWER3 || mR->power < POWER3) {
130:                   if (mL->power < POWER3) {
131:                       mL->power++;
132:                   }
133:                   if (mR->power < POWER3
134:                           ) {
135:                       mR->power++;
136:                   }
137:                   setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
138:                   setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
139:                   __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
140:               }
141:           }
142:           // both motors forward and up to full power
143:           
144:           void forwards(struct Motor *mL, struct Motor *mR) {
145:               mL->direction = 0;
11BA  EE20     LFSR 2, 0x1
11BC  F001     NOP
11BE  501B     MOVF mL, W, ACCESS
11C0  26D9     ADDWF FSR2, F, ACCESS
11C2  501C     MOVF 0x1C, W, ACCESS
11C4  22DA     ADDWFC FSR2H, F, ACCESS
11C6  0E00     MOVLW 0x0
11C8  6EDF     MOVWF INDF2, ACCESS
146:               mR->direction = 0;
11CA  EE20     LFSR 2, 0x1
11CC  F001     NOP
11CE  501D     MOVF i, W, ACCESS
11D0  26D9     ADDWF FSR2, F, ACCESS
11D2  501E     MOVF counter, W, ACCESS
11D4  22DA     ADDWFC FSR2H, F, ACCESS
11D6  0E00     MOVLW 0x0
11D8  6EDF     MOVWF INDF2, ACCESS
147:               while (mL->power < POWER || mR->power < POWER) {
11DA  D02B     BRA 0x1232
148:                   if (mL->power < POWER) {
11DC  C01B     MOVFF mL, FSR2
11DE  FFD9     NOP
11E0  C01C     MOVFF 0x1C, FSR2H
11E2  FFDA     NOP
11E4  0E64     MOVLW 0x64
11E6  60DF     CPFSLT INDF2, ACCESS
11E8  D005     BRA 0x11F4
149:                       mL->power++;
11EA  C01B     MOVFF mL, FSR2
11EC  FFD9     NOP
11EE  C01C     MOVFF 0x1C, FSR2H
11F0  FFDA     NOP
11F2  2ADF     INCF INDF2, F, ACCESS
150:                   }
151:                   if (mR->power < POWER) {
11F4  C01D     MOVFF i, FSR2
11F6  FFD9     NOP
11F8  C01E     MOVFF counter, FSR2H
11FA  FFDA     NOP
11FC  0E64     MOVLW 0x64
11FE  60DF     CPFSLT INDF2, ACCESS
1200  D005     BRA 0x120C
152:                       mR->power++;
1202  C01D     MOVFF i, FSR2
1204  FFD9     NOP
1206  C01E     MOVFF counter, FSR2H
1208  FFDA     NOP
120A  2ADF     INCF INDF2, F, ACCESS
153:                   }
154:                   setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
120C  C01B     MOVFF mL, i
120E  F014     NOP
1210  C01C     MOVFF 0x1C, 0x15
1212  F015     NOP
1214  ECE6     CALL 0xDCC, 0
1216  F006     NOP
155:                   setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
1218  C01D     MOVFF i, i
121A  F014     NOP
121C  C01E     MOVFF counter, 0x15
121E  F015     NOP
1220  ECE6     CALL 0xDCC, 0
1222  F006     NOP
156:                   __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
1224  0E0D     MOVLW 0xD
1226  6E1F     MOVWF w, ACCESS
1228  0EFC     MOVLW 0xFC
122A  2EE8     DECFSZ WREG, F, ACCESS
122C  D7FE     BRA 0x122A
122E  2E1F     DECFSZ w, F, ACCESS
1230  D7FC     BRA 0x122A
157:               }
1232  C01B     MOVFF mL, FSR2
1234  FFD9     NOP
1236  C01C     MOVFF 0x1C, FSR2H
1238  FFDA     NOP
123A  0E63     MOVLW 0x63
123C  64DF     CPFSGT INDF2, ACCESS
123E  D7CE     BRA 0x11DC
1240  C01D     MOVFF i, FSR2
1242  FFD9     NOP
1244  C01E     MOVFF counter, FSR2H
1246  FFDA     NOP
1248  0E63     MOVLW 0x63
124A  64DF     CPFSGT INDF2, ACCESS
124C  D7C7     BRA 0x11DC
158:                   mR->direction = 0;
124E  EE20     LFSR 2, 0x1
1250  F001     NOP
1252  501D     MOVF i, W, ACCESS
1254  26D9     ADDWF FSR2, F, ACCESS
1256  501E     MOVF counter, W, ACCESS
1258  22DA     ADDWFC FSR2H, F, ACCESS
125A  0E00     MOVLW 0x0
125C  6EDF     MOVWF INDF2, ACCESS
159:                   while (mL->power < POWER2 || mR->power < POWER2) {
125E  D02B     BRA 0x12B6
160:                       if (mL->power < POWER2) {
1260  C01B     MOVFF mL, FSR2
1262  FFD9     NOP
1264  C01C     MOVFF 0x1C, FSR2H
1266  FFDA     NOP
1268  0E3C     MOVLW 0x3C
126A  60DF     CPFSLT INDF2, ACCESS
126C  D005     BRA 0x1278
161:                           mL->power++;
126E  C01B     MOVFF mL, FSR2
1270  FFD9     NOP
1272  C01C     MOVFF 0x1C, FSR2H
1274  FFDA     NOP
1276  2ADF     INCF INDF2, F, ACCESS
162:                       }
163:                       if (mR->power < POWER2) {
1278  C01D     MOVFF i, FSR2
127A  FFD9     NOP
127C  C01E     MOVFF counter, FSR2H
127E  FFDA     NOP
1280  0E3C     MOVLW 0x3C
1282  60DF     CPFSLT INDF2, ACCESS
1284  D005     BRA 0x1290
164:                           mR->power++;
1286  C01D     MOVFF i, FSR2
1288  FFD9     NOP
128A  C01E     MOVFF counter, FSR2H
128C  FFDA     NOP
128E  2ADF     INCF INDF2, F, ACCESS
165:                       }
166:                       setMotorPWM(mL); //pass pointer to setMotorSpeed function (not &m here)
1290  C01B     MOVFF mL, i
1292  F014     NOP
1294  C01C     MOVFF 0x1C, 0x15
1296  F015     NOP
1298  ECE6     CALL 0xDCC, 0
129A  F006     NOP
167:                       setMotorPWM(mR); //pass pointer to setMotorSpeed function (not &m here)
129C  C01D     MOVFF i, i
129E  F014     NOP
12A0  C01E     MOVFF counter, 0x15
12A2  F015     NOP
12A4  ECE6     CALL 0xDCC, 0
12A6  F006     NOP
168:                       __delay_ms(5); //delay of 5 ms (500 ms from 0 to 100 full power)
12A8  0E0D     MOVLW 0xD
12AA  6E1F     MOVWF w, ACCESS
12AC  0EFC     MOVLW 0xFC
12AE  2EE8     DECFSZ WREG, F, ACCESS
12B0  D7FE     BRA 0x12AE
12B2  2E1F     DECFSZ w, F, ACCESS
12B4  D7FC     BRA 0x12AE
169:                   }
12B6  C01B     MOVFF mL, FSR2
12B8  FFD9     NOP
12BA  C01C     MOVFF 0x1C, FSR2H
12BC  FFDA     NOP
12BE  0E3B     MOVLW 0x3B
12C0  64DF     CPFSGT INDF2, ACCESS
12C2  D7CE     BRA 0x1260
12C4  C01D     MOVFF i, FSR2
12C6  FFD9     NOP
12C8  C01E     MOVFF counter, FSR2H
12CA  FFDA     NOP
12CC  0E3B     MOVLW 0x3B
12CE  64DF     CPFSGT INDF2, ACCESS
12D0  D7C7     BRA 0x1260
12D2  0012     RETURN 0
170:               }
171:           
172:           
173:           
174:           
175:           
---  /Users/hasan/Box Sync/me4/ecm/main.c  --------------------------------------------------------------
1:             #pragma config OSC = IRCIO, LVP = OFF, MCLRE = OFF
2:             #include <stdio.h>
3:             #include <stdlib.h>
4:             #include <xc.h>
5:             #define _XTAL_FREQ 8000000
6:             #define PWMPERIOD 199
7:             #define TIME 100
8:             #include "lcd.h"
9:             #include "ir.h"
10:            #include "motor.h"
11:            #include "rfid.h"
12:            #include "reverse.h"
13:            
14:            
15:            volatile char card_read; //value will change during the code at any time therefore it must be a volatile character 
16:            char string_rfid[17]; //global variable because it is used in the RFID interrupt and called in the main loop 
17:            //
18:            volatile char count_encoder = 0;
19:            
20:            void __interrupt(high_priority) InterruptHandlerHigh() {
0008  825A     BSF btemp, 1, ACCESS
21:            
22:                //RFID tag
23:                static char count = 0;
24:                char rx_char;
25:            
26:                if (PIR1bits.RCIF) { //if a character is read from the rfid tag
001A  AA9E     BTFSS PIR1, 5, ACCESS
001C  D01A     BRA 0x52
27:                    rx_char = RCREG;
001E  CFAE     MOVFF RCREG, rx_char
0020  F005     NOP
28:                    if (rx_char == 0x02) { //if it is the first character of the message
0022  0E02     MOVLW 0x2
0024  1805     XORWF rx_char, W, ACCESS
0026  A4D8     BTFSS STATUS, 2, ACCESS
0028  D002     BRA 0x2E
29:                        count = 0;
002A  0E00     MOVLW 0x0
002C  6E59     MOVWF count, ACCESS
30:                    }
31:                    if (rx_char == 0x03) { //when all the message is read
002E  0E03     MOVLW 0x3
0030  1805     XORWF rx_char, W, ACCESS
0032  A4D8     BTFSS STATUS, 2, ACCESS
0034  D003     BRA 0x3C
32:                        card_read = 1; //enter RFID reading and checksum functions
0036  0E01     MOVLW 0x1
0038  0100     MOVLB 0x0
003A  6FBF     MOVWF card_read, BANKED
33:                    }
34:                    string_rfid[count] = rx_char; //store the character read by the RFID tag into a character string
003C  5059     MOVF count, W, ACCESS
003E  0D01     MULLW 0x1
0040  0EE1     MOVLW 0xE1
0042  24F3     ADDWF PROD, W, ACCESS
0044  6ED9     MOVWF FSR2, ACCESS
0046  0E00     MOVLW 0x0
0048  20F4     ADDWFC PRODH, W, ACCESS
004A  6EDA     MOVWF FSR2H, ACCESS
004C  C005     MOVFF rx_char, INDF2
004E  FFDF     NOP
35:                    count++;
0050  2A59     INCF count, F, ACCESS
36:                }
37:            
38:                if (INTCON3bits.INT2IF) {
0052  A2F0     BTFSS INTCON3, 1, ACCESS
0054  D003     BRA 0x5C
39:                    count_encoder++; // Increment the encoder counter
0056  0100     MOVLB 0x0
0058  2BBE     INCF count_encoder, F, BANKED
40:            
41:                    INTCON3bits.INT2IF = 0; // Clear the encoder flag
005A  92F0     BCF INTCON3, 1, ACCESS
42:                }
43:                
44:                if (INTCON3bits.INT2IF) { //external interrupt flag
005C  A2F0     BTFSS INTCON3, 1, ACCESS
005E  D00A     BRA 0x74
45:                    if (PORTCbits.RC5 == 1) { //Ask 4 times for the RC5 input to prevent button false positives
0060  BA82     BTFSC PORTC, 5, ACCESS
46:                        if (PORTCbits.RC5 == 1) {
0062  AA82     BTFSS PORTC, 5, ACCESS
0064  D006     BRA 0x72
47:                            if (PORTCbits.RC5 == 1) {
0066  BA82     BTFSC PORTC, 5, ACCESS
48:                                if (PORTCbits.RC5 == 1) {
0068  AA82     BTFSS PORTC, 5, ACCESS
006A  D003     BRA 0x72
49:                                    card_read = 0; //re-start the searching routine
006C  0E00     MOVLW 0x0
006E  0100     MOVLB 0x0
0070  6FBF     MOVWF card_read, BANKED
50:                                }
51:                            }
52:                        }
53:                    }
54:                    INTCON3bits.INT2IF = 0; //clear the interrupt flag
0072  92F0     BCF INTCON3, 1, ACCESS
55:                }
56:            
57:            }
0074  C004     MOVFF 0x4, PRODH
0076  FFF4     NOP
0078  C003     MOVFF 0x3, PROD
007A  FFF3     NOP
007C  C002     MOVFF 0x2, FSR2H
007E  FFDA     NOP
0080  C001     MOVFF __pcstackCOMRAM, FSR2
0082  FFD9     NOP
0084  925A     BCF btemp, 1, ACCESS
0086  0011     RETFIE 1
58:            
59:            void main(void) {
60:                ANSEL0 = 0; //Override start up analogue mode to digital instead
0334  0E00     MOVLW 0x0
0336  6EB8     MOVWF ANSEL0, ACCESS
61:                ANSEL1 = 0;
0338  0E00     MOVLW 0x0
033A  6EB9     MOVWF ANSEL1, ACCESS
62:                OSCCON = 0x72;
033C  0E72     MOVLW 0x72
033E  6ED3     MOVWF OSCCON, ACCESS
63:                while (!OSCCONbits.IOFS);
0340  A4D3     BTFSS OSCCON, 2, ACCESS
0342  D7FE     BRA 0x340
64:            
65:                LCD_init();
0344  EC6A     CALL 0x12D4, 0
0346  F009     NOP
66:            
67:                init_TIMER5();
0348  EC67     CALL 0x1CCE, 0
034A  F00E     NOP
68:                initPWM();
034C  EC3D     CALL 0x1C7A, 0
034E  F00E     NOP
69:                init_capture();
0350  EC5A     CALL 0x1CB4, 0
0352  F00E     NOP
70:                init_RFID();
0354  EC74     CALL 0x1CE8, 0
0356  F00E     NOP
71:                initEncoder();
0358  EC94     CALL 0x1D28, 0
035A  F00E     NOP
72:            
73:            
74:            
75:                interrupt_EUSART();
035C  EC8C     CALL 0x1D18, 0
035E  F00E     NOP
76:                struct Sensor_ir Values;
77:                struct Motor mL, mR;
78:                int PWMcycle = 199;
0360  0E00     MOVLW 0x0
0362  0100     MOVLB 0x0
0364  6F99     MOVWF 0x99, BANKED
0366  0EC7     MOVLW 0xC7
0368  6F98     MOVWF PWMcycle, BANKED
79:                mL.power = 0; //zero power to start
036A  0E00     MOVLW 0x0
036C  6FA8     MOVWF mL, BANKED
80:                mL.direction = 1; //set default motor direction, forward
036E  0E01     MOVLW 0x1
0370  6FA9     MOVWF 0xA9, BANKED
81:                mL.duty_low = (unsigned char *) (&PDC0L); //store address of PWM duty low byte
0372  0E79     MOVLW 0x79
0374  6FAA     MOVWF 0xAA, BANKED
0376  0E0F     MOVLW 0xF
0378  6FAB     MOVWF 0xAB, BANKED
82:                mL.duty_high = (unsigned char *) (&PDC0H); //store address of PWM duty high byte
037A  0E78     MOVLW 0x78
037C  6FAC     MOVWF 0xAC, BANKED
037E  0E0F     MOVLW 0xF
0380  6FAD     MOVWF 0xAD, BANKED
83:                mL.dir_pin = 0; //pin RB0/PWM0 controls direction
0382  0E00     MOVLW 0x0
0384  6FAE     MOVWF 0xAE, BANKED
84:                mL.period = PWMcycle; //store PWMperiod for motor
0386  C098     MOVFF PWMcycle, 0xAF
0388  F0AF     NOP
038A  C099     MOVFF 0x99, 0xB0
038C  F0B0     NOP
85:            
86:                //same for motorR but different PWM registers and direction pin
87:                mR.power = 0;
038E  0E00     MOVLW 0x0
0390  6FB1     MOVWF mR, BANKED
88:                mR.direction = 1;
0392  0E01     MOVLW 0x1
0394  6FB2     MOVWF 0xB2, BANKED
89:                mR.duty_low = (unsigned char *) (&PDC1L);
0396  0E77     MOVLW 0x77
0398  6FB3     MOVWF 0xB3, BANKED
039A  0E0F     MOVLW 0xF
039C  6FB4     MOVWF 0xB4, BANKED
90:                mR.duty_high = (unsigned char *) (&PDC1H);
039E  0E76     MOVLW 0x76
03A0  6FB5     MOVWF 0xB5, BANKED
03A2  0E0F     MOVLW 0xF
03A4  6FB6     MOVWF 0xB6, BANKED
91:                mR.dir_pin = 2; //pin RB2/PWM0 controls direction
03A6  0E02     MOVLW 0x2
03A8  6FB7     MOVWF 0xB7, BANKED
92:                mR.period = PWMcycle;
03AA  C098     MOVFF PWMcycle, 0xB8
03AC  F0B8     NOP
03AE  C099     MOVFF 0x99, 0xB9
03B0  F0B9     NOP
93:            
94:                while (1) {
95:            
96:                    int direction = 0;
03B2  D0B5     BRA 0x51E
97:                    //Searching for IR emitter 
98:            
99:                    while (card_read == 0) { //Card read is set to 0 by the interrupt set by pressing the button
100:                       read_IR(&Values);
03B4  0EA0     MOVLW 0xA0
03B6  6E06     MOVWF Values, ACCESS
03B8  0E00     MOVLW 0x0
03BA  6E07     MOVWF number, ACCESS
03BC  EC1B     CALL 0xA36, 0
03BE  F005     NOP
101:                       //            Values.left = measureIRLeft();
102:                       //            Values.right = measureIRRight();
103:           
104:                       print_IR(&Values);
03C0  0EA0     MOVLW 0xA0
03C2  0100     MOVLB 0x0
03C4  6F82     MOVWF Values, BANKED
03C6  0E00     MOVLW 0x0
03C8  6F83     MOVWF 0x83, BANKED
03CA  EC46     CALL 0x148C, 0
03CC  F00A     NOP
105:                       int threshold = 50;
03CE  0E00     MOVLW 0x0
03D0  0100     MOVLB 0x0
03D2  6F9D     MOVWF 0x9D, BANKED
03D4  0E32     MOVLW 0x32
03D6  6F9C     MOVWF threshold, BANKED
106:                       int diff = Values.left - Values.right;
03D8  EE20     LFSR 2, 0xA2
03DA  F0A2     NOP
03DC  CFDE     MOVFF POSTINC2, 0x95
03DE  F095     NOP
03E0  CFDD     MOVFF POSTDEC2, 0x96
03E2  F096     NOP
03E4  1F95     COMF 0x95, F, BANKED
03E6  1F96     COMF 0x96, F, BANKED
03E8  4B95     INFSNZ 0x95, F, BANKED
03EA  2B96     INCF 0x96, F, BANKED
03EC  51A0     MOVF Values, W, BANKED
03EE  2595     ADDWF 0x95, W, BANKED
03F0  6F9A     MOVWF diff, BANKED
03F2  51A1     MOVF 0xA1, W, BANKED
03F4  2196     ADDWFC 0x96, W, BANKED
03F6  6F9B     MOVWF 0x9B, BANKED
107:                       if (Values.left > 256 | Values.right > 256) {
03F8  05A0     DECF Values, W, BANKED
03FA  0E01     MOVLW 0x1
03FC  59A1     SUBWFB 0xA1, W, BANKED
03FE  B0D8     BTFSC STATUS, 0, ACCESS
0400  D005     BRA 0x40C
0402  05A2     DECF 0xA2, W, BANKED
0404  0E01     MOVLW 0x1
0406  59A3     SUBWFB 0xA3, W, BANKED
0408  A0D8     BTFSS STATUS, 0, ACCESS
040A  D004     BRA 0x414
108:                           threshold = 50;
040C  0E00     MOVLW 0x0
040E  6F9D     MOVWF 0x9D, BANKED
0410  0E32     MOVLW 0x32
0412  D003     BRA 0x41A
109:                       } else {
110:                           threshold = 10;
0414  0E00     MOVLW 0x0
0416  6F9D     MOVWF 0x9D, BANKED
0418  0E0A     MOVLW 0xA
041A  6F9C     MOVWF threshold, BANKED
111:                       }
112:           
113:                       if (diff < -threshold) {
041C  C09C     MOVFF threshold, 0x95
041E  F095     NOP
0420  C09D     MOVFF 0x9D, 0x96
0422  F096     NOP
0424  1F95     COMF 0x95, F, BANKED
0426  1F96     COMF 0x96, F, BANKED
0428  4B95     INFSNZ 0x95, F, BANKED
042A  2B96     INCF 0x96, F, BANKED
042C  5195     MOVF 0x95, W, BANKED
042E  5D9A     SUBWF diff, W, BANKED
0430  519B     MOVF 0x9B, W, BANKED
0432  0A80     XORLW 0x80
0434  6F97     MOVWF 0x97, BANKED
0436  5196     MOVF 0x96, W, BANKED
0438  0A80     XORLW 0x80
043A  5997     SUBWFB 0x97, W, BANKED
043C  B0D8     BTFSC STATUS, 0, ACCESS
043E  D026     BRA 0x48C
114:                           //if (direction != 1) {
115:                           stop(&mL, &mR);
0440  0EA8     MOVLW 0xA8
0442  6E1B     MOVWF mL, ACCESS
0444  0E00     MOVLW 0x0
0446  6E1C     MOVWF 0x1C, ACCESS
0448  0EB1     MOVLW 0xB1
044A  6E1D     MOVWF i, ACCESS
044C  0E00     MOVLW 0x0
044E  6E1E     MOVWF counter, ACCESS
0450  ECEB     CALL 0x19D6, 0
0452  F00C     NOP
116:                           turnLeft(&mL, &mR);
0454  0EA8     MOVLW 0xA8
0456  6E1B     MOVWF mL, ACCESS
0458  0E00     MOVLW 0x0
045A  6E1C     MOVWF 0x1C, ACCESS
045C  0EB1     MOVLW 0xB1
045E  6E1D     MOVWF i, ACCESS
0460  0E00     MOVLW 0x0
0462  6E1E     MOVWF counter, ACCESS
0464  EC99     CALL 0x1732, 0
0466  F00B     NOP
117:                           __delay_ms(TIME);
0468  0E02     MOVLW 0x2
046A  0100     MOVLB 0x0
046C  6F96     MOVWF 0x96, BANKED
046E  0E04     MOVLW 0x4
0470  6F95     MOVWF 0x95, BANKED
0472  0EBA     MOVLW 0xBA
0474  2EE8     DECFSZ WREG, F, ACCESS
0476  D7FE     BRA 0x474
0478  2F95     DECFSZ 0x95, F, BANKED
047A  D7FC     BRA 0x474
047C  2F96     DECFSZ 0x96, F, BANKED
047E  D7FA     BRA 0x474
0480  F000     NOP
118:                           //}
119:           
120:           
121:                           direction = 1;
0482  0E00     MOVLW 0x0
0484  0100     MOVLB 0x0
0486  6F9F     MOVWF 0x9F, BANKED
0488  0E01     MOVLW 0x1
048A  D04D     BRA 0x526
122:           
123:                       } else if (diff > threshold) {
048C  519A     MOVF diff, W, BANKED
048E  5D9C     SUBWF threshold, W, BANKED
0490  519D     MOVF 0x9D, W, BANKED
0492  0A80     XORLW 0x80
0494  6F95     MOVWF 0x95, BANKED
0496  519B     MOVF 0x9B, W, BANKED
0498  0A80     XORLW 0x80
049A  5995     SUBWFB 0x95, W, BANKED
049C  B0D8     BTFSC STATUS, 0, ACCESS
049E  D025     BRA 0x4EA
124:                           //if (direction != -1) {
125:                           stop(&mL, &mR);
04A0  0EA8     MOVLW 0xA8
04A2  6E1B     MOVWF mL, ACCESS
04A4  0E00     MOVLW 0x0
04A6  6E1C     MOVWF 0x1C, ACCESS
04A8  0EB1     MOVLW 0xB1
04AA  6E1D     MOVWF i, ACCESS
04AC  0E00     MOVLW 0x0
04AE  6E1E     MOVWF counter, ACCESS
04B0  ECEB     CALL 0x19D6, 0
04B2  F00C     NOP
126:                           turnRight(&mL, &mR);
04B4  0EA8     MOVLW 0xA8
04B6  6E1B     MOVWF mL, ACCESS
04B8  0E00     MOVLW 0x0
04BA  6E1C     MOVWF 0x1C, ACCESS
04BC  0EB1     MOVLW 0xB1
04BE  6E1D     MOVWF i, ACCESS
04C0  0E00     MOVLW 0x0
04C2  6E1E     MOVWF counter, ACCESS
04C4  EC4E     CALL 0x169C, 0
04C6  F00B     NOP
127:                           __delay_ms(TIME);
04C8  0E02     MOVLW 0x2
04CA  0100     MOVLB 0x0
04CC  6F96     MOVWF 0x96, BANKED
04CE  0E04     MOVLW 0x4
04D0  6F95     MOVWF 0x95, BANKED
04D2  0EBA     MOVLW 0xBA
04D4  2EE8     DECFSZ WREG, F, ACCESS
04D6  D7FE     BRA 0x4D4
04D8  2F95     DECFSZ 0x95, F, BANKED
04DA  D7FC     BRA 0x4D4
04DC  2F96     DECFSZ 0x96, F, BANKED
04DE  D7FA     BRA 0x4D4
04E0  F000     NOP
128:                           //}
129:           
130:                           direction = -1;
04E2  0100     MOVLB 0x0
04E4  699E     SETF direction, BANKED
04E6  699F     SETF 0x9F, BANKED
131:                       } else { //either forwards or signal lost
04E8  D048     BRA 0x57A
132:                           if ((Values.left > 150) && (Values.right > 150)) {
04EA  51A1     MOVF 0xA1, W, BANKED
04EC  E104     BNZ 0x4F6
04EE  0E97     MOVLW 0x97
04F0  5DA0     SUBWF Values, W, BANKED
04F2  A0D8     BTFSS STATUS, 0, ACCESS
04F4  D01A     BRA 0x52A
04F6  51A3     MOVF 0xA3, W, BANKED
04F8  E104     BNZ 0x502
04FA  0E97     MOVLW 0x97
04FC  5DA2     SUBWF 0xA2, W, BANKED
04FE  A0D8     BTFSS STATUS, 0, ACCESS
0500  D014     BRA 0x52A
133:                               if (direction != 0) {
0502  519E     MOVF direction, W, BANKED
0504  119F     IORWF 0x9F, W, BANKED
0506  B4D8     BTFSC STATUS, 2, ACCESS
0508  D00A     BRA 0x51E
134:                                   //stop(&mL, &mR);
135:                                   forwards(&mL, &mR);
050A  0EA8     MOVLW 0xA8
050C  6E1B     MOVWF mL, ACCESS
050E  0E00     MOVLW 0x0
0510  6E1C     MOVWF 0x1C, ACCESS
0512  0EB1     MOVLW 0xB1
0514  6E1D     MOVWF i, ACCESS
0516  0E00     MOVLW 0x0
0518  6E1E     MOVWF counter, ACCESS
051A  ECDD     CALL 0x11BA, 0
051C  F008     NOP
136:                                   //__delay_ms(TIME);
137:                               }
138:           
139:                               direction = 0;
051E  0E00     MOVLW 0x0
0520  0100     MOVLB 0x0
0522  6F9F     MOVWF 0x9F, BANKED
0524  0E00     MOVLW 0x0
0526  6F9E     MOVWF direction, BANKED
140:                           } else {
0528  D028     BRA 0x57A
141:                               if (direction != 1) {
052A  059E     DECF direction, W, BANKED
052C  119F     IORWF 0x9F, W, BANKED
052E  B4D8     BTFSC STATUS, 2, ACCESS
0530  D024     BRA 0x57A
142:           
143:                                   turnRight(&mL, &mR);
0532  0EA8     MOVLW 0xA8
0534  6E1B     MOVWF mL, ACCESS
0536  0E00     MOVLW 0x0
0538  6E1C     MOVWF 0x1C, ACCESS
053A  0EB1     MOVLW 0xB1
053C  6E1D     MOVWF i, ACCESS
053E  0E00     MOVLW 0x0
0540  6E1E     MOVWF counter, ACCESS
0542  EC4E     CALL 0x169C, 0
0544  F00B     NOP
144:                                   stop(&mL, &mR);
0546  0EA8     MOVLW 0xA8
0548  6E1B     MOVWF mL, ACCESS
054A  0E00     MOVLW 0x0
054C  6E1C     MOVWF 0x1C, ACCESS
054E  0EB1     MOVLW 0xB1
0550  6E1D     MOVWF i, ACCESS
0552  0E00     MOVLW 0x0
0554  6E1E     MOVWF counter, ACCESS
0556  ECEB     CALL 0x19D6, 0
0558  F00C     NOP
145:                                   direction = -1;
055A  0100     MOVLB 0x0
055C  699E     SETF direction, BANKED
055E  699F     SETF 0x9F, BANKED
146:                                   __delay_ms(TIME);
0560  0E02     MOVLW 0x2
0562  0100     MOVLB 0x0
0564  6F96     MOVWF 0x96, BANKED
0566  0E04     MOVLW 0x4
0568  6F95     MOVWF 0x95, BANKED
056A  0EBA     MOVLW 0xBA
056C  2EE8     DECFSZ WREG, F, ACCESS
056E  D7FE     BRA 0x56C
0570  2F95     DECFSZ 0x95, F, BANKED
0572  D7FC     BRA 0x56C
0574  2F96     DECFSZ 0x96, F, BANKED
0576  D7FA     BRA 0x56C
0578  F000     NOP
147:                               }
057A  0100     MOVLB 0x0
057C  51BF     MOVF card_read, W, BANKED
057E  B4D8     BTFSC STATUS, 2, ACCESS
0580  D719     BRA 0x3B4
148:           
149:           
150:                           }
151:                       }
152:                       //stop(&mL, &mR);
153:                       //            __delay_ms(100);
154:                   }
155:           
156:           
157:           
158:           
159:                   if (card_read == 1) { //the interrupt for the RFID tag sets card_read to 1 when the card is read
0582  05BF     DECF card_read, W, BANKED
0584  A4D8     BTFSS STATUS, 2, ACCESS
0586  D7CB     BRA 0x51E
160:                       stop(&mL, &mR);
0588  0EA8     MOVLW 0xA8
058A  6E1B     MOVWF mL, ACCESS
058C  0E00     MOVLW 0x0
058E  6E1C     MOVWF 0x1C, ACCESS
0590  0EB1     MOVLW 0xB1
0592  6E1D     MOVWF i, ACCESS
0594  0E00     MOVLW 0x0
0596  6E1E     MOVWF counter, ACCESS
0598  ECEB     CALL 0x19D6, 0
059A  F00C     NOP
161:                       print_RFID(&string_rfid[0], &string_rfid[0]); //sends the significant characters read from the RFID to the LCD
059C  0EE1     MOVLW 0xE1
059E  6E0B     MOVWF pa, ACCESS
05A0  0E00     MOVLW 0x0
05A2  6E0C     MOVWF dividend, ACCESS
05A4  0EE1     MOVLW 0xE1
05A6  6E0D     MOVWF dis, ACCESS
05A8  0E00     MOVLW 0x0
05AA  6E0E     MOVWF divisor, ACCESS
05AC  EC71     CALL 0x18E2, 0
05AE  F00C     NOP
162:                       __delay_ms(10);
05B0  0E1A     MOVLW 0x1A
05B2  0100     MOVLB 0x0
05B4  6F95     MOVWF 0x95, BANKED
05B6  0EF8     MOVLW 0xF8
05B8  2EE8     DECFSZ WREG, F, ACCESS
05BA  D7FE     BRA 0x5B8
05BC  2F95     DECFSZ 0x95, F, BANKED
05BE  D7FC     BRA 0x5B8
05C0  F000     NOP
163:                       //            return 0;
164:                   }
165:               }
05C2  D7AD     BRA 0x51E
166:           }
167:           
168:           
169:           
170:           
171:           
172:           
173:           
174:           
175:           
---  /Users/hasan/Box Sync/me4/ecm/lcd.c  ---------------------------------------------------------------
1:             #include "lcd.h"
2:             
3:             /*To toggle enable bit on then off*/
4:             void E_TOG(void) {
5:                 PORTCbits.RC0 = 1;
1D02  8082     BSF PORTC, 0, ACCESS
6:                 __delay_us(5);
1D04  0E03     MOVLW 0x3
1D06  2EE8     DECFSZ WREG, F, ACCESS
1D08  D7FE     BRA 0x1D06
1D0A  F000     NOP
7:                 PORTCbits.RC0 = 0;
1D0C  9082     BCF PORTC, 0, ACCESS
8:                 __delay_us(5);
1D0E  0E03     MOVLW 0x3
1D10  2EE8     DECFSZ WREG, F, ACCESS
1D12  D7FE     BRA 0x1D10
1D14  F000     NOP
9:             }
0008  825A     BSF btemp, 1, ACCESS
000A  CFD9     MOVFF FSR2, __pcstackCOMRAM
000C  F001     NOP
000E  CFDA     MOVFF FSR2H, 0x2
0010  F002     NOP
0012  CFF3     MOVFF PROD, 0x3
0014  F003     NOP
0016  CFF4     MOVFF PRODH, 0x4
0018  F004     NOP
1D16  0012     RETURN 0
10:            
11:            /*remake*/
12:            void time(int t) {
13:                for (int k = 0; k < t; k++) {
14:                    __delay_ms(90);
15:                }
16:            }
17:            
18:            /*To create 4-bit data stream to the LCD*/
19:            void LCD_out(unsigned char number)
195E  6E07     MOVWF number, ACCESS
20:             {
21:            
22:                PORTCbits.RC1 = (number & 0b0001);
1960  C007     MOVFF number, Values
1962  F006     NOP
1964  0E01     MOVLW 0x1
1966  1606     ANDWF Values, F, ACCESS
1968  4606     RLNCF Values, F, ACCESS
196A  5082     MOVF PORTC, W, ACCESS
196C  1806     XORWF Values, W, ACCESS
196E  0BFD     ANDLW 0xFD
1970  1806     XORWF Values, W, ACCESS
1972  6E82     MOVWF PORTC, ACCESS
23:                PORTCbits.RC2 = (number & 0b0010) >> 1;
1974  C007     MOVFF number, Values
1976  F006     NOP
1978  90D8     BCF STATUS, 0, ACCESS
197A  3206     RRCF Values, F, ACCESS
197C  0E01     MOVLW 0x1
197E  1606     ANDWF Values, F, ACCESS
1980  4606     RLNCF Values, F, ACCESS
1982  4606     RLNCF Values, F, ACCESS
1984  5082     MOVF PORTC, W, ACCESS
1986  1806     XORWF Values, W, ACCESS
1988  0BFB     ANDLW 0xFB
198A  1806     XORWF Values, W, ACCESS
198C  6E82     MOVWF PORTC, ACCESS
24:                PORTDbits.RD0 = (number & 0b0100) >> 2;
198E  C007     MOVFF number, Values
1990  F006     NOP
1992  90D8     BCF STATUS, 0, ACCESS
1994  3206     RRCF Values, F, ACCESS
1996  90D8     BCF STATUS, 0, ACCESS
1998  3206     RRCF Values, F, ACCESS
199A  0E01     MOVLW 0x1
199C  1606     ANDWF Values, F, ACCESS
199E  5083     MOVF PORTD, W, ACCESS
19A0  1806     XORWF Values, W, ACCESS
19A2  0BFE     ANDLW 0xFE
19A4  1806     XORWF Values, W, ACCESS
19A6  6E83     MOVWF PORTD, ACCESS
25:                PORTDbits.RD1 = (number & 0b1000) >> 3;
19A8  C007     MOVFF number, Values
19AA  F006     NOP
19AC  90D8     BCF STATUS, 0, ACCESS
19AE  3206     RRCF Values, F, ACCESS
19B0  90D8     BCF STATUS, 0, ACCESS
19B2  3206     RRCF Values, F, ACCESS
19B4  90D8     BCF STATUS, 0, ACCESS
19B6  3206     RRCF Values, F, ACCESS
19B8  0E01     MOVLW 0x1
19BA  1606     ANDWF Values, F, ACCESS
19BC  4606     RLNCF Values, F, ACCESS
19BE  5083     MOVF PORTD, W, ACCESS
19C0  1806     XORWF Values, W, ACCESS
19C2  0BFD     ANDLW 0xFD
19C4  1806     XORWF Values, W, ACCESS
19C6  6E83     MOVWF PORTD, ACCESS
26:                //toggle the enable bit to send data
27:                E_TOG();
19C8  EC81     CALL 0x1D02, 0
19CA  F00E     NOP
28:                __delay_us(5);
19CC  0E03     MOVLW 0x3
19CE  2EE8     DECFSZ WREG, F, ACCESS
19D0  D7FE     BRA 0x19CE
19D2  F000     NOP
29:            }
19D4  0012     RETURN 0
30:            
31:            /*
32:             * function to send data over 4 bit interface
33:             */
34:            void LCD_send(unsigned char Byte, char type) {
1C00  6E09     MOVWF Byte, ACCESS
35:                // set RS pin whether it is a Command (0) or Data/Char (1)
36:                // using type as the argument
37:                /*TODO needs to be redone, no need for command anymore*/
38:                PORTAbits.RA6 = type;
1C02  B008     BTFSC type, 0, ACCESS
1C04  D002     BRA 0x1C0A
1C06  9C80     BCF PORTA, 6, ACCESS
1C08  D001     BRA 0x1C0C
1C0A  8C80     BSF PORTA, 6, ACCESS
39:            
40:                // send high bits of Byte using LCDout function
41:                LCD_out(Byte >> 4);
1C0C  3809     SWAPF Byte, W, ACCESS
1C0E  0B0F     ANDLW 0xF
1C10  ECAF     CALL 0x195E, 0
1C12  F00C     NOP
42:                __delay_us(10); //10us delay
1C14  0E06     MOVLW 0x6
1C16  2EE8     DECFSZ WREG, F, ACCESS
1C18  D7FE     BRA 0x1C16
1C1A  D000     BRA 0x1C1C
43:                // send low bits of Byte using LCDout function
44:                LCD_out(Byte);
1C1C  5009     MOVF Byte, W, ACCESS
1C1E  ECAF     CALL 0x195E, 0
1C20  F00C     NOP
45:                __delay_us(50);
1C22  0E21     MOVLW 0x21
1C24  2EE8     DECFSZ WREG, F, ACCESS
1C26  D7FE     BRA 0x1C24
1C28  F000     NOP
46:            
47:            }
1C2A  0012     RETURN 0
48:            
49:            void LCD_init(void) {
50:            
51:                /* Configuring the outputs, else unknown*/
52:                LATA = 0;
12D4  0E00     MOVLW 0x0
12D6  6E89     MOVWF LATA, ACCESS
53:                LATC = 0;
12D8  0E00     MOVLW 0x0
12DA  6E8B     MOVWF LATC, ACCESS
54:                LATD = 0;
12DC  0E00     MOVLW 0x0
12DE  6E8C     MOVWF LATD, ACCESS
55:            
56:                /*Initialise pins for LCD from PIC, TODO redo and move LCD*/
57:                TRISA = 0;
12E0  0E00     MOVLW 0x0
12E2  6E92     MOVWF TRISA, ACCESS
58:                TRISC = 0; //set the data direction registers to output on all pins
12E4  0E00     MOVLW 0x0
12E6  6E94     MOVWF TRISC, ACCESS
59:                TRISD = 0;
12E8  0E00     MOVLW 0x0
12EA  6E95     MOVWF TRISD, ACCESS
60:            
61:            
62:                /*Initialisation sequence, page TODO of datasheet*/
63:                __delay_ms(15);
12EC  0E27     MOVLW 0x27
12EE  6E0A     MOVWF string, ACCESS
12F0  0EF5     MOVLW 0xF5
12F2  2EE8     DECFSZ WREG, F, ACCESS
12F4  D7FE     BRA 0x12F2
12F6  2E0A     DECFSZ string, F, ACCESS
12F8  D7FC     BRA 0x12F2
12FA  F000     NOP
64:                LCD_out(0b0011);
12FC  0E03     MOVLW 0x3
12FE  ECAF     CALL 0x195E, 0
1300  F00C     NOP
65:                __delay_ms(5);
1302  0E0D     MOVLW 0xD
1304  6E0A     MOVWF string, ACCESS
1306  0EFC     MOVLW 0xFC
1308  2EE8     DECFSZ WREG, F, ACCESS
130A  D7FE     BRA 0x1308
130C  2E0A     DECFSZ string, F, ACCESS
130E  D7FC     BRA 0x1308
66:                LCD_out(0b0011);
1310  0E03     MOVLW 0x3
1312  ECAF     CALL 0x195E, 0
1314  F00C     NOP
67:                __delay_us(200);
1316  0E85     MOVLW 0x85
1318  2EE8     DECFSZ WREG, F, ACCESS
131A  D7FE     BRA 0x1318
131C  F000     NOP
68:                LCD_out(0b0011);
131E  0E03     MOVLW 0x3
1320  ECAF     CALL 0x195E, 0
1322  F00C     NOP
69:                __delay_us(50);
1324  0E21     MOVLW 0x21
1326  2EE8     DECFSZ WREG, F, ACCESS
1328  D7FE     BRA 0x1326
132A  F000     NOP
70:                LCD_out(0b0010);
132C  0E02     MOVLW 0x2
132E  ECAF     CALL 0x195E, 0
1330  F00C     NOP
71:                __delay_us(50);
1332  0E21     MOVLW 0x21
1334  2EE8     DECFSZ WREG, F, ACCESS
1336  D7FE     BRA 0x1334
1338  F000     NOP
72:            
73:                LCD_send(0b00101000, 0); /*4 bit mode, 2 line, 5 x 7 grid*/
133A  0E00     MOVLW 0x0
133C  6E08     MOVWF type, ACCESS
133E  0E28     MOVLW 0x28
1340  EC00     CALL 0x1C00, 0
1342  F00E     NOP
74:                __delay_ms(2);
1344  0E06     MOVLW 0x6
1346  6E0A     MOVWF string, ACCESS
1348  0E30     MOVLW 0x30
134A  2EE8     DECFSZ WREG, F, ACCESS
134C  D7FE     BRA 0x134A
134E  2E0A     DECFSZ string, F, ACCESS
1350  D7FC     BRA 0x134A
1352  D000     BRA 0x1354
75:                LCD_send(0b00001000, 0);
1354  0E00     MOVLW 0x0
1356  6E08     MOVWF type, ACCESS
1358  0E08     MOVLW 0x8
135A  EC00     CALL 0x1C00, 0
135C  F00E     NOP
76:                __delay_ms(2);
135E  0E06     MOVLW 0x6
1360  6E0A     MOVWF string, ACCESS
1362  0E30     MOVLW 0x30
1364  2EE8     DECFSZ WREG, F, ACCESS
1366  D7FE     BRA 0x1364
1368  2E0A     DECFSZ string, F, ACCESS
136A  D7FC     BRA 0x1364
136C  D000     BRA 0x136E
77:                LCD_send(0b00000001, 0);
136E  0E00     MOVLW 0x0
1370  6E08     MOVWF type, ACCESS
1372  0E01     MOVLW 0x1
1374  EC00     CALL 0x1C00, 0
1376  F00E     NOP
78:                __delay_ms(2);
1378  0E06     MOVLW 0x6
137A  6E0A     MOVWF string, ACCESS
137C  0E30     MOVLW 0x30
137E  2EE8     DECFSZ WREG, F, ACCESS
1380  D7FE     BRA 0x137E
1382  2E0A     DECFSZ string, F, ACCESS
1384  D7FC     BRA 0x137E
1386  D000     BRA 0x1388
79:                LCD_send(0b00000110, 0);
1388  0E00     MOVLW 0x0
138A  6E08     MOVWF type, ACCESS
138C  0E06     MOVLW 0x6
138E  EC00     CALL 0x1C00, 0
1390  F00E     NOP
80:                __delay_ms(2);
1392  0E06     MOVLW 0x6
1394  6E0A     MOVWF string, ACCESS
1396  0E30     MOVLW 0x30
1398  2EE8     DECFSZ WREG, F, ACCESS
139A  D7FE     BRA 0x1398
139C  2E0A     DECFSZ string, F, ACCESS
139E  D7FC     BRA 0x1398
13A0  D000     BRA 0x13A2
81:                LCD_send(0b00001100, 0);
13A2  0E00     MOVLW 0x0
13A4  6E08     MOVWF type, ACCESS
13A6  0E0C     MOVLW 0xC
13A8  EC00     CALL 0x1C00, 0
13AA  F00E     NOP
82:                __delay_ms(2);
13AC  0E06     MOVLW 0x6
13AE  6E0A     MOVWF string, ACCESS
13B0  0E30     MOVLW 0x30
13B2  2EE8     DECFSZ WREG, F, ACCESS
13B4  D7FE     BRA 0x13B2
13B6  2E0A     DECFSZ string, F, ACCESS
13B8  D7FC     BRA 0x13B2
13BA  D000     BRA 0x13BC
83:            
84:            }
13BC  0012     RETURN 0
85:            
86:            /*
87:             * To set cursor to correct line (of two)
88:             */
89:            void LCD_line(char line) {
1BD0  6E0A     MOVWF string, ACCESS
90:                if (line == 1) {
1BD2  040A     DECF string, W, ACCESS
1BD4  A4D8     BTFSS STATUS, 2, ACCESS
1BD6  D006     BRA 0x1BE4
91:                    LCD_send(0x80, 0); /*DDRAM address for line 1*/
1BD8  0E00     MOVLW 0x0
1BDA  6E08     MOVWF type, ACCESS
1BDC  0E80     MOVLW 0x80
1BDE  EC00     CALL 0x1C00, 0
1BE0  F00E     NOP
92:                } else if (line == 2) {
1BE2  D009     BRA 0x1BF6
1BE4  0E02     MOVLW 0x2
1BE6  180A     XORWF string, W, ACCESS
1BE8  A4D8     BTFSS STATUS, 2, ACCESS
1BEA  D005     BRA 0x1BF6
93:                    LCD_send(0xC0, 0);
1BEC  0E00     MOVLW 0x0
1BEE  6E08     MOVWF type, ACCESS
1BF0  0EC0     MOVLW 0xC0
1BF2  EC00     CALL 0x1C00, 0
1BF4  F00E     NOP
94:                }
95:                __delay_us(50); //50us delay
1BF6  0E21     MOVLW 0x21
1BF8  2EE8     DECFSZ WREG, F, ACCESS
1BFA  D7FE     BRA 0x1BF8
1BFC  F000     NOP
96:            }
1BFE  0012     RETURN 0
97:            
98:            /*
99:             * To print character by character to screen
100:            */
101:           void LCD_string(char *string) {
102:               while (*string != 0) {
1BA0  D00F     BRA 0x1BC0
103:                   //Send out the current byte pointed to
104:                   //and increment the pointer
105:                   LCD_send(*string++, 1);
1BA2  0E01     MOVLW 0x1
1BA4  6E08     MOVWF type, ACCESS
1BA6  C00A     MOVFF string, FSR2
1BA8  FFD9     NOP
1BAA  C00B     MOVFF pa, FSR2H
1BAC  FFDA     NOP
1BAE  50DF     MOVF INDF2, W, ACCESS
1BB0  EC00     CALL 0x1C00, 0
1BB2  F00E     NOP
1BB4  4A0A     INFSNZ string, F, ACCESS
1BB6  2A0B     INCF pa, F, ACCESS
106:                   __delay_us(50); //so we can see each character
1BB8  0E21     MOVLW 0x21
1BBA  2EE8     DECFSZ WREG, F, ACCESS
1BBC  D7FE     BRA 0x1BBA
1BBE  F000     NOP
107:                   //being printed in turn (remove delay if you want
108:                   //your message to appear almost instantly)
109:               }
1BC0  C00A     MOVFF string, FSR2
1BC2  FFD9     NOP
1BC4  C00B     MOVFF pa, FSR2H
1BC6  FFDA     NOP
1BC8  50DF     MOVF INDF2, W, ACCESS
1BCA  B4D8     BTFSC STATUS, 2, ACCESS
1BCC  0012     RETURN 0
1BCE  D7E9     BRA 0x1BA2
110:           }
111:           
112:           /*
113:            * To clear LCD
114:            */
115:           void LCD_clear(void) {
116:               LCD_send(0b00000001, 0);
1C98  0E00     MOVLW 0x0
1C9A  6E08     MOVWF type, ACCESS
1C9C  0E01     MOVLW 0x1
1C9E  EC00     CALL 0x1C00, 0
1CA0  F00E     NOP
117:               __delay_ms(2);
1CA2  0E06     MOVLW 0x6
1CA4  6E0A     MOVWF string, ACCESS
1CA6  0E30     MOVLW 0x30
1CA8  2EE8     DECFSZ WREG, F, ACCESS
1CAA  D7FE     BRA 0x1CA8
1CAC  2E0A     DECFSZ string, F, ACCESS
1CAE  D7FC     BRA 0x1CA8
1CB0  D000     BRA 0x1CB2
118:           }
1CB2  0012     RETURN 0
119:           
120:           /*
121:            * To print IR values to LCD
122:            */
123:           void print_IR(struct Sensor_ir *Values) {
124:               LCD_clear();
148C  EC4C     CALL 0x1C98, 0
148E  F00E     NOP
125:               char buf[16];
126:               LCD_line(1);
1490  0E01     MOVLW 0x1
1492  ECE8     CALL 0x1BD0, 0
1494  F00D     NOP
127:               sprintf(buf, "Left: %u", Values->left);
1496  0E85     MOVLW 0x85
1498  0100     MOVLB 0x0
149A  6F72     MOVWF s, BANKED
149C  0E00     MOVLW 0x0
149E  6F73     MOVWF 0x73, BANKED
14A0  0E29     MOVLW 0x29
14A2  6F74     MOVWF fmt, BANKED
14A4  0E03     MOVLW 0x3
14A6  6F75     MOVWF 0x75, BANKED
14A8  C082     MOVFF Values, FSR2
14AA  FFD9     NOP
14AC  C083     MOVFF 0x83, FSR2H
14AE  FFDA     NOP
14B0  CFDE     MOVFF POSTINC2, 0x76
14B2  F076     NOP
14B4  CFDD     MOVFF POSTDEC2, 0x77
14B6  F077     NOP
14B8  EC26     CALL 0x1A4C, 0
14BA  F00D     NOP
128:               LCD_string(buf);
14BC  0E85     MOVLW 0x85
14BE  6E0A     MOVWF string, ACCESS
14C0  0E00     MOVLW 0x0
14C2  6E0B     MOVWF pa, ACCESS
14C4  ECD0     CALL 0x1BA0, 0
14C6  F00D     NOP
129:               LCD_line(2);
14C8  0E02     MOVLW 0x2
14CA  ECE8     CALL 0x1BD0, 0
14CC  F00D     NOP
130:               sprintf(buf, "Right: %u", Values->right);
14CE  0E85     MOVLW 0x85
14D0  0100     MOVLB 0x0
14D2  6F72     MOVWF s, BANKED
14D4  0E00     MOVLW 0x0
14D6  6F73     MOVWF 0x73, BANKED
14D8  0E1F     MOVLW 0x1F
14DA  6F74     MOVWF fmt, BANKED
14DC  0E03     MOVLW 0x3
14DE  6F75     MOVWF 0x75, BANKED
14E0  EE20     LFSR 2, 0x2
14E2  F002     NOP
14E4  5182     MOVF Values, W, BANKED
14E6  26D9     ADDWF FSR2, F, ACCESS
14E8  5183     MOVF 0x83, W, BANKED
14EA  22DA     ADDWFC FSR2H, F, ACCESS
14EC  CFDE     MOVFF POSTINC2, 0x76
14EE  F076     NOP
14F0  CFDD     MOVFF POSTDEC2, 0x77
14F2  F077     NOP
14F4  EC26     CALL 0x1A4C, 0
14F6  F00D     NOP
131:               LCD_string(buf);
14F8  0E85     MOVLW 0x85
14FA  6E0A     MOVWF string, ACCESS
14FC  0E00     MOVLW 0x0
14FE  6E0B     MOVWF pa, ACCESS
1500  ECD0     CALL 0x1BA0, 0
1502  F00D     NOP
132:               __delay_ms(50);
1504  0E82     MOVLW 0x82
1506  0100     MOVLB 0x0
1508  6F84     MOVWF 0x84, BANKED
150A  0EDD     MOVLW 0xDD
150C  2EE8     DECFSZ WREG, F, ACCESS
150E  D7FE     BRA 0x150C
1510  2F84     DECFSZ 0x84, F, BANKED
1512  D7FC     BRA 0x150C
1514  D000     BRA 0x1516
133:               __delay_ms(50);
1516  0E82     MOVLW 0x82
1518  0100     MOVLB 0x0
151A  6F84     MOVWF 0x84, BANKED
151C  0EDD     MOVLW 0xDD
151E  2EE8     DECFSZ WREG, F, ACCESS
1520  D7FE     BRA 0x151E
1522  2F84     DECFSZ 0x84, F, BANKED
1524  D7FC     BRA 0x151E
1526  D000     BRA 0x1528
134:               __delay_ms(50);
1528  0E82     MOVLW 0x82
152A  0100     MOVLB 0x0
152C  6F84     MOVWF 0x84, BANKED
152E  0EDD     MOVLW 0xDD
1530  2EE8     DECFSZ WREG, F, ACCESS
1532  D7FE     BRA 0x1530
1534  2F84     DECFSZ 0x84, F, BANKED
1536  D7FC     BRA 0x1530
1538  D000     BRA 0x153A
135:               __delay_ms(50);
153A  0E82     MOVLW 0x82
153C  0100     MOVLB 0x0
153E  6F84     MOVWF 0x84, BANKED
1540  0EDD     MOVLW 0xDD
1542  2EE8     DECFSZ WREG, F, ACCESS
1544  D7FE     BRA 0x1542
1546  2F84     DECFSZ 0x84, F, BANKED
1548  D7FC     BRA 0x1542
154A  D000     BRA 0x154C
136:           
137:           }
154C  0012     RETURN 0
---  /Users/hasan/Box Sync/me4/ecm/ir.c  ----------------------------------------------------------------
1:             #include "ir.h"
2:             
3:             /*
4:              * Timer 5 for input capture, initialisation
5:              */
6:             void init_TIMER5(void) {
7:                 /*need to reset TMR5
8:                  *see page 139
9:                  */
10:            
11:                T5CON = 0;
1CCE  0E00     MOVLW 0x0
1CD0  6EB7     MOVWF T5CON, ACCESS
12:                T5CONbits.T5SEN = 0; /*disable during sleep            */
1CD2  9EB7     BCF T5CON, 7, ACCESS
13:                T5CONbits.RESEN = 0; /*disable special event trigger   */
1CD4  9CB7     BCF T5CON, 6, ACCESS
14:                T5CONbits.T5PS = 0b10; /*prescale, unsure TODO           */
1CD6  50B7     MOVF T5CON, W, ACCESS
1CD8  0BE7     ANDLW 0xE7
1CDA  0910     IORLW 0x10
1CDC  6EB7     MOVWF T5CON, ACCESS
15:                T5CONbits.T5MOD = 0; /*prescale, unsure TODO           */
1CDE  9AB7     BCF T5CON, 5, ACCESS
16:                T5CONbits.T5SYNC = 0; /*continuous count                */
1CE0  94B7     BCF T5CON, 2, ACCESS
17:                T5CONbits.TMR5CS = 0; /*internal clock                  */
1CE2  92B7     BCF T5CON, 1, ACCESS
18:                T5CONbits.TMR5ON = 1; /*turn on                         */
1CE4  80B7     BSF T5CON, 0, ACCESS
19:            
20:            }
1CE6  0012     RETURN 0
21:            
22:            /*
23:             * Detect falling edge to rising edge from IR detector
24:             */
25:            void init_capture(void) {
26:            
27:                LATA = 0; //Tensure all pins have same value initially
1CB4  0E00     MOVLW 0x0
1CB6  6E89     MOVWF LATA, ACCESS
28:                TRISA = 0b00001100; //Turn on CAP1 (RA2) and CAP2 (RA3) Pins.
1CB8  0E0C     MOVLW 0xC
1CBA  6E92     MOVWF TRISA, ACCESS
29:                CAP1CON = 0b01000110; //Time base enabled, measure PWM falling to rising 
1CBC  0E46     MOVLW 0x46
1CBE  6E63     MOVWF CAP1CON, ACCESS
30:                CAP2CON = 0b01000110;
1CC0  0E46     MOVLW 0x46
1CC2  6E62     MOVWF CAP2CON, ACCESS
31:                T5CON = 0b00001001; //Timer 5 prescaler 1:2, Timer on (overflow 65.536ms - max PWM is 50ms)
1CC4  0E09     MOVLW 0x9
1CC6  6EB7     MOVWF T5CON, ACCESS
32:                DFLTCON = 0b00011000; //Noise filter for CAP1 and CAP2 
1CC8  0E18     MOVLW 0x18
1CCA  6E60     MOVWF DFLTCON, ACCESS
33:            }
1CCC  0012     RETURN 0
34:            
35:            /*
36:             * Printing IR signal
37:             */
38:            void read_IR(struct Sensor_ir *Values) {
39:                Values->left_prev = Values->left;
0A36  C006     MOVFF Values, FSR2
0A38  FFD9     NOP
0A3A  C007     MOVFF number, FSR2H
0A3C  FFDA     NOP
0A3E  EE10     LFSR 1, 0x4
0A40  F004     NOP
0A42  5006     MOVF Values, W, ACCESS
0A44  26E1     ADDWF FSR1, F, ACCESS
0A46  5007     MOVF number, W, ACCESS
0A48  22E2     ADDWFC FSR1H, F, ACCESS
0A4A  CFDE     MOVFF POSTINC2, POSTINC1
0A4C  FFE6     NOP
0A4E  CFDD     MOVFF POSTDEC2, POSTDEC1
0A50  FFE5     NOP
40:                Values->right_prev = Values->right;
0A52  EE20     LFSR 2, 0x2
0A54  F002     NOP
0A56  5006     MOVF Values, W, ACCESS
0A58  26D9     ADDWF FSR2, F, ACCESS
0A5A  5007     MOVF number, W, ACCESS
0A5C  22DA     ADDWFC FSR2H, F, ACCESS
0A5E  EE10     LFSR 1, 0x6
0A60  F006     NOP
0A62  5006     MOVF Values, W, ACCESS
0A64  26E1     ADDWF FSR1, F, ACCESS
0A66  5007     MOVF number, W, ACCESS
0A68  22E2     ADDWFC FSR1H, F, ACCESS
0A6A  CFDE     MOVFF POSTINC2, POSTINC1
0A6C  FFE6     NOP
0A6E  CFDD     MOVFF POSTDEC2, POSTDEC1
0A70  FFE5     NOP
41:                Values->left = ((CAP2BUFH << 8) | (CAP2BUFL)); //left is cap2, i.e. lower
0A72  5066     MOVF CAP2BUFL, W, ACCESS
0A74  CF67     MOVFF CAP2BUFH, type
0A76  F008     NOP
0A78  6A09     CLRF Byte, ACCESS
0A7A  C008     MOVFF type, Byte
0A7C  F009     NOP
0A7E  6A08     CLRF type, ACCESS
0A80  1208     IORWF type, F, ACCESS
0A82  0E00     MOVLW 0x0
0A84  1209     IORWF Byte, F, ACCESS
0A86  C006     MOVFF Values, FSR2
0A88  FFD9     NOP
0A8A  C007     MOVFF number, FSR2H
0A8C  FFDA     NOP
0A8E  C008     MOVFF type, POSTINC2
0A90  FFDE     NOP
0A92  C009     MOVFF Byte, POSTDEC2
0A94  FFDD     NOP
42:                Values->right = ((CAP1BUFH << 8) | (CAP1BUFL));
0A96  5068     MOVF CAP1BUFL, W, ACCESS
0A98  CF69     MOVFF CAP1BUFH, type
0A9A  F008     NOP
0A9C  6A09     CLRF Byte, ACCESS
0A9E  C008     MOVFF type, Byte
0AA0  F009     NOP
0AA2  6A08     CLRF type, ACCESS
0AA4  1208     IORWF type, F, ACCESS
0AA6  0E00     MOVLW 0x0
0AA8  1209     IORWF Byte, F, ACCESS
0AAA  EE20     LFSR 2, 0x2
0AAC  F002     NOP
0AAE  5006     MOVF Values, W, ACCESS
0AB0  26D9     ADDWF FSR2, F, ACCESS
0AB2  5007     MOVF number, W, ACCESS
0AB4  22DA     ADDWFC FSR2H, F, ACCESS
0AB6  C008     MOVFF type, POSTINC2
0AB8  FFDE     NOP
0ABA  C009     MOVFF Byte, POSTDEC2
0ABC  FFDD     NOP
43:            
44:                if ((Values->left == Values->left_prev) && (Values->left <= 200)) {
0ABE  EE20     LFSR 2, 0x4
0AC0  F004     NOP
0AC2  5006     MOVF Values, W, ACCESS
0AC4  26D9     ADDWF FSR2, F, ACCESS
0AC6  5007     MOVF number, W, ACCESS
0AC8  22DA     ADDWFC FSR2H, F, ACCESS
0ACA  C006     MOVFF Values, FSR1
0ACC  FFE1     NOP
0ACE  C007     MOVFF number, FSR1H
0AD0  FFE2     NOP
0AD2  50DE     MOVF POSTINC2, W, ACCESS
0AD4  18E6     XORWF POSTINC1, W, ACCESS
0AD6  E117     BNZ 0xB06
0AD8  50DE     MOVF POSTINC2, W, ACCESS
0ADA  18E6     XORWF POSTINC1, W, ACCESS
0ADC  A4D8     BTFSS STATUS, 2, ACCESS
0ADE  D013     BRA 0xB06
0AE0  C006     MOVFF Values, FSR2
0AE2  FFD9     NOP
0AE4  C007     MOVFF number, FSR2H
0AE6  FFDA     NOP
0AE8  0E01     MOVLW 0x1
0AEA  50DB     MOVF PLUSW2, W, ACCESS
0AEC  E10C     BNZ 0xB06
0AEE  0EC9     MOVLW 0xC9
0AF0  5CDE     SUBWF POSTINC2, W, ACCESS
0AF2  B0D8     BTFSC STATUS, 0, ACCESS
0AF4  D008     BRA 0xB06
45:                    Values->left = 0;
0AF6  C006     MOVFF Values, FSR2
0AF8  FFD9     NOP
0AFA  C007     MOVFF number, FSR2H
0AFC  FFDA     NOP
0AFE  0E00     MOVLW 0x0
0B00  6EDE     MOVWF POSTINC2, ACCESS
0B02  0E00     MOVLW 0x0
0B04  6EDD     MOVWF POSTDEC2, ACCESS
46:                }
47:            
48:                if ((Values->right == Values->right_prev) && (Values->right <= 200)) {
0B06  EE20     LFSR 2, 0x6
0B08  F006     NOP
0B0A  5006     MOVF Values, W, ACCESS
0B0C  26D9     ADDWF FSR2, F, ACCESS
0B0E  5007     MOVF number, W, ACCESS
0B10  22DA     ADDWFC FSR2H, F, ACCESS
0B12  EE10     LFSR 1, 0x2
0B14  F002     NOP
0B16  5006     MOVF Values, W, ACCESS
0B18  26E1     ADDWF FSR1, F, ACCESS
0B1A  5007     MOVF number, W, ACCESS
0B1C  22E2     ADDWFC FSR1H, F, ACCESS
0B1E  50DE     MOVF POSTINC2, W, ACCESS
0B20  18E6     XORWF POSTINC1, W, ACCESS
0B22  E11B     BNZ 0xB5A
0B24  50DE     MOVF POSTINC2, W, ACCESS
0B26  18E6     XORWF POSTINC1, W, ACCESS
0B28  A4D8     BTFSS STATUS, 2, ACCESS
0B2A  D017     BRA 0xB5A
0B2C  EE20     LFSR 2, 0x2
0B2E  F002     NOP
0B30  5006     MOVF Values, W, ACCESS
0B32  26D9     ADDWF FSR2, F, ACCESS
0B34  5007     MOVF number, W, ACCESS
0B36  22DA     ADDWFC FSR2H, F, ACCESS
0B38  0E01     MOVLW 0x1
0B3A  50DB     MOVF PLUSW2, W, ACCESS
0B3C  E10E     BNZ 0xB5A
0B3E  0EC9     MOVLW 0xC9
0B40  5CDE     SUBWF POSTINC2, W, ACCESS
0B42  B0D8     BTFSC STATUS, 0, ACCESS
0B44  D00A     BRA 0xB5A
49:                    Values->right = 0;
0B46  EE20     LFSR 2, 0x2
0B48  F002     NOP
0B4A  5006     MOVF Values, W, ACCESS
0B4C  26D9     ADDWF FSR2, F, ACCESS
0B4E  5007     MOVF number, W, ACCESS
0B50  22DA     ADDWFC FSR2H, F, ACCESS
0B52  0E00     MOVLW 0x0
0B54  6EDE     MOVWF POSTINC2, ACCESS
0B56  0E00     MOVLW 0x0
0B58  6EDD     MOVWF POSTDEC2, ACCESS
50:                }
51:            
52:                Values->left = Values->left / 64;
0B5A  C006     MOVFF Values, FSR2
0B5C  FFD9     NOP
0B5E  C007     MOVFF number, FSR2H
0B60  FFDA     NOP
0B62  CFDE     MOVFF POSTINC2, type
0B64  F008     NOP
0B66  CFDD     MOVFF POSTDEC2, Byte
0B68  F009     NOP
0B6A  0E06     MOVLW 0x6
0B6C  6E0A     MOVWF string, ACCESS
0B6E  90D8     BCF STATUS, 0, ACCESS
0B70  3209     RRCF Byte, F, ACCESS
0B72  3208     RRCF type, F, ACCESS
0B74  2E0A     DECFSZ string, F, ACCESS
0B76  D7FB     BRA 0xB6E
0B78  C006     MOVFF Values, FSR2
0B7A  FFD9     NOP
0B7C  C007     MOVFF number, FSR2H
0B7E  FFDA     NOP
0B80  C008     MOVFF type, POSTINC2
0B82  FFDE     NOP
0B84  C009     MOVFF Byte, POSTDEC2
0B86  FFDD     NOP
53:                if (Values->left > 200) {
0B88  C006     MOVFF Values, FSR2
0B8A  FFD9     NOP
0B8C  C007     MOVFF number, FSR2H
0B8E  FFDA     NOP
0B90  0E01     MOVLW 0x1
0B92  50DB     MOVF PLUSW2, W, ACCESS
0B94  E104     BNZ 0xB9E
0B96  0EC9     MOVLW 0xC9
0B98  5CDE     SUBWF POSTINC2, W, ACCESS
0B9A  A0D8     BTFSS STATUS, 0, ACCESS
0B9C  D008     BRA 0xBAE
54:                    Values->left = 200;
0B9E  C006     MOVFF Values, FSR2
0BA0  FFD9     NOP
0BA2  C007     MOVFF number, FSR2H
0BA4  FFDA     NOP
0BA6  0EC8     MOVLW 0xC8
0BA8  6EDE     MOVWF POSTINC2, ACCESS
0BAA  0E00     MOVLW 0x0
0BAC  6EDD     MOVWF POSTDEC2, ACCESS
55:                } //reduce un-required noise above 200
56:            
57:                Values->right = Values->right / 64;
0BAE  EE20     LFSR 2, 0x2
0BB0  F002     NOP
0BB2  5006     MOVF Values, W, ACCESS
0BB4  26D9     ADDWF FSR2, F, ACCESS
0BB6  5007     MOVF number, W, ACCESS
0BB8  22DA     ADDWFC FSR2H, F, ACCESS
0BBA  CFDE     MOVFF POSTINC2, type
0BBC  F008     NOP
0BBE  CFDD     MOVFF POSTDEC2, Byte
0BC0  F009     NOP
0BC2  0E06     MOVLW 0x6
0BC4  6E0A     MOVWF string, ACCESS
0BC6  90D8     BCF STATUS, 0, ACCESS
0BC8  3209     RRCF Byte, F, ACCESS
0BCA  3208     RRCF type, F, ACCESS
0BCC  2E0A     DECFSZ string, F, ACCESS
0BCE  D7FB     BRA 0xBC6
0BD0  EE20     LFSR 2, 0x2
0BD2  F002     NOP
0BD4  5006     MOVF Values, W, ACCESS
0BD6  26D9     ADDWF FSR2, F, ACCESS
0BD8  5007     MOVF number, W, ACCESS
0BDA  22DA     ADDWFC FSR2H, F, ACCESS
0BDC  C008     MOVFF type, POSTINC2
0BDE  FFDE     NOP
0BE0  C009     MOVFF Byte, POSTDEC2
0BE2  FFDD     NOP
58:                if (Values->right > 200) {
0BE4  EE20     LFSR 2, 0x2
0BE6  F002     NOP
0BE8  5006     MOVF Values, W, ACCESS
0BEA  26D9     ADDWF FSR2, F, ACCESS
0BEC  5007     MOVF number, W, ACCESS
0BEE  22DA     ADDWFC FSR2H, F, ACCESS
0BF0  0E01     MOVLW 0x1
0BF2  50DB     MOVF PLUSW2, W, ACCESS
0BF4  E104     BNZ 0xBFE
0BF6  0EC9     MOVLW 0xC9
0BF8  5CDE     SUBWF POSTINC2, W, ACCESS
0BFA  A0D8     BTFSS STATUS, 0, ACCESS
0BFC  0012     RETURN 0
59:                    Values->right = 200;
0BFE  EE20     LFSR 2, 0x2
0C00  F002     NOP
0C02  5006     MOVF Values, W, ACCESS
0C04  26D9     ADDWF FSR2, F, ACCESS
0C06  5007     MOVF number, W, ACCESS
0C08  22DA     ADDWFC FSR2H, F, ACCESS
0C0A  0EC8     MOVLW 0xC8
0C0C  6EDE     MOVWF POSTINC2, ACCESS
0C0E  0E00     MOVLW 0x0
0C10  6EDD     MOVWF POSTDEC2, ACCESS
0C12  0012     RETURN 0
60:                } //reduce un-required noise above 200
61:            
62:                // __delay_ms(50);
63:                //    if ((Values->left_prev = Values->left) && (Values->left < 50)) 
64:                //        {
65:                //            Values->left = 0;
66:                //        }
67:                //    if ((Values->right_prev = Values->right) && (Values->right < 50)) {
68:                //            {
69:                //                Values->right = 0;
70:                //            }
71:            
72:                //        }
73:            }
74:            
75:            //int measureIRLeft(void)
76:            //{
77:            //    // Initialise IR level variable
78:            //    // ----------------------------------------------------------------------
79:            //    unsigned int IRlevel = 0;
80:            //
81:            //    // Take a predetermined number of readings, and sum the results
82:            //    // ----------------------------------------------------------------------
83:            //    for (char i = 0; i < 2; i++)
84:            //    {
85:            //         IRlevel += CAP1BUFL;  // Get the 8 bit LSB result
86:            //         IRlevel += ((unsigned int)CAP1BUFH << 8); // Get 2 bit MSB result
87:            //         __delay_ms(50);
88:            //    }
89:            //
90:            //    // Reset to zero
91:            //    // ----------------------------------------------------------------------
92:            //    CAP1BUFL = 0;
93:            //    CAP1BUFH = 0;
94:            //
95:            //    // Calculate the average
96:            //    // ----------------------------------------------------------------------
97:            //    IRlevel = IRlevel/3;
98:            //
99:            //    // Return the averaged value
100:           //    // ----------------------------------------------------------------------
101:           //    return IRlevel;
102:           //}
103:           //
104:           //int measureIRright(void)
105:           //{
106:           //    // Initialise IR level variable
107:           //    // ----------------------------------------------------------------------
108:           //    unsigned int IRlevel = 0;
109:           //
110:           //    // Take a predetermined number of readings, and sum the results
111:           //    // ----------------------------------------------------------------------
112:           //    for (char i = 0; i < 2; i++)
113:           //    {
114:           //         IRlevel += CAP1BUFL;  // Get the 8 bit LSB result
115:           //         IRlevel += ((unsigned int)CAP1BUFH << 8); // Get 2 bit MSB result
116:           //         __delay_ms(50);
117:           //    }
118:           //
119:           //    // Reset to zero
120:           //    // ----------------------------------------------------------------------
121:           //    CAP1BUFL = 0;
122:           //    CAP1BUFH = 0;
123:           //
124:           //    // Calculate the average
125:           //    // ----------------------------------------------------------------------
126:           //    IRlevel = IRlevel/2;
127:           //
128:           //    // Return the averaged value
129:           //    // ----------------------------------------------------------------------
130:           //    return IRlevel;
131:           //}
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/strlen.c  ---------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             #ifndef __XC8__
6:             #define ALIGN (sizeof(size_t))
7:             #define ONES ((size_t)-1/UCHAR_MAX)
8:             #define HIGHS (ONES * (UCHAR_MAX/2+1))
9:             #define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)
10:            #endif
11:            
12:            size_t strlen(const char *s)
13:            {
14:            	const char *a = s;
1AFC  C006     MOVFF Values, string
1AFE  F00A     NOP
1B00  C007     MOVFF number, pa
1B02  F00B     NOP
15:            #ifdef __XC8__
16:            	while(*s) {
1B04  D002     BRA 0x1B0A
17:            		s++;
1B06  4A06     INFSNZ Values, F, ACCESS
1B08  2A07     INCF number, F, ACCESS
18:            	}
1B0A  C006     MOVFF Values, FSR2
1B0C  FFD9     NOP
1B0E  C007     MOVFF number, FSR2H
1B10  FFDA     NOP
1B12  50DF     MOVF INDF2, W, ACCESS
1B14  A4D8     BTFSS STATUS, 2, ACCESS
1B16  D7F7     BRA 0x1B06
19:            #else
20:            	const size_t *w;
21:            	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
22:            	for (w = (const void *)s; !HASZERO(*w); w++);
23:            	for (s = (const void *)w; *s; s++);
24:            #endif
25:            	return s-a;
1B18  C00A     MOVFF string, type
1B1A  F008     NOP
1B1C  C00B     MOVFF pa, Byte
1B1E  F009     NOP
1B20  1E08     COMF type, F, ACCESS
1B22  1E09     COMF Byte, F, ACCESS
1B24  4A08     INFSNZ type, F, ACCESS
1B26  2A09     INCF Byte, F, ACCESS
1B28  5006     MOVF Values, W, ACCESS
1B2A  2408     ADDWF type, W, ACCESS
1B2C  6E06     MOVWF Values, ACCESS
1B2E  5007     MOVF number, W, ACCESS
1B30  2009     ADDWFC Byte, W, ACCESS
1B32  6E07     MOVWF number, ACCESS
1B34  0012     RETURN 0
26:            }
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/putch.c  ----------------------------------
1:             /*
2:              * Function: putch
3:              * Weak implementation.  User implementation may be required
4:              */
5:             
6:             void 
7:             putch(char c)
8:             {
9:             }
1D36  0012     RETURN 0
10:            
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/nf_sprintf.c  -----------------------------
1:             #include <stdarg.h>
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             /* "No file system" sprintf */
8:             
9:             int sprintf(char *restrict s, const char *restrict fmt, ...)
10:            {
11:            	int ret;
12:            	va_list ap;
13:            	FILE f;
14:            
15:            	va_start(ap, fmt);
1A4C  0E76     MOVLW 0x76
1A4E  0100     MOVLB 0x0
1A50  6F7A     MOVWF ap, BANKED
1A52  0E00     MOVLW 0x0
1A54  6F7B     MOVWF 0x7B, BANKED
16:            	f.buffer = s;
1A56  C072     MOVFF s, f
1A58  F07C     NOP
1A5A  C073     MOVFF 0x73, 0x7D
1A5C  F07D     NOP
17:            	f.count = 0;
1A5E  0E00     MOVLW 0x0
1A60  6F7F     MOVWF 0x7F, BANKED
1A62  0E00     MOVLW 0x0
1A64  6F7E     MOVWF 0x7E, BANKED
18:            	f.limit = 0;
1A66  0E00     MOVLW 0x0
1A68  6F81     MOVWF 0x81, BANKED
1A6A  0E00     MOVLW 0x0
1A6C  6F80     MOVWF 0x80, BANKED
19:            	ret = vfprintf(&f, fmt, ap);
1A6E  0E7C     MOVLW 0x7C
1A70  6E4F     MOVWF fp, ACCESS
1A72  0E00     MOVLW 0x0
1A74  6E50     MOVWF 0x50, ACCESS
1A76  C074     MOVFF fmt, fmt
1A78  F051     NOP
1A7A  C075     MOVFF 0x75, 0x52
1A7C  F052     NOP
1A7E  0E7A     MOVLW 0x7A
1A80  6E53     MOVWF ap, ACCESS
1A82  0E00     MOVLW 0x0
1A84  6E54     MOVWF 0x54, ACCESS
1A86  EC53     CALL 0x1AA6, 0
1A88  F00D     NOP
1A8A  C04F     MOVFF fp, ret
1A8C  F078     NOP
1A8E  C050     MOVFF 0x50, 0x79
1A90  F079     NOP
20:            	s[f.count] = '\0';
1A92  0100     MOVLB 0x0
1A94  517E     MOVF 0x7E, W, BANKED
1A96  2572     ADDWF s, W, BANKED
1A98  6ED9     MOVWF FSR2, ACCESS
1A9A  517F     MOVF 0x7F, W, BANKED
1A9C  2173     ADDWFC 0x73, W, BANKED
1A9E  6EDA     MOVWF FSR2H, ACCESS
1AA0  0E00     MOVLW 0x0
1AA2  6EDF     MOVWF INDF2, ACCESS
1AA4  0012     RETURN 0
21:            	va_end(ap);
22:            	return ret;
23:            }
24:            
25:            #endif
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/nf_fputs.c  -------------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
1B36  0E00     MOVLW 0x0
1B38  6E15     MOVWF 0x15, ACCESS
1B3A  0E00     MOVLW 0x0
1B3C  6E14     MOVWF i, ACCESS
14:                while ((c = *(s + i))) {
1B3E  D00B     BRA 0x1B56
15:            	fputc(c,fp);
1B40  C013     MOVFF c, Values
1B42  F006     NOP
1B44  6A07     CLRF number, ACCESS
1B46  C011     MOVFF fp, type
1B48  F008     NOP
1B4A  C012     MOVFF quotient, Byte
1B4C  F009     NOP
1B4E  ECFE     CALL 0x15FC, 0
1B50  F00A     NOP
16:                    ++i;
1B52  4A14     INFSNZ i, F, ACCESS
1B54  2A15     INCF 0x15, F, ACCESS
17:                }
1B56  5014     MOVF i, W, ACCESS
1B58  240F     ADDWF s, W, ACCESS
1B5A  6ED9     MOVWF FSR2, ACCESS
1B5C  5015     MOVF 0x15, W, ACCESS
1B5E  2010     ADDWFC counter, W, ACCESS
1B60  6EDA     MOVWF FSR2H, ACCESS
1B62  50DF     MOVF INDF2, W, ACCESS
1B64  6E13     MOVWF c, ACCESS
1B66  5013     MOVF c, W, ACCESS
1B68  B4D8     BTFSC STATUS, 2, ACCESS
1B6A  0012     RETURN 0
1B6C  D7E9     BRA 0x1B40
18:                return i;
19:            }
20:            
21:            #endif
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/nf_fputc.c  -------------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
15FC  5008     MOVF type, W, ACCESS
15FE  1009     IORWF Byte, W, ACCESS
1600  B4D8     BTFSC STATUS, 2, ACCESS
1602  D004     BRA 0x160C
1604  5008     MOVF type, W, ACCESS
1606  1009     IORWF Byte, W, ACCESS
1608  A4D8     BTFSS STATUS, 2, ACCESS
160A  D004     BRA 0x1614
13:                    putch(c);
160C  5006     MOVF Values, W, ACCESS
160E  EC9B     CALL 0x1D36, 0
1610  F00E     NOP
14:                } else {
1612  0012     RETURN 0
15:            	if((fp->limit == 0) || (fp->count < fp->limit)) {
1614  EE20     LFSR 2, 0x4
1616  F004     NOP
1618  5008     MOVF type, W, ACCESS
161A  26D9     ADDWF FSR2, F, ACCESS
161C  5009     MOVF Byte, W, ACCESS
161E  22DA     ADDWFC FSR2H, F, ACCESS
1620  50DE     MOVF POSTINC2, W, ACCESS
1622  10DE     IORWF POSTINC2, W, ACCESS
1624  B4D8     BTFSC STATUS, 2, ACCESS
1626  D016     BRA 0x1654
1628  EE20     LFSR 2, 0x4
162A  F004     NOP
162C  5008     MOVF type, W, ACCESS
162E  26D9     ADDWF FSR2, F, ACCESS
1630  5009     MOVF Byte, W, ACCESS
1632  22DA     ADDWFC FSR2H, F, ACCESS
1634  EE10     LFSR 1, 0x2
1636  F002     NOP
1638  5008     MOVF type, W, ACCESS
163A  26E1     ADDWF FSR1, F, ACCESS
163C  5009     MOVF Byte, W, ACCESS
163E  22E2     ADDWFC FSR1H, F, ACCESS
1640  50DE     MOVF POSTINC2, W, ACCESS
1642  5CE6     SUBWF POSTINC1, W, ACCESS
1644  50E6     MOVF POSTINC1, W, ACCESS
1646  0A80     XORLW 0x80
1648  6E0E     MOVWF divisor, ACCESS
164A  50DE     MOVF POSTINC2, W, ACCESS
164C  0A80     XORLW 0x80
164E  580E     SUBWFB divisor, W, ACCESS
1650  B0D8     BTFSC STATUS, 0, ACCESS
1652  0012     RETURN 0
16:            	        fp->buffer[fp->count] = (char)c;
1654  EE20     LFSR 2, 0x2
1656  F002     NOP
1658  5008     MOVF type, W, ACCESS
165A  26D9     ADDWF FSR2, F, ACCESS
165C  5009     MOVF Byte, W, ACCESS
165E  22DA     ADDWFC FSR2H, F, ACCESS
1660  CFDE     MOVFF POSTINC2, string
1662  F00A     NOP
1664  CFDD     MOVFF POSTDEC2, pa
1666  F00B     NOP
1668  C008     MOVFF type, FSR2
166A  FFD9     NOP
166C  C009     MOVFF Byte, FSR2H
166E  FFDA     NOP
1670  CFDE     MOVFF POSTINC2, dividend
1672  F00C     NOP
1674  CFDD     MOVFF POSTDEC2, dis
1676  F00D     NOP
1678  500A     MOVF string, W, ACCESS
167A  240C     ADDWF dividend, W, ACCESS
167C  6ED9     MOVWF FSR2, ACCESS
167E  500B     MOVF pa, W, ACCESS
1680  200D     ADDWFC dis, W, ACCESS
1682  6EDA     MOVWF FSR2H, ACCESS
1684  C006     MOVFF Values, INDF2
1686  FFDF     NOP
17:            		++fp->count;
1688  EE20     LFSR 2, 0x2
168A  F002     NOP
168C  5008     MOVF type, W, ACCESS
168E  26D9     ADDWF FSR2, F, ACCESS
1690  5009     MOVF Byte, W, ACCESS
1692  22DA     ADDWFC FSR2H, F, ACCESS
1694  2ADE     INCF POSTINC2, F, ACCESS
1696  0E00     MOVLW 0x0
1698  22DD     ADDWFC POSTDEC2, F, ACCESS
18:            	}
19:                }
169A  0012     RETURN 0
20:                return (unsigned char)c;
21:            }
22:            
23:            #endif
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/lomod.c  ----------------------------------
1:             // long long unsigned unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lomod(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lomod(unsigned long long int dividend, unsigned long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter;
13:            
14:            	if(divisor != 0) {
154E  500E     MOVF divisor, W, ACCESS
1550  100F     IORWF s, W, ACCESS
1552  1010     IORWF counter, W, ACCESS
1554  1011     IORWF fp, W, ACCESS
1556  1012     IORWF quotient, W, ACCESS
1558  1013     IORWF c, W, ACCESS
155A  1014     IORWF i, W, ACCESS
155C  1015     IORWF 0x15, W, ACCESS
155E  B4D8     BTFSC STATUS, 2, ACCESS
1560  D03C     BRA 0x15DA
15:            		counter = 1;
1562  0E01     MOVLW 0x1
1564  6E16     MOVWF fp, ACCESS
16:            		while((divisor & 0x8000000000000000ULL) == 0) {
1566  D00A     BRA 0x157C
17:            			divisor <<= 1;
1568  90D8     BCF STATUS, 0, ACCESS
156A  360E     RLCF divisor, F, ACCESS
156C  360F     RLCF s, F, ACCESS
156E  3610     RLCF counter, F, ACCESS
1570  3611     RLCF fp, F, ACCESS
1572  3612     RLCF quotient, F, ACCESS
1574  3613     RLCF c, F, ACCESS
1576  3614     RLCF i, F, ACCESS
1578  3615     RLCF 0x15, F, ACCESS
18:            			counter++;
157A  2A16     INCF fp, F, ACCESS
19:            		}
157C  AE15     BTFSS 0x15, 7, ACCESS
157E  D7F4     BRA 0x1568
20:            		do {
21:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
1580  500E     MOVF divisor, W, ACCESS
1582  5C06     SUBWF Values, W, ACCESS
1584  500F     MOVF s, W, ACCESS
1586  5807     SUBWFB number, W, ACCESS
1588  5010     MOVF counter, W, ACCESS
158A  5808     SUBWFB type, W, ACCESS
158C  5011     MOVF fp, W, ACCESS
158E  5809     SUBWFB Byte, W, ACCESS
1590  5012     MOVF quotient, W, ACCESS
1592  580A     SUBWFB string, W, ACCESS
1594  5013     MOVF c, W, ACCESS
1596  580B     SUBWFB pa, W, ACCESS
1598  5014     MOVF i, W, ACCESS
159A  580C     SUBWFB dividend, W, ACCESS
159C  5015     MOVF 0x15, W, ACCESS
159E  580D     SUBWFB dis, W, ACCESS
15A0  A0D8     BTFSS STATUS, 0, ACCESS
15A2  D010     BRA 0x15C4
22:            				dividend -= divisor;
15A4  500E     MOVF divisor, W, ACCESS
15A6  5E06     SUBWF Values, F, ACCESS
15A8  500F     MOVF s, W, ACCESS
15AA  5A07     SUBWFB number, F, ACCESS
15AC  5010     MOVF counter, W, ACCESS
15AE  5A08     SUBWFB type, F, ACCESS
15B0  5011     MOVF fp, W, ACCESS
15B2  5A09     SUBWFB Byte, F, ACCESS
15B4  5012     MOVF quotient, W, ACCESS
15B6  5A0A     SUBWFB string, F, ACCESS
15B8  5013     MOVF c, W, ACCESS
15BA  5A0B     SUBWFB pa, F, ACCESS
15BC  5014     MOVF i, W, ACCESS
15BE  5A0C     SUBWFB dividend, F, ACCESS
15C0  5015     MOVF 0x15, W, ACCESS
15C2  5A0D     SUBWFB dis, F, ACCESS
23:            			*(unsigned long long int *)&divisor >>= 1;
15C4  90D8     BCF STATUS, 0, ACCESS
15C6  3215     RRCF 0x15, F, ACCESS
15C8  3214     RRCF i, F, ACCESS
15CA  3213     RRCF c, F, ACCESS
15CC  3212     RRCF quotient, F, ACCESS
15CE  3211     RRCF fp, F, ACCESS
15D0  3210     RRCF counter, F, ACCESS
15D2  320F     RRCF s, F, ACCESS
15D4  320E     RRCF divisor, F, ACCESS
24:            		} while(--counter != 0);
15D6  2E16     DECFSZ fp, F, ACCESS
15D8  D7D3     BRA 0x1580
25:            	}
26:            	return dividend;
15DA  C006     MOVFF Values, Values
15DC  F006     NOP
15DE  C007     MOVFF number, number
15E0  F007     NOP
15E2  C008     MOVFF type, type
15E4  F008     NOP
15E6  C009     MOVFF Byte, Byte
15E8  F009     NOP
15EA  C00A     MOVFF string, string
15EC  F00A     NOP
15EE  C00B     MOVFF pa, pa
15F0  F00B     NOP
15F2  C00C     MOVFF dividend, dividend
15F4  F00C     NOP
15F6  C00D     MOVFF dis, dis
15F8  F00D     NOP
27:            }
15FA  0012     RETURN 0
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/lodiv.c  ----------------------------------
1:             // long long unsigned unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lodiv(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lodiv(unsigned long long int dividend, unsigned long long int divisor)
10:            #endif
11:            {
12:            	unsigned long long int	quotient;
13:            	unsigned char	counter;
14:            
15:            	quotient = 0;
13BE  EE20     LFSR 2, 0x16
13C0  F016     NOP
13C2  0E07     MOVLW 0x7
13C4  6ADE     CLRF POSTINC2, ACCESS
13C6  06E8     DECF WREG, F, ACCESS
13C8  E2FD     BC 0x13C4
16:            	if(divisor != 0) {
13CA  500E     MOVF divisor, W, ACCESS
13CC  100F     IORWF s, W, ACCESS
13CE  1010     IORWF counter, W, ACCESS
13D0  1011     IORWF fp, W, ACCESS
13D2  1012     IORWF quotient, W, ACCESS
13D4  1013     IORWF c, W, ACCESS
13D6  1014     IORWF i, W, ACCESS
13D8  1015     IORWF 0x15, W, ACCESS
13DA  B4D8     BTFSC STATUS, 2, ACCESS
13DC  D046     BRA 0x146A
17:            		counter = 1;
13DE  0E01     MOVLW 0x1
13E0  6E1E     MOVWF counter, ACCESS
18:            		while((divisor & 0x8000000000000000ULL) == 0) {
13E2  D00A     BRA 0x13F8
19:            			divisor <<= 1;
13E4  90D8     BCF STATUS, 0, ACCESS
13E6  360E     RLCF divisor, F, ACCESS
13E8  360F     RLCF s, F, ACCESS
13EA  3610     RLCF counter, F, ACCESS
13EC  3611     RLCF fp, F, ACCESS
13EE  3612     RLCF quotient, F, ACCESS
13F0  3613     RLCF c, F, ACCESS
13F2  3614     RLCF i, F, ACCESS
13F4  3615     RLCF 0x15, F, ACCESS
20:            			counter++;
13F6  2A1E     INCF counter, F, ACCESS
21:            		}
13F8  AE15     BTFSS 0x15, 7, ACCESS
13FA  D7F4     BRA 0x13E4
22:            		do {
23:            			quotient <<= 1;
13FC  90D8     BCF STATUS, 0, ACCESS
13FE  3616     RLCF fp, F, ACCESS
1400  3617     RLCF sign, F, ACCESS
1402  3618     RLCF buf, F, ACCESS
1404  3619     RLCF PWMduty, F, ACCESS
1406  361A     RLCF p, F, ACCESS
1408  361B     RLCF mL, F, ACCESS
140A  361C     RLCF 0x1C, F, ACCESS
140C  361D     RLCF i, F, ACCESS
24:            			if(divisor <= dividend) {
140E  500E     MOVF divisor, W, ACCESS
1410  5C06     SUBWF Values, W, ACCESS
1412  500F     MOVF s, W, ACCESS
1414  5807     SUBWFB number, W, ACCESS
1416  5010     MOVF counter, W, ACCESS
1418  5808     SUBWFB type, W, ACCESS
141A  5011     MOVF fp, W, ACCESS
141C  5809     SUBWFB Byte, W, ACCESS
141E  5012     MOVF quotient, W, ACCESS
1420  580A     SUBWFB string, W, ACCESS
1422  5013     MOVF c, W, ACCESS
1424  580B     SUBWFB pa, W, ACCESS
1426  5014     MOVF i, W, ACCESS
1428  580C     SUBWFB dividend, W, ACCESS
142A  5015     MOVF 0x15, W, ACCESS
142C  580D     SUBWFB dis, W, ACCESS
142E  A0D8     BTFSS STATUS, 0, ACCESS
1430  D011     BRA 0x1454
25:            				dividend -= divisor;
1432  500E     MOVF divisor, W, ACCESS
1434  5E06     SUBWF Values, F, ACCESS
1436  500F     MOVF s, W, ACCESS
1438  5A07     SUBWFB number, F, ACCESS
143A  5010     MOVF counter, W, ACCESS
143C  5A08     SUBWFB type, F, ACCESS
143E  5011     MOVF fp, W, ACCESS
1440  5A09     SUBWFB Byte, F, ACCESS
1442  5012     MOVF quotient, W, ACCESS
1444  5A0A     SUBWFB string, F, ACCESS
1446  5013     MOVF c, W, ACCESS
1448  5A0B     SUBWFB pa, F, ACCESS
144A  5014     MOVF i, W, ACCESS
144C  5A0C     SUBWFB dividend, F, ACCESS
144E  5015     MOVF 0x15, W, ACCESS
1450  5A0D     SUBWFB dis, F, ACCESS
26:            				quotient |= 1;
1452  8016     BSF fp, 0, ACCESS
27:            			}
28:            			divisor >>= 1;
1454  90D8     BCF STATUS, 0, ACCESS
1456  3215     RRCF 0x15, F, ACCESS
1458  3214     RRCF i, F, ACCESS
145A  3213     RRCF c, F, ACCESS
145C  3212     RRCF quotient, F, ACCESS
145E  3211     RRCF fp, F, ACCESS
1460  3210     RRCF counter, F, ACCESS
1462  320F     RRCF s, F, ACCESS
1464  320E     RRCF divisor, F, ACCESS
29:            		} while(--counter != 0);
1466  2E1E     DECFSZ counter, F, ACCESS
1468  D7C9     BRA 0x13FC
30:            	}
31:            	return quotient;
146A  C016     MOVFF fp, Values
146C  F006     NOP
146E  C017     MOVFF sign, number
1470  F007     NOP
1472  C018     MOVFF buf, type
1474  F008     NOP
1476  C019     MOVFF PWMduty, Byte
1478  F009     NOP
147A  C01A     MOVFF p, string
147C  F00A     NOP
147E  C01B     MOVFF mL, pa
1480  F00B     NOP
1482  C01C     MOVFF 0x1C, dividend
1484  F00C     NOP
1486  C01D     MOVFF i, dis
1488  F00D     NOP
32:            }
148A  0012     RETURN 0
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/doprnt.c  ---------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
17C8  A057     BTFSS flags, 0, ACCESS
78:                    fputs((const char *)buf, fp);
17CC  C018     MOVFF buf, s
17CE  F00F     NOP
17D0  C019     MOVFF PWMduty, counter
17D2  F010     NOP
17D4  C016     MOVFF fp, fp
17D6  F011     NOP
17D8  C017     MOVFF sign, quotient
17DA  F012     NOP
17DC  EC9B     CALL 0x1B36, 0
17DE  F00D     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
17E0  BE1B     BTFSC mL, 7, ACCESS
17E2  D005     BRA 0x17EE
17E4  C01A     MOVFF p, w
17E6  F01F     NOP
17E8  C01B     MOVFF mL, 0x20
17EA  F020     NOP
17EC  D004     BRA 0x17F6
17EE  0E00     MOVLW 0x0
17F0  6E20     MOVWF 0x20, ACCESS
17F2  0E00     MOVLW 0x0
17F4  6E1F     MOVWF w, ACCESS
83:                i = 0;
17F6  0E00     MOVLW 0x0
17F8  6E1E     MOVWF counter, ACCESS
17FA  0E00     MOVLW 0x0
17FC  6E1D     MOVWF i, ACCESS
84:                while (i < w) {
17FE  D00C     BRA 0x1818
85:                    fputc(' ', fp);
1800  0E00     MOVLW 0x0
1802  6E07     MOVWF number, ACCESS
1804  0E20     MOVLW 0x20
1806  6E06     MOVWF Values, ACCESS
1808  C016     MOVFF fp, type
180A  F008     NOP
180C  C017     MOVFF sign, Byte
180E  F009     NOP
1810  ECFE     CALL 0x15FC, 0
1812  F00A     NOP
86:                    ++i;
1814  4A1D     INFSNZ i, F, ACCESS
1816  2A1E     INCF counter, F, ACCESS
87:                }
1818  501F     MOVF w, W, ACCESS
181A  5C1D     SUBWF i, W, ACCESS
181C  501E     MOVF counter, W, ACCESS
181E  0A80     XORLW 0x80
1820  6E1C     MOVWF 0x1C, ACCESS
1822  5020     MOVF 0x20, W, ACCESS
1824  0A80     XORLW 0x80
1826  581C     SUBWFB 0x1C, W, ACCESS
1828  A0D8     BTFSS STATUS, 0, ACCESS
182A  D7EA     BRA 0x1800
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
182C  B057     BTFSC flags, 0, ACCESS
182E  D00A     BRA 0x1844
91:                    fputs((const char *)buf, fp);
1830  C018     MOVFF buf, s
1832  F00F     NOP
1834  C019     MOVFF PWMduty, counter
1836  F010     NOP
1838  C016     MOVFF fp, fp
183A  F011     NOP
183C  C017     MOVFF sign, quotient
183E  F012     NOP
1840  EC9B     CALL 0x1B36, 0
1842  F00D     NOP
92:                }
93:            
94:                return strlen(buf) + w;
1844  C018     MOVFF buf, Values
1846  F006     NOP
1848  C019     MOVFF PWMduty, number
184A  F007     NOP
184C  EC7E     CALL 0x1AFC, 0
184E  F00D     NOP
1850  501F     MOVF w, W, ACCESS
1852  2406     ADDWF Values, W, ACCESS
1854  6E16     MOVWF fp, ACCESS
1856  5020     MOVF 0x20, W, ACCESS
1858  2007     ADDWFC number, W, ACCESS
185A  6E17     MOVWF sign, ACCESS
185C  0012     RETURN 0
95:            }
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? '0' + d : 'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Put out padded string */
267:               dbuf[0] = c;
268:               dbuf[1] = '\0';
269:               return pad(fp, &dbuf[0], w);
270:           }
271:           #endif
272:           
273:           #ifdef _VFPF_D
274:           static _INLINE int dtoa(FILE *fp, long long d)
275:           {
276:               int i, p, s, w;
277:               long long n;
278:           
279:               /* Record sign, get absolute value */
280:               n = d;
05C4  C023     MOVFF d, n
281:               s = n < 0 ? 1 : 0;
05E4  AE42     BTFSS 0x42, 7, ACCESS
05E6  D002     BRA 0x5EC
05E8  0E01     MOVLW 0x1
05EA  D001     BRA 0x5EE
05EC  0E00     MOVLW 0x0
05EE  6E39     MOVWF s, ACCESS
05F0  6A3A     CLRF 0x3A, ACCESS
282:               if (s) {
05F2  5039     MOVF s, W, ACCESS
05F4  103A     IORWF 0x3A, W, ACCESS
05F6  B4D8     BTFSC STATUS, 2, ACCESS
05F8  D010     BRA 0x61A
283:                   n = -n;
05FA  1E42     COMF 0x42, F, ACCESS
05FC  1E41     COMF 0x41, F, ACCESS
05FE  1E40     COMF 0x40, F, ACCESS
0600  1E3F     COMF i, F, ACCESS
0602  1E3E     COMF 0x3E, F, ACCESS
0604  1E3D     COMF 0x3D, F, ACCESS
0606  1E3C     COMF 0x3C, F, ACCESS
0608  6C3B     NEGF n, ACCESS
060A  0E00     MOVLW 0x0
060C  223C     ADDWFC 0x3C, F, ACCESS
060E  223D     ADDWFC 0x3D, F, ACCESS
0610  223E     ADDWFC 0x3E, F, ACCESS
0612  223F     ADDWFC i, F, ACCESS
0614  2240     ADDWFC 0x40, F, ACCESS
0616  2241     ADDWFC 0x41, F, ACCESS
0618  2242     ADDWFC 0x42, F, ACCESS
284:               }
285:           
286:               /* Adjust flags, precision, width */
287:               if (!(prec < 0)) {
061A  AE56     BTFSS 0x56, 7, ACCESS
288:                   flags &= ~ZERO_FLAG;
061C  9257     BCF flags, 1, ACCESS
289:               }
290:               p = (0 < prec) ? prec : 1;
061E  BE56     BTFSC 0x56, 7, ACCESS
0620  D005     BRA 0x62C
0622  5056     MOVF 0x56, W, ACCESS
0624  E108     BNZ 0x636
0626  0455     DECF prec, W, ACCESS
0628  B0D8     BTFSC STATUS, 0, ACCESS
062A  D005     BRA 0x636
062C  0E00     MOVLW 0x0
062E  6E36     MOVWF 0x36, ACCESS
0630  0E01     MOVLW 0x1
0632  6E35     MOVWF p, ACCESS
0634  D004     BRA 0x63E
0636  C055     MOVFF prec, p
0638  F035     NOP
063A  C056     MOVFF 0x56, 0x36
063C  F036     NOP
291:               w = width;
063E  C0BC     MOVFF width, w
0640  F037     NOP
0642  C0BD     MOVFF 0xBD, 0x38
0644  F038     NOP
292:               if (s || (flags & PLUS_FLAG)) {
0646  5039     MOVF s, W, ACCESS
0648  103A     IORWF 0x3A, W, ACCESS
064A  A4D8     BTFSS STATUS, 2, ACCESS
064C  D002     BRA 0x652
064E  A457     BTFSS flags, 2, ACCESS
0650  D003     BRA 0x658
293:                   --w;
0652  0637     DECF w, F, ACCESS
0654  A0D8     BTFSS STATUS, 0, ACCESS
0656  0638     DECF 0x38, F, ACCESS
294:               }
295:           
296:               /* Convert to decimal, possibly filling on the left with zeroes */
297:               i = sizeof(dbuf) - 1;
0658  0E00     MOVLW 0x0
065A  6E44     MOVWF 0x44, ACCESS
065C  0E1F     MOVLW 0x1F
065E  6E43     MOVWF i, ACCESS
298:               dbuf[i] = '\0';
0660  0EC1     MOVLW 0xC1
0662  2443     ADDWF i, W, ACCESS
0664  6ED9     MOVWF FSR2, ACCESS
0666  0E00     MOVLW 0x0
0668  2044     ADDWFC 0x44, W, ACCESS
066A  6EDA     MOVWF FSR2H, ACCESS
066C  0E00     MOVLW 0x0
066E  6EDF     MOVWF INDF2, ACCESS
299:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
0670  D07C     BRA 0x76A
300:                   --i;
0672  0643     DECF i, F, ACCESS
0674  A0D8     BTFSS STATUS, 0, ACCESS
0676  0644     DECF 0x44, F, ACCESS
301:                   dbuf[i] = '0' + abs(n % 10);
0678  0EC1     MOVLW 0xC1
067A  2443     ADDWF i, W, ACCESS
067C  6ED9     MOVWF FSR2, ACCESS
067E  0E00     MOVLW 0x0
0680  2044     ADDWFC 0x44, W, ACCESS
0682  6EDA     MOVWF FSR2H, ACCESS
0684  C03B     MOVFF n, Values
0686  F006     NOP
0688  C03C     MOVFF 0x3C, number
068A  F007     NOP
068C  C03D     MOVFF 0x3D, type
068E  F008     NOP
0690  C03E     MOVFF 0x3E, Byte
0692  F009     NOP
0694  C03F     MOVFF i, string
0696  F00A     NOP
0698  C040     MOVFF 0x40, pa
069A  F00B     NOP
069C  C041     MOVFF 0x41, dividend
069E  F00C     NOP
06A0  C042     MOVFF 0x42, dis
06A2  F00D     NOP
06A4  0E0A     MOVLW 0xA
06A6  6E0E     MOVWF divisor, ACCESS
06A8  0E00     MOVLW 0x0
06AA  6E0F     MOVWF s, ACCESS
06AC  0E00     MOVLW 0x0
06AE  6E10     MOVWF counter, ACCESS
06B0  0E00     MOVLW 0x0
06B2  6E11     MOVWF fp, ACCESS
06B4  0E00     MOVLW 0x0
06B6  6E12     MOVWF quotient, ACCESS
06B8  0E00     MOVLW 0x0
06BA  6E13     MOVWF c, ACCESS
06BC  0E00     MOVLW 0x0
06BE  6E14     MOVWF i, ACCESS
06C0  0E00     MOVLW 0x0
06C2  6E15     MOVWF 0x15, ACCESS
06C4  EC4B     CALL 0x1096, 0
06C6  F008     NOP
06C8  C006     MOVFF Values, 0x2B
06CA  F02B     NOP
06CC  C007     MOVFF number, 0x2C
06CE  F02C     NOP
06D0  C008     MOVFF type, 0x2D
06D2  F02D     NOP
06D4  C009     MOVFF Byte, 0x2E
06D6  F02E     NOP
06D8  C00A     MOVFF string, 0x2F
06DA  F02F     NOP
06DC  C00B     MOVFF pa, 0x30
06DE  F030     NOP
06E0  C00C     MOVFF dividend, 0x31
06E2  F031     NOP
06E4  C00D     MOVFF dis, 0x32
06E6  F032     NOP
06E8  C02B     MOVFF 0x2B, buf
06EA  F018     NOP
06EC  C02D     MOVFF 0x2D, PWMduty
06EE  F019     NOP
06F0  ECB7     CALL 0x1B6E, 0
06F2  F00D     NOP
06F4  5018     MOVF buf, W, ACCESS
06F6  0F30     ADDLW 0x30
06F8  6EDF     MOVWF INDF2, ACCESS
302:                   --p;
06FA  0635     DECF p, F, ACCESS
06FC  A0D8     BTFSS STATUS, 0, ACCESS
06FE  0636     DECF 0x36, F, ACCESS
303:                   --w;
0700  0637     DECF w, F, ACCESS
0702  A0D8     BTFSS STATUS, 0, ACCESS
0704  0638     DECF 0x38, F, ACCESS
304:                   n = n / 10;
0706  C03B     MOVFF n, Values
0708  F006     NOP
070A  C03C     MOVFF 0x3C, number
070C  F007     NOP
070E  C03D     MOVFF 0x3D, type
0710  F008     NOP
0712  C03E     MOVFF 0x3E, Byte
0714  F009     NOP
0716  C03F     MOVFF i, string
0718  F00A     NOP
071A  C040     MOVFF 0x40, pa
071C  F00B     NOP
071E  C041     MOVFF 0x41, dividend
0720  F00C     NOP
0722  C042     MOVFF 0x42, dis
0724  F00D     NOP
0726  0E0A     MOVLW 0xA
0728  6E0E     MOVWF divisor, ACCESS
072A  0E00     MOVLW 0x0
072C  6E0F     MOVWF s, ACCESS
072E  0E00     MOVLW 0x0
0730  6E10     MOVWF counter, ACCESS
0732  0E00     MOVLW 0x0
0734  6E11     MOVWF fp, ACCESS
0736  0E00     MOVLW 0x0
0738  6E12     MOVWF quotient, ACCESS
073A  0E00     MOVLW 0x0
073C  6E13     MOVWF c, ACCESS
073E  0E00     MOVLW 0x0
0740  6E14     MOVWF i, ACCESS
0742  0E00     MOVLW 0x0
0744  6E15     MOVWF 0x15, ACCESS
0746  ECA7     CALL 0xF4E, 0
0748  F007     NOP
074A  C006     MOVFF Values, n
074C  F03B     NOP
074E  C007     MOVFF number, 0x3C
0750  F03C     NOP
0752  C008     MOVFF type, 0x3D
0754  F03D     NOP
0756  C009     MOVFF Byte, 0x3E
0758  F03E     NOP
075A  C00A     MOVFF string, i
075C  F03F     NOP
075E  C00B     MOVFF pa, 0x40
0760  F040     NOP
0762  C00C     MOVFF dividend, 0x41
0764  F041     NOP
0766  C00D     MOVFF dis, 0x42
0768  F042     NOP
305:               }
076A  BE44     BTFSC 0x44, 7, ACCESS
076C  D01F     BRA 0x7AC
076E  5044     MOVF 0x44, W, ACCESS
0770  E103     BNZ 0x778
0772  0443     DECF i, W, ACCESS
0774  A0D8     BTFSS STATUS, 0, ACCESS
0776  D01A     BRA 0x7AC
0778  503B     MOVF n, W, ACCESS
077A  103C     IORWF 0x3C, W, ACCESS
077C  103D     IORWF 0x3D, W, ACCESS
077E  103E     IORWF 0x3E, W, ACCESS
0780  103F     IORWF i, W, ACCESS
0782  1040     IORWF 0x40, W, ACCESS
0784  1041     IORWF 0x41, W, ACCESS
0786  1042     IORWF 0x42, W, ACCESS
0788  A4D8     BTFSS STATUS, 2, ACCESS
078A  D773     BRA 0x672
078C  BE36     BTFSC 0x36, 7, ACCESS
078E  D005     BRA 0x79A
0790  5036     MOVF 0x36, W, ACCESS
0792  E102     BNZ 0x798
0794  0435     DECF p, W, ACCESS
0796  B0D8     BTFSC STATUS, 0, ACCESS
0798  D76C     BRA 0x672
079A  BE38     BTFSC 0x38, 7, ACCESS
079C  D007     BRA 0x7AC
079E  5038     MOVF 0x38, W, ACCESS
07A0  E103     BNZ 0x7A8
07A2  0437     DECF w, W, ACCESS
07A4  A0D8     BTFSS STATUS, 0, ACCESS
07A6  D002     BRA 0x7AC
07A8  B257     BTFSC flags, 1, ACCESS
07AA  D763     BRA 0x672
306:           
307:               /* Display sign if required */
308:               if (s || (flags & PLUS_FLAG)) {
07AC  5039     MOVF s, W, ACCESS
07AE  103A     IORWF 0x3A, W, ACCESS
07B0  A4D8     BTFSS STATUS, 2, ACCESS
07B2  D002     BRA 0x7B8
07B4  A457     BTFSS flags, 2, ACCESS
07B6  D017     BRA 0x7E6
309:                   --i;
07B8  0643     DECF i, F, ACCESS
07BA  A0D8     BTFSS STATUS, 0, ACCESS
07BC  0644     DECF 0x44, F, ACCESS
310:                   dbuf[i] = s ? '-' : '+';
07BE  5039     MOVF s, W, ACCESS
07C0  103A     IORWF 0x3A, W, ACCESS
07C2  A4D8     BTFSS STATUS, 2, ACCESS
07C4  D004     BRA 0x7CE
07C6  0E00     MOVLW 0x0
07C8  6E34     MOVWF 0x34, ACCESS
07CA  0E2B     MOVLW 0x2B
07CC  D003     BRA 0x7D4
07CE  0E00     MOVLW 0x0
07D0  6E34     MOVWF 0x34, ACCESS
07D2  0E2D     MOVLW 0x2D
07D4  6E33     MOVWF p, ACCESS
07D6  0EC1     MOVLW 0xC1
07D8  2443     ADDWF i, W, ACCESS
07DA  6ED9     MOVWF FSR2, ACCESS
07DC  0E00     MOVLW 0x0
07DE  2044     ADDWFC 0x44, W, ACCESS
07E0  6EDA     MOVWF FSR2H, ACCESS
07E2  C033     MOVFF p, INDF2
07E4  FFDF     NOP
311:               }
312:           
313:               /* Put out padded string */
314:               return pad(fp, &dbuf[i], w);
07E6  C021     MOVFF fp, fp
07E8  F016     NOP
07EA  C022     MOVFF 0x22, sign
07EC  F017     NOP
07EE  0EC1     MOVLW 0xC1
07F0  2443     ADDWF i, W, ACCESS
07F2  6E18     MOVWF buf, ACCESS
07F4  0E00     MOVLW 0x0
07F6  2044     ADDWFC 0x44, W, ACCESS
07F8  6E19     MOVWF PWMduty, ACCESS
07FA  C037     MOVFF w, p
07FC  F01A     NOP
07FE  C038     MOVFF 0x38, mL
0800  F01B     NOP
0802  ECE4     CALL 0x17C8, 0
0804  F00B     NOP
0806  C016     MOVFF fp, fp
0808  F021     NOP
080A  C017     MOVFF sign, 0x22
080C  F022     NOP
080E  0012     RETURN 0
315:           }
316:           #endif
317:           
318:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
319:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
320:           {
321:               char mode, nmode;
322:               int d, e, i, m, n, ne, p, pp, sign, t, w;
323:               long double g, h, l, ou, u;
324:           
325:               /* Record sign, get absolute value */
326:               sign = 0;
327:               g = f;
328:               if (g < 0.0) {
329:                   sign = 1;
330:                   g = -g;
331:               }
332:           
333:               /* Print sign */
334:               n = 0;
335:               w = width;
336:               if (sign || (flags & PLUS_FLAG)) {
337:                   dbuf[n] = sign ? '-' : '+';
338:                   ++n;
339:                   --w;
340:               }
341:           
342:               /* Catch infinities, NaNs here */
343:               if (isinf(g)) {
344:                   if (isupper((int)c)) {
345:                       strcpy(&dbuf[n], "INF");
346:                   } else {
347:                       strcpy(&dbuf[n], "inf");
348:                   }
349:                   w -= CSTRLEN("inf");
350:                   return pad(fp, &dbuf[0], w);
351:               }
352:               if (isnan(g)) {
353:                   if (isupper((int)c)) {
354:                       strcpy(&dbuf[n], "NAN");
355:                   } else {
356:                       strcpy(&dbuf[n], "nan");
357:                   }
358:                   w -= CSTRLEN("inf");
359:                   return pad(fp, &dbuf[0], w);
360:               }
361:           
362:               /* First find the largest power of 10 not larger than number to print */
363:               u = 1.0;
364:               e = 0;
365:               if (!(g == 0.0)) {
366:                   while (!(g < (u*10.0))) {
367:                       u = u*10.0;
368:                       ++e;
369:                   }
370:                   while (g < u) {
371:                       u = u/10.0;
372:                       --e;
373:                   }
374:               }
375:           
376:               /* Get mode, precision */
377:               mode = tolower((int)c);
378:               nmode = mode;
379:               if (mode == 'g') {
380:           		if (prec == 0) {
381:           			prec = 1;
382:           		}
383:                   p = (0 < prec) ? prec : 6;
384:               } else {
385:                   p = (prec < 0) ? 6 : prec;
386:               }
387:           
388:               /* Choose e or f mode from g mode */
389:               if (mode == 'g') {
390:                   if (!(e < -4) && !((p - 1) < e)) {
391:                       nmode = 'f';
392:                   } else {
393:                       nmode = 'e';
394:                   }
395:               }
396:           
397:               /* Decimal places or significant digits */
398:               m = p;
399:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
400:                   ++m;
401:               }
402:           
403:               /* Adjust starting exponent, string length for 'f' conversions */
404:               if (nmode == 'f') {
405:                   if (e < 0) {
406:                       u = 1.0;
407:                       e = 0;
408:                   }
409:                   if (!(mode == 'g')) {
410:                       m += e;
411:                   }
412:               }
413:           
414:               /* Go through the conversion once to get to the rounding step */
415:               i = 0;
416:               h = g;
417:               ou = u;
418:               while (i < m) {
419:                   l = floor(h/u);
420:                   d = (int)l;
421:                   h -= l*u;
422:                   u = u/10.0;
423:                   ++i;
424:               }
425:               
426:               /* Remainder >= halfway ? */
427:               l = u*5.0;
428:               if (h < l) {
429:                   l = 0.0;
430:               } else {
431:                   /* On tie choose even number */
432:                   if ((h == l) && !(d % 2)) {
433:                       l = 0.0;
434:                   }
435:               }
436:           
437:               /* Round */
438:               h = g + l;
439:               
440:               /* Convert again, after rounding */
441:               u = ou;
442:               ne = (nmode == 'e') ? 0 : e;
443:               pp = 0;
444:               t = 0;
445:               i = 0;
446:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
447:                   l = floor(h/u);
448:                   d = (int)l;
449:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
450:                       ++t;
451:                   } else {
452:                       if (!pp && (ne < 0)) {
453:                           dbuf[n++] = '.';
454:                           --w;
455:                           pp = 1;
456:                       }
457:                       while (t) {
458:                           dbuf[n++] = '0';
459:                           --w;
460:                           --t;
461:                       }
462:                       dbuf[n++] = '0' + d;
463:                       --w;
464:                   }
465:                   h -= l*u;
466:                   u = u/10.0;
467:                   --ne;
468:                   ++i;
469:               }
470:               if (!pp && (flags & POUND_FLAG)) {
471:                   dbuf[n++] = '.';
472:               }
473:               dbuf[n] = '\0';
474:           
475:               /* Convert exponent */
476:               if (nmode == 'e') {
477:                   i = sizeof(dbuf) - 1;
478:                   dbuf[i] = '\0';
479:                   sign = 0;
480:                   if (e < 0) {
481:                       sign = 1;
482:                       e = -e;
483:                   }
484:                   p = 2;
485:                   while (e || (0 < p)) {
486:                       --i;
487:                       dbuf[i] = '0' + (e % 10);
488:                       e = e / 10;
489:                       --p;
490:                       --w;
491:                   }
492:                   --i;
493:                   dbuf[i] = sign ? '-' : '+';
494:                   --w;
495:                   --i;
496:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
497:                   --w;
498:                   strcpy(&dbuf[n], &dbuf[i]);
499:               }
500:           
501:               /* Put out padded string */
502:               return pad(fp, &dbuf[0], w);
503:           }
504:           #endif
505:           
506:           #ifdef _VFPF_O
507:           static _INLINE int otoa(FILE *fp, unsigned long long d)
508:           {
509:               int i, p, t, w;
510:               unsigned long long n;
511:           
512:               /* Adjust flags, precision, width */
513:               if (!(prec < 0)) {
514:                   flags &= ~ZERO_FLAG;
515:               }
516:               p = (0 < prec) ? prec : 1;
517:               w = width;
518:           
519:               /* Convert to octal, possibly filling on the left with zeroes */
520:               n = d;
521:               i = sizeof(dbuf) - 1;
522:               dbuf[i] = '\0';
523:               t = 0;
524:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
525:                   --i;
526:                   t = n & 07;
527:                   dbuf[i] = '0' + t;
528:                   --p;
529:                   --w;
530:                   n = n >> 3;
531:               }
532:           
533:               /* Display prefix if required */
534:               if ((flags & POUND_FLAG) && t) {
535:                   --i;
536:                   dbuf[i] = '0';
537:                   --w;
538:               }
539:           
540:               /* Put out padded string */
541:               return pad(fp, &dbuf[i], w);
542:           }
543:           #endif
544:           
545:           #ifdef _VFPF_S
546:           static _INLINE int stoa(FILE *fp, char *s)
547:           {
548:               char *cp, nuls[] = "(null)";
549:               int i, l, p, w;
550:           
551:               /* Check for null string */
552:               cp = s;
553:               if (!cp) {
554:                   cp = nuls;
555:               }
556:           
557:               /* Get length, precision, width */
558:               l = strlen(cp);
559:               p = prec;
560:               l = (!(p < 0) && (p < l)) ? p : l;
561:               p = l;
562:               w = width;
563:           
564:               /* Right justify, pad on left ? */
565:               if (!(flags & MINUS_FLAG)) {
566:                   while (l < w) {
567:                       fputc(' ', fp);
568:                       ++l;
569:                   }
570:               }
571:           
572:               /* Put out string */
573:               i = 0;
574:               while (i < p) {
575:                   fputc(*cp, fp);
576:                   ++cp;
577:                   ++i;
578:               }
579:           
580:               /* Left justify, pad on right ? */
581:               if (flags & MINUS_FLAG) {
582:                   while (l < w) {
583:                       fputc(' ', fp);
584:                       ++l;
585:                   }
586:               }
587:           
588:               return l;
589:           }
590:           #endif
591:           
592:           #ifdef _VFPF_U
593:           static _INLINE int utoa(FILE *fp, unsigned long long d)
594:           {
595:               int i, p, w;
596:               unsigned long long n;
597:           
598:               /* Adjust flags, precision, width */
599:               if (!(prec < 0)) {
0C14  AE56     BTFSS 0x56, 7, ACCESS
600:                   flags &= ~ZERO_FLAG;
0C16  9257     BCF flags, 1, ACCESS
601:               }
602:               p = (0 < prec) ? prec : 1;
0C18  BE56     BTFSC 0x56, 7, ACCESS
0C1A  D005     BRA 0xC26
0C1C  5056     MOVF 0x56, W, ACCESS
0C1E  E108     BNZ 0xC30
0C20  0455     DECF prec, W, ACCESS
0C22  B0D8     BTFSC STATUS, 0, ACCESS
0C24  D005     BRA 0xC30
0C26  0E00     MOVLW 0x0
0C28  6E34     MOVWF 0x34, ACCESS
0C2A  0E01     MOVLW 0x1
0C2C  6E33     MOVWF p, ACCESS
0C2E  D004     BRA 0xC38
0C30  C055     MOVFF prec, p
0C32  F033     NOP
0C34  C056     MOVFF 0x56, 0x34
0C36  F034     NOP
603:               w = width;
0C38  C0BC     MOVFF width, p
0C3A  F035     NOP
0C3C  C0BD     MOVFF 0xBD, 0x36
0C3E  F036     NOP
604:           
605:               /* Convert to decimal, possibly filling on the left with zeroes */
606:               n = d;
0C40  C023     MOVFF d, w
0C42  F037     NOP
0C44  C024     MOVFF 0x24, 0x38
0C46  F038     NOP
0C48  C025     MOVFF 0x25, s
0C4A  F039     NOP
0C4C  C026     MOVFF 0x26, 0x3A
0C4E  F03A     NOP
0C50  C027     MOVFF 0x27, n
0C52  F03B     NOP
0C54  C028     MOVFF 0x28, 0x3C
0C56  F03C     NOP
0C58  C029     MOVFF 0x29, 0x3D
0C5A  F03D     NOP
0C5C  C02A     MOVFF 0x2A, 0x3E
0C5E  F03E     NOP
607:               i = sizeof(dbuf) - 1;
0C60  0E00     MOVLW 0x0
0C62  6E40     MOVWF 0x40, ACCESS
0C64  0E1F     MOVLW 0x1F
0C66  6E3F     MOVWF i, ACCESS
608:               dbuf[i] = '\0';
0C68  0EC1     MOVLW 0xC1
0C6A  243F     ADDWF i, W, ACCESS
0C6C  6ED9     MOVWF FSR2, ACCESS
0C6E  0E00     MOVLW 0x0
0C70  2040     ADDWFC 0x40, W, ACCESS
0C72  6EDA     MOVWF FSR2H, ACCESS
0C74  0E00     MOVLW 0x0
0C76  6EDF     MOVWF INDF2, ACCESS
609:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
0C78  D076     BRA 0xD66
610:                   --i;
0C7A  063F     DECF i, F, ACCESS
0C7C  A0D8     BTFSS STATUS, 0, ACCESS
0C7E  0640     DECF 0x40, F, ACCESS
611:                   dbuf[i] = '0' + (n % 10);
0C80  0EC1     MOVLW 0xC1
0C82  243F     ADDWF i, W, ACCESS
0C84  6ED9     MOVWF FSR2, ACCESS
0C86  0E00     MOVLW 0x0
0C88  2040     ADDWFC 0x40, W, ACCESS
0C8A  6EDA     MOVWF FSR2H, ACCESS
0C8C  C037     MOVFF w, Values
0C8E  F006     NOP
0C90  C038     MOVFF 0x38, number
0C92  F007     NOP
0C94  C039     MOVFF s, type
0C96  F008     NOP
0C98  C03A     MOVFF 0x3A, Byte
0C9A  F009     NOP
0C9C  C03B     MOVFF n, string
0C9E  F00A     NOP
0CA0  C03C     MOVFF 0x3C, pa
0CA2  F00B     NOP
0CA4  C03D     MOVFF 0x3D, dividend
0CA6  F00C     NOP
0CA8  C03E     MOVFF 0x3E, dis
0CAA  F00D     NOP
0CAC  0E0A     MOVLW 0xA
0CAE  6E0E     MOVWF divisor, ACCESS
0CB0  0E00     MOVLW 0x0
0CB2  6E0F     MOVWF s, ACCESS
0CB4  0E00     MOVLW 0x0
0CB6  6E10     MOVWF counter, ACCESS
0CB8  0E00     MOVLW 0x0
0CBA  6E11     MOVWF fp, ACCESS
0CBC  0E00     MOVLW 0x0
0CBE  6E12     MOVWF quotient, ACCESS
0CC0  0E00     MOVLW 0x0
0CC2  6E13     MOVWF c, ACCESS
0CC4  0E00     MOVLW 0x0
0CC6  6E14     MOVWF i, ACCESS
0CC8  0E00     MOVLW 0x0
0CCA  6E15     MOVWF 0x15, ACCESS
0CCC  ECA7     CALL 0x154E, 0
0CCE  F00A     NOP
0CD0  C006     MOVFF Values, 0x2B
0CD2  F02B     NOP
0CD4  C007     MOVFF number, 0x2C
0CD6  F02C     NOP
0CD8  C008     MOVFF type, 0x2D
0CDA  F02D     NOP
0CDC  C009     MOVFF Byte, 0x2E
0CDE  F02E     NOP
0CE0  C00A     MOVFF string, 0x2F
0CE2  F02F     NOP
0CE4  C00B     MOVFF pa, 0x30
0CE6  F030     NOP
0CE8  C00C     MOVFF dividend, 0x31
0CEA  F031     NOP
0CEC  C00D     MOVFF dis, 0x32
0CEE  F032     NOP
0CF0  502B     MOVF 0x2B, W, ACCESS
0CF2  0F30     ADDLW 0x30
0CF4  6EDF     MOVWF INDF2, ACCESS
612:                   --p;
0CF6  0633     DECF p, F, ACCESS
0CF8  A0D8     BTFSS STATUS, 0, ACCESS
0CFA  0634     DECF 0x34, F, ACCESS
613:                   --w;
0CFC  0635     DECF p, F, ACCESS
0CFE  A0D8     BTFSS STATUS, 0, ACCESS
0D00  0636     DECF 0x36, F, ACCESS
614:                   n = n / 10;
0D02  C037     MOVFF w, Values
0D04  F006     NOP
0D06  C038     MOVFF 0x38, number
0D08  F007     NOP
0D0A  C039     MOVFF s, type
0D0C  F008     NOP
0D0E  C03A     MOVFF 0x3A, Byte
0D10  F009     NOP
0D12  C03B     MOVFF n, string
0D14  F00A     NOP
0D16  C03C     MOVFF 0x3C, pa
0D18  F00B     NOP
0D1A  C03D     MOVFF 0x3D, dividend
0D1C  F00C     NOP
0D1E  C03E     MOVFF 0x3E, dis
0D20  F00D     NOP
0D22  0E0A     MOVLW 0xA
0D24  6E0E     MOVWF divisor, ACCESS
0D26  0E00     MOVLW 0x0
0D28  6E0F     MOVWF s, ACCESS
0D2A  0E00     MOVLW 0x0
0D2C  6E10     MOVWF counter, ACCESS
0D2E  0E00     MOVLW 0x0
0D30  6E11     MOVWF fp, ACCESS
0D32  0E00     MOVLW 0x0
0D34  6E12     MOVWF quotient, ACCESS
0D36  0E00     MOVLW 0x0
0D38  6E13     MOVWF c, ACCESS
0D3A  0E00     MOVLW 0x0
0D3C  6E14     MOVWF i, ACCESS
0D3E  0E00     MOVLW 0x0
0D40  6E15     MOVWF 0x15, ACCESS
0D42  ECDF     CALL 0x13BE, 0
0D44  F009     NOP
0D46  C006     MOVFF Values, w
0D48  F037     NOP
0D4A  C007     MOVFF number, 0x38
0D4C  F038     NOP
0D4E  C008     MOVFF type, s
0D50  F039     NOP
0D52  C009     MOVFF Byte, 0x3A
0D54  F03A     NOP
0D56  C00A     MOVFF string, n
0D58  F03B     NOP
0D5A  C00B     MOVFF pa, 0x3C
0D5C  F03C     NOP
0D5E  C00C     MOVFF dividend, 0x3D
0D60  F03D     NOP
0D62  C00D     MOVFF dis, 0x3E
0D64  F03E     NOP
615:               }
0D66  503F     MOVF i, W, ACCESS
0D68  1040     IORWF 0x40, W, ACCESS
0D6A  B4D8     BTFSC STATUS, 2, ACCESS
0D6C  D01A     BRA 0xDA2
0D6E  5037     MOVF w, W, ACCESS
0D70  1038     IORWF 0x38, W, ACCESS
0D72  1039     IORWF s, W, ACCESS
0D74  103A     IORWF 0x3A, W, ACCESS
0D76  103B     IORWF n, W, ACCESS
0D78  103C     IORWF 0x3C, W, ACCESS
0D7A  103D     IORWF 0x3D, W, ACCESS
0D7C  103E     IORWF 0x3E, W, ACCESS
0D7E  A4D8     BTFSS STATUS, 2, ACCESS
0D80  D77C     BRA 0xC7A
0D82  BE34     BTFSC 0x34, 7, ACCESS
0D84  D005     BRA 0xD90
0D86  5034     MOVF 0x34, W, ACCESS
0D88  E102     BNZ 0xD8E
0D8A  0433     DECF p, W, ACCESS
0D8C  B0D8     BTFSC STATUS, 0, ACCESS
0D8E  D775     BRA 0xC7A
0D90  BE36     BTFSC 0x36, 7, ACCESS
0D92  D007     BRA 0xDA2
0D94  5036     MOVF 0x36, W, ACCESS
0D96  E103     BNZ 0xD9E
0D98  0435     DECF p, W, ACCESS
0D9A  A0D8     BTFSS STATUS, 0, ACCESS
0D9C  D002     BRA 0xDA2
0D9E  B257     BTFSC flags, 1, ACCESS
0DA0  D76C     BRA 0xC7A
616:           
617:               /* Put out padded string */
618:               return pad(fp, &dbuf[i], w);
0DA2  C021     MOVFF fp, fp
0DA4  F016     NOP
0DA6  C022     MOVFF 0x22, sign
0DA8  F017     NOP
0DAA  0EC1     MOVLW 0xC1
0DAC  243F     ADDWF i, W, ACCESS
0DAE  6E18     MOVWF buf, ACCESS
0DB0  0E00     MOVLW 0x0
0DB2  2040     ADDWFC 0x40, W, ACCESS
0DB4  6E19     MOVWF PWMduty, ACCESS
0DB6  C035     MOVFF p, p
0DB8  F01A     NOP
0DBA  C036     MOVFF 0x36, mL
0DBC  F01B     NOP
0DBE  ECE4     CALL 0x17C8, 0
0DC0  F00B     NOP
0DC2  C016     MOVFF fp, fp
0DC4  F021     NOP
0DC6  C017     MOVFF sign, 0x22
0DC8  F022     NOP
0DCA  0012     RETURN 0
619:           }
620:           #endif
621:           
622:           #if defined(_VFPF_X) || defined(_VFPF_P)
623:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
624:           {
625:               int c, i, p, w;
626:               unsigned long long n;
627:           
628:               /* Adjust, flags, precision, width */
629:               if (!(prec < 0)) {
630:                   flags &= ~ZERO_FLAG;
631:               }
632:               p = (0 < prec) ? prec : 1;
633:               w = width;
634:               if (flags & POUND_FLAG) {
635:                   w -= 2;
636:               }
637:           
638:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
639:               n = d;
640:               i = sizeof(dbuf) - 1;
641:               dbuf[i] = '\0';
642:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
643:                   --i;
644:                   c = n & 0x0f;
645:                   c = (c < 10) ? '0' + c : 'a' + (c - 10);
646:                   if (isupper((int)x) && isalpha(c)) {
647:                       c = toupper(c);
648:                   }
649:                   dbuf[i] = (char)c;
650:                   --p;
651:                   --w;
652:                   n = n >> 4;
653:               }
654:           
655:               /* Display prefix if required */
656:               if (flags & POUND_FLAG) {
657:                   --i;
658:                   dbuf[i] = x;
659:                   --i;
660:                   dbuf[i] = '0';
661:               }
662:           
663:               /* Put out padded string */
664:               return pad(fp, &dbuf[i], w);
665:           }
666:           #endif
667:           
668:           /* Consume and convert the next part of the format string */
669:           #ifdef _VFPF_CONVERT
670:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
671:           {
672:               char c, *cp, ct[3];
673:               int done, i;
674:               long long ll;
675:               unsigned long long llu;
676:               long double f;
677:               void *vp;
678:           
679:               /* Conversion ? */
680:               if ((*fmt)[0] == '%') {
0810  C047     MOVFF fmt, FSR2
681:                   ++*fmt;
082A  C047     MOVFF fmt, FSR2
082C  FFD9     NOP
082E  C048     MOVFF 0x48, FSR2H
0830  FFDA     NOP
0832  2ADE     INCF POSTINC2, F, ACCESS
0834  0E00     MOVLW 0x0
0836  22DD     ADDWFC POSTDEC2, F, ACCESS
682:           
683:                   flags = width = 0;
0838  0E00     MOVLW 0x0
083A  0100     MOVLB 0x0
083C  6FBD     MOVWF 0xBD, BANKED
083E  0E00     MOVLW 0x0
0840  6FBC     MOVWF width, BANKED
0842  C0BC     MOVFF width, flags
0844  F057     NOP
0846  C0BD     MOVFF 0xBD, 0x58
0848  F058     NOP
684:                   prec = -1;
084A  6855     SETF prec, ACCESS
084C  6856     SETF 0x56, ACCESS
685:           
686:           #ifdef _VFPF_FLAGS
687:                   /* Get flags */
688:                   done = 0;
689:                   while (!done) {
690:                       switch ((*fmt)[0]) {
691:                           case '-' :
692:                               flags |= MINUS_FLAG;
693:                               ++*fmt;
694:                               break;
695:                           case '0' :
696:                               flags |= ZERO_FLAG;
697:                               ++*fmt;
698:                               break;
699:                           case '+' :
700:                               flags |= PLUS_FLAG;
701:                               ++*fmt;
702:                               break;
703:                           case ' ' :
704:                               flags |= SPACE_FLAG;
705:                               ++*fmt;
706:                               break;
707:                           case '#' :
708:                               flags |= POUND_FLAG;
709:                               ++*fmt;
710:                               break;
711:                           default:
712:                               done = 1;
713:                               break;
714:                       }
715:                   }
716:                   if (flags & MINUS_FLAG) {
717:                       flags &= ~ZERO_FLAG;
718:                   }
719:           #endif
720:           
721:           #ifdef _VFPF_WIDTH
722:                   /* Get field width */
723:                   if ((*fmt)[0] == '*') {
724:                       ++*fmt;
725:                       width = va_arg(ap, int);
726:                       if (width < 0) {
727:                           flags |= MINUS_FLAG;
728:                           width = -width;
729:                       }
730:                   } else {
731:                       width = atoi(*fmt);
732:                       while (isdigit((*fmt)[0])) {
733:                           ++*fmt;
734:                       }
735:                   }
736:           #endif
737:           
738:           #ifdef _VFPF_PRECISION
739:                   /* Get precision */
740:                   if ((*fmt)[0] == '.') {
741:                       prec = 0;
742:                       ++*fmt;
743:                       if ((*fmt)[0] == '*') {
744:                           ++*fmt;
745:                           prec = va_arg(ap, int);
746:                       } else {
747:                           prec = atoi(*fmt);
748:                           while (isdigit((*fmt)[0])) {
749:                               ++*fmt;
750:                           }
751:                       }
752:                   }
753:           #endif
754:           
755:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
756:                   /* Case-folded conversion types */
757:                   ct[0] = tolower((int)(*fmt)[0]);
758:                   if (ct[0]) {
759:                       ct[1] = tolower((int)(*fmt)[1]);
760:                       if (ct[1]) {
761:                           ct[2] = tolower((int)(*fmt)[2]);
762:                       }
763:                   }
764:           #endif
765:           
766:           #ifdef _VFPF_A
767:                   /* 'a' style (hex) floating point */
768:                   if (ct[0] == 'a') {
769:           
770:                       c = (*fmt)[0];
771:                       ++*fmt;
772:                       f = (long double)va_arg(ap, double);
773:                                   
774:                       return atoa(fp, f, c);
775:                   }
776:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
777:           
778:                       c = (*fmt)[1];
779:                       if (isupper((int)(*fmt)[0])) {
780:                           f = va_arg(ap, long double);
781:                       } else {
782:                           f = (long double)va_arg(ap, double);
783:                       }
784:                       *fmt += CSTRLEN("la");
785:                                   
786:                       return atoa(fp, f, c);
787:                   }
788:           #endif
789:           
790:           #ifdef _VFPF_C
791:                   /* Character */
792:                   if (*fmt[0] == 'c') {
793:                       ++*fmt;
794:                       c = (unsigned char)va_arg(ap, int);
795:                       return ctoa(fp, c);
796:                   }
797:           #endif
798:           
799:           #ifdef _VFPF_D
800:           #ifdef _VFPF_HH
801:                   /* Character decimal integer */
802:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
803:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
804:           
805:                       *fmt += CSTRLEN("hhd");
806:                       ll = (long long)(signed char)va_arg(ap, int);
807:                                   
808:                       return dtoa(fp, ll);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_H
813:                   /* Short decimal integer */
814:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
815:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
816:           
817:                       *fmt += CSTRLEN("hd");
818:                       ll = (long long)(short)va_arg(ap, int);
819:                                   
820:                       return dtoa(fp, ll);
821:                   }
822:           #endif
823:           
824:                   /* Decimal integer */
825:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
084E  C047     MOVFF fmt, FSR2
0850  FFD9     NOP
0852  C048     MOVFF 0x48, FSR2H
0854  FFDA     NOP
0856  CFDE     MOVFF POSTINC2, TBLPTR
0858  FFF6     NOP
085A  CFDD     MOVFF POSTDEC2, TBLPTRH
085C  FFF7     NOP
085E  0008     TBLRD*
0860  50F5     MOVF TABLAT, W, ACCESS
0862  0A64     XORLW 0x64
0864  B4D8     BTFSC STATUS, 2, ACCESS
0866  D00D     BRA 0x882
0868  C047     MOVFF fmt, FSR2
086A  FFD9     NOP
086C  C048     MOVFF 0x48, FSR2H
086E  FFDA     NOP
0870  CFDE     MOVFF POSTINC2, TBLPTR
0872  FFF6     NOP
0874  CFDD     MOVFF POSTDEC2, TBLPTRH
0876  FFF7     NOP
0878  0008     TBLRD*
087A  50F5     MOVF TABLAT, W, ACCESS
087C  0A69     XORLW 0x69
087E  A4D8     BTFSS STATUS, 2, ACCESS
0880  D03F     BRA 0x900
826:           
827:                       ++*fmt;
0882  C047     MOVFF fmt, FSR2
0884  FFD9     NOP
0886  C048     MOVFF 0x48, FSR2H
0888  FFDA     NOP
088A  2ADE     INCF POSTINC2, F, ACCESS
088C  0E00     MOVLW 0x0
088E  22DD     ADDWFC POSTDEC2, F, ACCESS
828:                       ll = (long long)va_arg(ap, int);
0890  C049     MOVFF ap, FSR2
0892  FFD9     NOP
0894  C04A     MOVFF 0x4A, FSR2H
0896  FFDA     NOP
0898  CFDF     MOVFF INDF2, 0x4B
089A  F04B     NOP
089C  0E02     MOVLW 0x2
089E  26DE     ADDWF POSTINC2, F, ACCESS
08A0  CFDF     MOVFF INDF2, 0x4C
08A2  F04C     NOP
08A4  0E00     MOVLW 0x0
08A6  22DD     ADDWFC POSTDEC2, F, ACCESS
08A8  C04B     MOVFF 0x4B, FSR2
08AA  FFD9     NOP
08AC  C04C     MOVFF 0x4C, FSR2H
08AE  FFDA     NOP
08B0  CFDE     MOVFF POSTINC2, __pcstackBANK0
08B2  F060     NOP
08B4  CFDD     MOVFF POSTDEC2, 0x61
08B6  F061     NOP
08B8  0E00     MOVLW 0x0
08BA  BF61     BTFSC 0x61, 7, BANKED
08BC  0EFF     MOVLW 0xFF
08BE  6F62     MOVWF ttemp7, BANKED
08C0  6F63     MOVWF 0x63, BANKED
08C2  6F64     MOVWF 0x64, BANKED
08C4  6F65     MOVWF 0x65, BANKED
08C6  6F66     MOVWF 0x66, BANKED
08C8  6F67     MOVWF 0x67, BANKED
829:                                   
830:                       return dtoa(fp, ll);
08CA  C045     MOVFF fp, fp
08CC  F021     NOP
08CE  C046     MOVFF 0x46, 0x22
08D0  F022     NOP
08D2  C060     MOVFF __pcstackBANK0, d
08D4  F023     NOP
08D6  C061     MOVFF 0x61, 0x24
08D8  F024     NOP
08DA  C062     MOVFF ttemp7, 0x25
08DC  F025     NOP
08DE  C063     MOVFF 0x63, 0x26
08E0  F026     NOP
08E2  C064     MOVFF 0x64, 0x27
08E4  F027     NOP
08E6  C065     MOVFF 0x65, 0x28
08E8  F028     NOP
08EA  C066     MOVFF 0x66, 0x29
08EC  F029     NOP
08EE  C067     MOVFF 0x67, 0x2A
08F0  F02A     NOP
08F2  ECE2     CALL 0x5C4, 0
08F4  F002     NOP
08F6  C021     MOVFF fp, fp
08F8  F045     NOP
08FA  C022     MOVFF 0x22, 0x46
08FC  F046     NOP
08FE  0012     RETURN 0
831:                   }
832:           
833:           #ifdef _VFPF_L
834:                   /* Long decimal integer */
835:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
836:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
837:           
838:                       *fmt += CSTRLEN("ld");
839:                       ll = (long long)va_arg(ap, long);
840:                                   
841:                       return dtoa(fp, ll);
842:                   }
843:           #endif
844:           
845:           #ifdef _VFPF_LL
846:                   /* Long long decimal integer */
847:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
848:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
849:           
850:                       *fmt += CSTRLEN("lld");
851:                       ll = va_arg(ap, long long);
852:                                   
853:                       return dtoa(fp, ll);
854:                   }
855:           #endif
856:           
857:           #ifdef _VFPF_J
858:                   /* intmax_t decimal integer */
859:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
860:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
861:           
862:                       *fmt += CSTRLEN("jd");
863:                       ll = (long long)va_arg(ap, intmax_t);
864:                                   
865:                       return dtoa(fp, ll);
866:                   }
867:           #endif
868:           
869:           #ifdef _VFPF_T
870:                   /* ptrdiff_t decimal integer */
871:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
872:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
873:           
874:                       *fmt += CSTRLEN("td");
875:                       ll = (long long)va_arg(ap, ptrdiff_t);
876:                                   
877:                       return dtoa(fp, ll);
878:                   }
879:           #endif
880:           
881:           #ifdef _VFPF_Z
882:                   /* size_t decimal integer */
883:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
884:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
885:           
886:                       *fmt += CSTRLEN("zd");
887:                       ll = (long long)va_arg(ap, size_t);
888:                                   
889:                       return dtoa(fp, ll);
890:                   }
891:           #endif
892:           #endif
893:           
894:           #ifdef _VFPF_E
895:                   /* 'e' style floating point */
896:                   if (ct[0] == 'e') {
897:           
898:                       c = (*fmt)[0];
899:                       ++*fmt;
900:                       f = (long double)va_arg(ap, double);
901:                                   
902:                       return efgtoa(fp, f, c);
903:                   }
904:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
905:           
906:                       c = (*fmt)[1];
907:                       if (isupper((int)(*fmt)[0])) {
908:                           f = va_arg(ap, long double);
909:                       } else {
910:                           f = (long double)va_arg(ap, double);
911:                       }
912:                       *fmt += CSTRLEN("lf");
913:                                   
914:                       return efgtoa(fp, f, c);
915:                   }
916:           #endif
917:           
918:           #ifdef _VFPF_F
919:                   /* 'f' style floating point */
920:                   if (ct[0] == 'f') {
921:           
922:                       c = (*fmt)[0];
923:                       ++*fmt;
924:                       f = (long double)va_arg(ap, double);
925:                                   
926:                       return efgtoa(fp, f, c);
927:                   }
928:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
929:           
930:                       c = (*fmt)[1];
931:                       if (isupper((int)(*fmt)[0])) {
932:                           f = va_arg(ap, long double);
933:                       } else {
934:                           f = (long double)va_arg(ap, double);
935:                       }
936:                       *fmt += CSTRLEN("lf");
937:                                   
938:                       return efgtoa(fp, f, c);
939:                   }
940:           #endif
941:           
942:           #ifdef _VFPF_G
943:                   /* 'g' style floating point */
944:                   if (ct[0] == 'g') {
945:           
946:                       c = (*fmt)[0];
947:                       ++*fmt;
948:                       f = (long double)va_arg(ap, double);
949:                                   
950:                       return efgtoa(fp, f, c);
951:                   }
952:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
953:           
954:                       c = (*fmt)[1];
955:                       if (isupper((int)(*fmt)[0])) {
956:                           f = va_arg(ap, long double);
957:                       } else {
958:                           f = (long double)va_arg(ap, double);
959:                       }
960:                       *fmt += CSTRLEN("lg");
961:                                   
962:                       return efgtoa(fp, f, c);
963:                   }
964:           #endif
965:           
966:           #ifdef _VFPF_O
967:           #ifdef _VFPF_HH
968:                   /* Character octal integer */
969:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
970:           
971:                       *fmt += CSTRLEN("hho");
972:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
973:                                   
974:                       return otoa(fp, llu);
975:                   }
976:           #endif
977:           
978:           #ifdef _VFPF_H
979:                   /* Short octal integer */
980:                   if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
981:           
982:                       *fmt += CSTRLEN("ho");
983:                       llu = (unsigned long long)(unsigned short)va_arg(ap, int);
984:                                   
985:                       return otoa(fp, llu);
986:                   }
987:           #endif
988:           
989:                   /* Octal integer */
990:                   if (*fmt[0] == 'o') {
991:           
992:                       ++*fmt;
993:                       llu = (unsigned long long)va_arg(ap, unsigned int);
994:                                   
995:                       return otoa(fp, llu);
996:                   }
997:           
998:           #ifdef _VFPF_L
999:                   /* Long octal integer */
1000:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1001:          
1002:                      *fmt += CSTRLEN("lo");
1003:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1004:                                  
1005:                      return otoa(fp, llu);
1006:                  }
1007:          #endif
1008:          
1009:          #ifdef _VFPF_LL
1010:                  /* Long long octal integer */
1011:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1012:          
1013:                      *fmt += CSTRLEN("llo");
1014:                      llu = va_arg(ap, unsigned long long);
1015:                                  
1016:                      return otoa(fp, llu);
1017:                  }
1018:          #endif
1019:          
1020:          #ifdef _VFPF_J
1021:                  /* uintmax_t octal integer */
1022:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1023:          
1024:                      *fmt += CSTRLEN("jo");
1025:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_T
1032:                  /* ptrdiff_t octal integer */
1033:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1034:          
1035:                      *fmt += CSTRLEN("to");
1036:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_Z
1043:                  /* size_t octal integer */
1044:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1045:          
1046:                      *fmt += CSTRLEN("zo");
1047:                      llu = (unsigned long long)va_arg(ap, size_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          #endif
1053:          
1054:                  /* Character count */
1055:          #ifdef _VFPF_N
1056:          
1057:          #ifdef _VFPF_HH
1058:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1059:          
1060:                      *fmt += CSTRLEN("hhn");
1061:                      vp = (void *)va_arg(ap, char *);
1062:                      *(char *)vp = (char)nout;
1063:                      return 0;
1064:                  }
1065:          #endif
1066:          
1067:          #ifdef _VFPF_H
1068:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1069:          
1070:                      *fmt += CSTRLEN("hn");
1071:                      vp = (void *)va_arg(ap, short *);
1072:                      *(short *)vp = (short)nout;
1073:                      return 0;
1074:                  }
1075:          #endif
1076:          
1077:                  if (*fmt[0] == 'n') {
1078:                      ++*fmt;
1079:                      vp = (void *)va_arg(ap, int *);
1080:                      *(int *)vp = nout;
1081:                      return 0;
1082:                  }
1083:          
1084:          #ifdef _VFPF_L
1085:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1086:          
1087:                      *fmt += CSTRLEN("ln");
1088:                      vp = (void *)va_arg(ap, long *);
1089:                      *(long *)vp = (long)nout;
1090:                      return 0;
1091:                  }
1092:          #endif
1093:          
1094:          #ifdef _VFPF_LL
1095:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1096:          
1097:                      *fmt += CSTRLEN("lln");
1098:                      vp = (void *)va_arg(ap, long long *);
1099:                      *(long long *)vp = (long long)nout;
1100:                      return 0;
1101:                  }
1102:          #endif
1103:          
1104:          #ifdef _VFPF_J
1105:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1106:          
1107:                      *fmt += CSTRLEN("jn");
1108:                      vp = (void *)va_arg(ap, uintmax_t *);
1109:                      *(uintmax_t *)vp = (uintmax_t)nout;
1110:                      return 0;
1111:                  }
1112:          #endif
1113:          
1114:          #ifdef _VFPF_T
1115:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1116:          
1117:                      *fmt += CSTRLEN("tn");
1118:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1119:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1120:                      return 0;
1121:                  }
1122:          #endif
1123:          
1124:          #ifdef _VFPF_Z
1125:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1126:          
1127:                      *fmt += CSTRLEN("zn");
1128:                      vp = (void *)va_arg(ap, size_t *);
1129:                      *(size_t *)vp = (size_t)nout;
1130:                      return 0;
1131:                  }
1132:          #endif
1133:          
1134:          #endif
1135:          
1136:          #ifdef _VFPF_P
1137:                  /* Pointer */
1138:                  if (*fmt[0] == 'p') {
1139:          
1140:                      ++*fmt;
1141:                      llu = (unsigned long long)(size_t)va_arg(ap, void *);
1142:                                  
1143:                      return xtoa(fp, llu, 'x');
1144:                  }
1145:          #endif
1146:          
1147:          #ifdef _VFPF_S
1148:                  /* String */
1149:                  if (*fmt[0] == 's') {
1150:          
1151:                      ++*fmt;
1152:                      cp = va_arg(ap, char *);
1153:          
1154:                      return stoa(fp, cp);
1155:                  }
1156:          #endif
1157:          
1158:          #ifdef _VFPF_U
1159:          #ifdef _VFPF_HH
1160:                  /* Unsigned character decimal integer */
1161:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1162:          
1163:                      *fmt += CSTRLEN("hhu");
1164:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1165:                                  
1166:                      return utoa(fp, llu);
1167:                  }
1168:          #endif
1169:          
1170:          #ifdef _VFPF_H
1171:                  /* Unsigned short decimal integer */
1172:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1173:          
1174:                      *fmt += CSTRLEN("hu");
1175:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1176:                                  
1177:                      return utoa(fp, llu);
1178:                  }
1179:          #endif
1180:          
1181:                  /* Unsigned decimal integer */
1182:                  if (*fmt[0] == 'u') {
0900  C047     MOVFF fmt, FSR2
0902  FFD9     NOP
0904  C048     MOVFF 0x48, FSR2H
0906  FFDA     NOP
0908  CFDE     MOVFF POSTINC2, TBLPTR
090A  FFF6     NOP
090C  CFDD     MOVFF POSTDEC2, TBLPTRH
090E  FFF7     NOP
0910  0008     TBLRD*
0912  50F5     MOVF TABLAT, W, ACCESS
0914  0A75     XORLW 0x75
0916  A4D8     BTFSS STATUS, 2, ACCESS
0918  D041     BRA 0x99C
1183:          
1184:                      ++*fmt;
091A  C047     MOVFF fmt, FSR2
091C  FFD9     NOP
091E  C048     MOVFF 0x48, FSR2H
0920  FFDA     NOP
0922  2ADE     INCF POSTINC2, F, ACCESS
0924  0E00     MOVLW 0x0
0926  22DD     ADDWFC POSTDEC2, F, ACCESS
1185:                      llu = (unsigned long long)va_arg(ap, unsigned int);
0928  C049     MOVFF ap, FSR2
092A  FFD9     NOP
092C  C04A     MOVFF 0x4A, FSR2H
092E  FFDA     NOP
0930  CFDF     MOVFF INDF2, 0x4B
0932  F04B     NOP
0934  0E02     MOVLW 0x2
0936  26DE     ADDWF POSTINC2, F, ACCESS
0938  CFDF     MOVFF INDF2, 0x4C
093A  F04C     NOP
093C  0E00     MOVLW 0x0
093E  22DD     ADDWFC POSTDEC2, F, ACCESS
0940  C04B     MOVFF 0x4B, FSR2
0942  FFD9     NOP
0944  C04C     MOVFF 0x4C, FSR2H
0946  FFDA     NOP
0948  CFDE     MOVFF POSTINC2, 0x4D
094A  F04D     NOP
094C  CFDD     MOVFF POSTDEC2, 0x4E
094E  F04E     NOP
0950  C04D     MOVFF 0x4D, llu
0952  F068     NOP
0954  C04E     MOVFF 0x4E, 0x69
0956  F069     NOP
0958  0100     MOVLB 0x0
095A  6B6A     CLRF 0x6A, BANKED
095C  6B6B     CLRF 0x6B, BANKED
095E  6B6C     CLRF 0x6C, BANKED
0960  6B6D     CLRF 0x6D, BANKED
0962  6B6E     CLRF 0x6E, BANKED
0964  6B6F     CLRF 0x6F, BANKED
1186:                                  
1187:                      return utoa(fp, llu);
0966  C045     MOVFF fp, fp
0968  F021     NOP
096A  C046     MOVFF 0x46, 0x22
096C  F022     NOP
096E  C068     MOVFF llu, d
0970  F023     NOP
0972  C069     MOVFF 0x69, 0x24
0974  F024     NOP
0976  C06A     MOVFF 0x6A, 0x25
0978  F025     NOP
097A  C06B     MOVFF 0x6B, 0x26
097C  F026     NOP
097E  C06C     MOVFF 0x6C, 0x27
0980  F027     NOP
0982  C06D     MOVFF 0x6D, 0x28
0984  F028     NOP
0986  C06E     MOVFF 0x6E, 0x29
0988  F029     NOP
098A  C06F     MOVFF 0x6F, 0x2A
098C  F02A     NOP
098E  EC0A     CALL 0xC14, 0
0990  F006     NOP
0992  C021     MOVFF fp, fp
0994  F045     NOP
0996  C022     MOVFF 0x22, 0x46
0998  F046     NOP
099A  0012     RETURN 0
1188:                  }
1189:          
1190:          #ifdef _VFPF_L
1191:                  /* Unsigned long decimal integer */
1192:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1193:          
1194:                      *fmt += CSTRLEN("lu");
1195:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1196:                                  
1197:                      return utoa(fp, llu);
1198:                  }
1199:          #endif
1200:          
1201:          #ifdef _VFPF_LL
1202:                  /* Unsigned long long decimal integer */
1203:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1204:          
1205:                      *fmt += CSTRLEN("llu");
1206:                      llu = va_arg(ap, unsigned long long);
1207:                                  
1208:                      return utoa(fp, llu);
1209:                  }
1210:          #endif
1211:          
1212:          #ifdef _VFPF_J
1213:                  /* uintmax_t decimal integer */
1214:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1215:          
1216:                      *fmt += CSTRLEN("ju");
1217:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_T
1224:                  /* ptrdiff_t decimal integer */
1225:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1226:          
1227:                      *fmt += CSTRLEN("tu");
1228:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_Z
1235:                  /* size_t decimal integer */
1236:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1237:          
1238:                      *fmt += CSTRLEN("zu");
1239:                      llu = (unsigned long long)va_arg(ap, size_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          #endif
1245:          
1246:          #ifdef _VFPF_X
1247:          #ifdef _VFPF_HH
1248:                  /* Character hexadecimal integer */
1249:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1250:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1251:          
1252:                      c = (*fmt)[2];
1253:                      *fmt += CSTRLEN("hhx");
1254:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1255:                                  
1256:                      return xtoa(fp, llu, c);
1257:                  }
1258:          #endif
1259:          
1260:          #ifdef _VFPF_H
1261:                  /* Short hexadecimal integer */
1262:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1263:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1264:          
1265:                      c = (*fmt)[1];
1266:                      *fmt += CSTRLEN("hx");
1267:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1268:                                  
1269:                      return xtoa(fp, llu, c);
1270:                  }
1271:          #endif
1272:          
1273:                  /* Hexadecimal integer */
1274:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1275:          
1276:                      c = (*fmt)[0];
1277:                      ++*fmt;
1278:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1279:                                  
1280:                      return xtoa(fp, llu, c);
1281:                  }
1282:          
1283:          #ifdef _VFPF_L
1284:                  /* Long hexadecimal integer */
1285:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1286:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1287:          
1288:                      c = (*fmt)[1];
1289:                      *fmt += CSTRLEN("lx");
1290:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1291:                                  
1292:                      return xtoa(fp, llu, c);
1293:                  }
1294:          #endif
1295:          
1296:          #ifdef _VFPF_LL
1297:                  /* Long long hexadecimal integer */
1298:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1299:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1300:          
1301:                      c = (*fmt)[2];
1302:                      *fmt += CSTRLEN("llx");
1303:                      llu = va_arg(ap, unsigned long long);
1304:                                  
1305:                      return xtoa(fp, llu, c);
1306:                  }
1307:          #endif
1308:          
1309:          #ifdef _VFPF_J
1310:                  /* uintmax_t hexadecimal integer */
1311:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1312:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1313:          
1314:                      c = (*fmt)[1];
1315:                      *fmt += CSTRLEN("jx");
1316:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1317:                                  
1318:                      return xtoa(fp, llu, c);
1319:                  }
1320:          #endif
1321:          
1322:          #ifdef _VFPF_T
1323:                  /* ptrdiff_t hexadecimal integer */
1324:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1325:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1326:          
1327:                      c = (*fmt)[1];
1328:                      *fmt += CSTRLEN("tx");
1329:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1330:                                  
1331:                      return xtoa(fp, llu, c);
1332:                  }
1333:          #endif
1334:          
1335:          #ifdef _VFPF_Z
1336:                  /* size_t hexadecimal integer */
1337:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1338:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1339:          
1340:                      c = (*fmt)[1];
1341:                      *fmt += CSTRLEN("zx");
1342:                      llu = (unsigned long long)va_arg(ap, size_t);
1343:                                  
1344:                      return xtoa(fp, llu, c);
1345:                  }
1346:          #endif
1347:          #endif
1348:          
1349:                  /* 'Escaped' '%' character */
1350:                  if ((*fmt)[0] == '%') {
099C  C047     MOVFF fmt, FSR2
099E  FFD9     NOP
09A0  C048     MOVFF 0x48, FSR2H
09A2  FFDA     NOP
09A4  CFDE     MOVFF POSTINC2, TBLPTR
09A6  FFF6     NOP
09A8  CFDD     MOVFF POSTDEC2, TBLPTRH
09AA  FFF7     NOP
09AC  0008     TBLRD*
09AE  50F5     MOVF TABLAT, W, ACCESS
09B0  0A25     XORLW 0x25
09B2  A4D8     BTFSS STATUS, 2, ACCESS
09B4  D016     BRA 0x9E2
1351:                      ++*fmt;
09B6  C047     MOVFF fmt, FSR2
09B8  FFD9     NOP
09BA  C048     MOVFF 0x48, FSR2H
09BC  FFDA     NOP
09BE  2ADE     INCF POSTINC2, F, ACCESS
09C0  0E00     MOVLW 0x0
09C2  22DD     ADDWFC POSTDEC2, F, ACCESS
1352:                      fputc((int)'%', fp);
09C4  0E00     MOVLW 0x0
09C6  6E07     MOVWF number, ACCESS
09C8  0E25     MOVLW 0x25
09CA  6E06     MOVWF Values, ACCESS
09CC  C045     MOVFF fp, type
09CE  F008     NOP
09D0  C046     MOVFF 0x46, Byte
09D2  F009     NOP
09D4  ECFE     CALL 0x15FC, 0
09D6  F00A     NOP
1353:                      return 1;
09D8  0E00     MOVLW 0x0
09DA  6E46     MOVWF 0x46, ACCESS
09DC  0E01     MOVLW 0x1
09DE  6E45     MOVWF fp, ACCESS
09E0  0012     RETURN 0
1354:                  }
1355:          
1356:                  /* Unrecognized conversion */
1357:                  ++*fmt;
09E2  C047     MOVFF fmt, FSR2
09E4  FFD9     NOP
09E6  C048     MOVFF 0x48, FSR2H
09E8  FFDA     NOP
09EA  2ADE     INCF POSTINC2, F, ACCESS
09EC  0E00     MOVLW 0x0
09EE  22DD     ADDWFC POSTDEC2, F, ACCESS
1358:                  return 0;
09F0  0E00     MOVLW 0x0
09F2  6E46     MOVWF 0x46, ACCESS
09F4  0E00     MOVLW 0x0
09F6  6E45     MOVWF fp, ACCESS
09F8  0012     RETURN 0
1359:              }
1360:          
1361:              /* No conversion, just intervening text */
1362:              fputc((int)(*fmt)[0], fp);
09FA  C047     MOVFF fmt, FSR2
09FC  FFD9     NOP
09FE  C048     MOVFF 0x48, FSR2H
0A00  FFDA     NOP
0A02  CFDE     MOVFF POSTINC2, TBLPTR
0A04  FFF6     NOP
0A06  CFDD     MOVFF POSTDEC2, TBLPTRH
0A08  FFF7     NOP
0A0A  0008     TBLRD*
0A0C  50F5     MOVF TABLAT, W, ACCESS
0A0E  6E06     MOVWF Values, ACCESS
0A10  6A07     CLRF number, ACCESS
0A12  C045     MOVFF fp, type
0A14  F008     NOP
0A16  C046     MOVFF 0x46, Byte
0A18  F009     NOP
0A1A  ECFE     CALL 0x15FC, 0
0A1C  F00A     NOP
1363:              ++*fmt;
0A1E  C047     MOVFF fmt, FSR2
0A20  FFD9     NOP
0A22  C048     MOVFF 0x48, FSR2H
0A24  FFDA     NOP
0A26  2ADE     INCF POSTINC2, F, ACCESS
0A28  0E00     MOVLW 0x0
0A2A  22DD     ADDWFC POSTDEC2, F, ACCESS
1364:              return 1;
0A2C  0E00     MOVLW 0x0
0A2E  6E46     MOVWF 0x46, ACCESS
0A30  0E01     MOVLW 0x1
0A32  6E45     MOVWF fp, ACCESS
0A34  0012     RETURN 0
1365:          }
1366:          #endif
1367:          
1368:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1369:          {
1370:          #ifdef _VFPF_CONVERT
1371:              char *cfmt;
1372:          
1373:              cfmt = (char *)fmt;
1AA6  C051     MOVFF fmt, cfmt
1AA8  F070     NOP
1AAA  C052     MOVFF 0x52, 0x71
1AAC  F071     NOP
1374:              nout = 0;
1AAE  0E00     MOVLW 0x0
1AB0  0100     MOVLB 0x0
1AB2  6FBB     MOVWF 0xBB, BANKED
1AB4  0E00     MOVLW 0x0
1AB6  6FBA     MOVWF nout, BANKED
1375:              while (*cfmt) {
1AB8  D013     BRA 0x1AE0
1376:                  nout += vfpfcnvrt(fp, &cfmt, ap);
1ABA  C04F     MOVFF fp, fp
1ABC  F045     NOP
1ABE  C050     MOVFF 0x50, 0x46
1AC0  F046     NOP
1AC2  0E70     MOVLW 0x70
1AC4  6E47     MOVWF fmt, ACCESS
1AC6  0E00     MOVLW 0x0
1AC8  6E48     MOVWF 0x48, ACCESS
1ACA  C053     MOVFF ap, ap
1ACC  F049     NOP
1ACE  C054     MOVFF 0x54, 0x4A
1AD0  F04A     NOP
1AD2  EC08     CALL 0x810, 0
1AD4  F004     NOP
1AD6  5045     MOVF fp, W, ACCESS
1AD8  0100     MOVLB 0x0
1ADA  27BA     ADDWF nout, F, BANKED
1ADC  5046     MOVF 0x46, W, ACCESS
1ADE  23BB     ADDWFC 0xBB, F, BANKED
1377:              }
1AE0  C070     MOVFF cfmt, TBLPTR
1AE2  FFF6     NOP
1AE4  C071     MOVFF 0x71, TBLPTRH
1AE6  FFF7     NOP
1AE8  0008     TBLRD*
1AEA  50F5     MOVF TABLAT, W, ACCESS
1AEC  0900     IORLW 0x0
1AEE  A4D8     BTFSS STATUS, 2, ACCESS
1AF0  D7E4     BRA 0x1ABA
1378:              return nout;
1AF2  C0BA     MOVFF nout, fp
1AF4  F04F     NOP
1AF6  C0BB     MOVFF 0xBB, 0x50
1AF8  F050     NOP
1379:          #else
1380:              return fputs(fmt, fp);
1381:          #endif
1382:          }
1AFA  0012     RETURN 0
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/awdiv.c  ----------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awdiv(signed int divisor, signed int dividend)
6:             #else
7:             __awdiv(signed int dividend, signed int divisor)
8:             #endif
9:             {
10:            	signed int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
185E  0E00     MOVLW 0x0
1860  6E11     MOVWF fp, ACCESS
14:            	if(divisor < 0) {
1862  AE0F     BTFSS s, 7, ACCESS
1864  D006     BRA 0x1872
15:            		divisor = -divisor;
1866  6C0E     NEGF divisor, ACCESS
1868  1E0F     COMF s, F, ACCESS
186A  B0D8     BTFSC STATUS, 0, ACCESS
186C  2A0F     INCF s, F, ACCESS
16:            		sign = 1;
186E  0E01     MOVLW 0x1
1870  6E11     MOVWF fp, ACCESS
17:            	}
18:            	if(dividend < 0) {
1872  AE0D     BTFSS dis, 7, ACCESS
1874  D006     BRA 0x1882
19:            		dividend = -dividend;
1876  6C0C     NEGF dividend, ACCESS
1878  1E0D     COMF dis, F, ACCESS
187A  B0D8     BTFSC STATUS, 0, ACCESS
187C  2A0D     INCF dis, F, ACCESS
20:            		sign ^= 1;
187E  0E01     MOVLW 0x1
1880  1A11     XORWF fp, F, ACCESS
21:            	}
22:            	quotient = 0;
1882  0E00     MOVLW 0x0
1884  6E13     MOVWF c, ACCESS
1886  0E00     MOVLW 0x0
1888  6E12     MOVWF quotient, ACCESS
23:            	if(divisor != 0) {
188A  500E     MOVF divisor, W, ACCESS
188C  100F     IORWF s, W, ACCESS
188E  B4D8     BTFSC STATUS, 2, ACCESS
1890  D01C     BRA 0x18CA
24:            		counter = 1;
1892  0E01     MOVLW 0x1
1894  6E10     MOVWF counter, ACCESS
25:            		while((divisor & 0x8000U) == 0) {
1896  D004     BRA 0x18A0
26:            			divisor <<= 1;
1898  90D8     BCF STATUS, 0, ACCESS
189A  360E     RLCF divisor, F, ACCESS
189C  360F     RLCF s, F, ACCESS
27:            			counter++;
189E  2A10     INCF counter, F, ACCESS
28:            		}
18A0  AE0F     BTFSS s, 7, ACCESS
18A2  D7FA     BRA 0x1898
29:            		do {
30:            			quotient <<= 1;
18A4  90D8     BCF STATUS, 0, ACCESS
18A6  3612     RLCF quotient, F, ACCESS
18A8  3613     RLCF c, F, ACCESS
31:            			if((unsigned int)divisor <= (unsigned int)dividend) {
18AA  500E     MOVF divisor, W, ACCESS
18AC  5C0C     SUBWF dividend, W, ACCESS
18AE  500F     MOVF s, W, ACCESS
18B0  580D     SUBWFB dis, W, ACCESS
18B2  A0D8     BTFSS STATUS, 0, ACCESS
18B4  D005     BRA 0x18C0
32:            				dividend -= divisor;
18B6  500E     MOVF divisor, W, ACCESS
18B8  5E0C     SUBWF dividend, F, ACCESS
18BA  500F     MOVF s, W, ACCESS
18BC  5A0D     SUBWFB dis, F, ACCESS
33:            				quotient |= 1;
18BE  8012     BSF quotient, 0, ACCESS
34:            			}
35:            			*(unsigned int *)&divisor >>= 1;
18C0  90D8     BCF STATUS, 0, ACCESS
18C2  320F     RRCF s, F, ACCESS
18C4  320E     RRCF divisor, F, ACCESS
36:            		} while(--counter != 0);
18C6  2E10     DECFSZ counter, F, ACCESS
18C8  D7ED     BRA 0x18A4
37:            	}
38:            	if(sign)
18CA  5011     MOVF fp, W, ACCESS
18CC  B4D8     BTFSC STATUS, 2, ACCESS
18CE  D004     BRA 0x18D8
39:            		quotient = -quotient;
18D0  6C12     NEGF quotient, ACCESS
18D2  1E13     COMF c, F, ACCESS
18D4  B0D8     BTFSC STATUS, 0, ACCESS
18D6  2A13     INCF c, F, ACCESS
40:            	return quotient;
18D8  C012     MOVFF quotient, dividend
18DA  F00C     NOP
18DC  C013     MOVFF c, dis
18DE  F00D     NOP
18E0  0012     RETURN 0
41:            }
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/aomod.c  ----------------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
1096  0E00     MOVLW 0x0
1098  6E17     MOVWF sign, ACCESS
15:            	if(dividend < 0) {
109A  AE0D     BTFSS dis, 7, ACCESS
109C  D012     BRA 0x10C2
16:            		dividend = -dividend;
109E  1E0D     COMF dis, F, ACCESS
10A0  1E0C     COMF dividend, F, ACCESS
10A2  1E0B     COMF pa, F, ACCESS
10A4  1E0A     COMF string, F, ACCESS
10A6  1E09     COMF Byte, F, ACCESS
10A8  1E08     COMF type, F, ACCESS
10AA  1E07     COMF number, F, ACCESS
10AC  6C06     NEGF Values, ACCESS
10AE  0E00     MOVLW 0x0
10B0  2207     ADDWFC number, F, ACCESS
10B2  2208     ADDWFC type, F, ACCESS
10B4  2209     ADDWFC Byte, F, ACCESS
10B6  220A     ADDWFC string, F, ACCESS
10B8  220B     ADDWFC pa, F, ACCESS
10BA  220C     ADDWFC dividend, F, ACCESS
10BC  220D     ADDWFC dis, F, ACCESS
17:            		sign = 1;
10BE  0E01     MOVLW 0x1
10C0  6E17     MOVWF sign, ACCESS
18:            	}
19:            	if(divisor < 0)
10C2  AE15     BTFSS 0x15, 7, ACCESS
10C4  D010     BRA 0x10E6
20:            		divisor = -divisor;
10C6  1E15     COMF 0x15, F, ACCESS
10C8  1E14     COMF i, F, ACCESS
10CA  1E13     COMF c, F, ACCESS
10CC  1E12     COMF quotient, F, ACCESS
10CE  1E11     COMF fp, F, ACCESS
10D0  1E10     COMF counter, F, ACCESS
10D2  1E0F     COMF s, F, ACCESS
10D4  6C0E     NEGF divisor, ACCESS
10D6  0E00     MOVLW 0x0
10D8  220F     ADDWFC s, F, ACCESS
10DA  2210     ADDWFC counter, F, ACCESS
10DC  2211     ADDWFC fp, F, ACCESS
10DE  2212     ADDWFC quotient, F, ACCESS
10E0  2213     ADDWFC c, F, ACCESS
10E2  2214     ADDWFC i, F, ACCESS
10E4  2215     ADDWFC 0x15, F, ACCESS
21:            	if(divisor != 0) {
10E6  500E     MOVF divisor, W, ACCESS
10E8  100F     IORWF s, W, ACCESS
10EA  1010     IORWF counter, W, ACCESS
10EC  1011     IORWF fp, W, ACCESS
10EE  1012     IORWF quotient, W, ACCESS
10F0  1013     IORWF c, W, ACCESS
10F2  1014     IORWF i, W, ACCESS
10F4  1015     IORWF 0x15, W, ACCESS
10F6  B4D8     BTFSC STATUS, 2, ACCESS
10F8  D03C     BRA 0x1172
22:            		counter = 1;
10FA  0E01     MOVLW 0x1
10FC  6E16     MOVWF fp, ACCESS
23:            		while((divisor & 0x8000000000000000ULL) == 0) {
10FE  D00A     BRA 0x1114
24:            			divisor <<= 1;
1100  90D8     BCF STATUS, 0, ACCESS
1102  360E     RLCF divisor, F, ACCESS
1104  360F     RLCF s, F, ACCESS
1106  3610     RLCF counter, F, ACCESS
1108  3611     RLCF fp, F, ACCESS
110A  3612     RLCF quotient, F, ACCESS
110C  3613     RLCF c, F, ACCESS
110E  3614     RLCF i, F, ACCESS
1110  3615     RLCF 0x15, F, ACCESS
25:            			counter++;
1112  2A16     INCF fp, F, ACCESS
26:            		}
1114  AE15     BTFSS 0x15, 7, ACCESS
1116  D7F4     BRA 0x1100
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
1118  500E     MOVF divisor, W, ACCESS
111A  5C06     SUBWF Values, W, ACCESS
111C  500F     MOVF s, W, ACCESS
111E  5807     SUBWFB number, W, ACCESS
1120  5010     MOVF counter, W, ACCESS
1122  5808     SUBWFB type, W, ACCESS
1124  5011     MOVF fp, W, ACCESS
1126  5809     SUBWFB Byte, W, ACCESS
1128  5012     MOVF quotient, W, ACCESS
112A  580A     SUBWFB string, W, ACCESS
112C  5013     MOVF c, W, ACCESS
112E  580B     SUBWFB pa, W, ACCESS
1130  5014     MOVF i, W, ACCESS
1132  580C     SUBWFB dividend, W, ACCESS
1134  5015     MOVF 0x15, W, ACCESS
1136  580D     SUBWFB dis, W, ACCESS
1138  A0D8     BTFSS STATUS, 0, ACCESS
113A  D010     BRA 0x115C
29:            				dividend -= divisor;
113C  500E     MOVF divisor, W, ACCESS
113E  5E06     SUBWF Values, F, ACCESS
1140  500F     MOVF s, W, ACCESS
1142  5A07     SUBWFB number, F, ACCESS
1144  5010     MOVF counter, W, ACCESS
1146  5A08     SUBWFB type, F, ACCESS
1148  5011     MOVF fp, W, ACCESS
114A  5A09     SUBWFB Byte, F, ACCESS
114C  5012     MOVF quotient, W, ACCESS
114E  5A0A     SUBWFB string, F, ACCESS
1150  5013     MOVF c, W, ACCESS
1152  5A0B     SUBWFB pa, F, ACCESS
1154  5014     MOVF i, W, ACCESS
1156  5A0C     SUBWFB dividend, F, ACCESS
1158  5015     MOVF 0x15, W, ACCESS
115A  5A0D     SUBWFB dis, F, ACCESS
30:            			*(unsigned long long int *)&divisor >>= 1;
115C  90D8     BCF STATUS, 0, ACCESS
115E  3215     RRCF 0x15, F, ACCESS
1160  3214     RRCF i, F, ACCESS
1162  3213     RRCF c, F, ACCESS
1164  3212     RRCF quotient, F, ACCESS
1166  3211     RRCF fp, F, ACCESS
1168  3210     RRCF counter, F, ACCESS
116A  320F     RRCF s, F, ACCESS
116C  320E     RRCF divisor, F, ACCESS
31:            		} while(--counter != 0);
116E  2E16     DECFSZ fp, F, ACCESS
1170  D7D3     BRA 0x1118
32:            	}
33:            	if(sign)
1172  5017     MOVF sign, W, ACCESS
1174  B4D8     BTFSC STATUS, 2, ACCESS
1176  D010     BRA 0x1198
34:            		dividend = -dividend;
1178  1E0D     COMF dis, F, ACCESS
117A  1E0C     COMF dividend, F, ACCESS
117C  1E0B     COMF pa, F, ACCESS
117E  1E0A     COMF string, F, ACCESS
1180  1E09     COMF Byte, F, ACCESS
1182  1E08     COMF type, F, ACCESS
1184  1E07     COMF number, F, ACCESS
1186  6C06     NEGF Values, ACCESS
1188  0E00     MOVLW 0x0
118A  2207     ADDWFC number, F, ACCESS
118C  2208     ADDWFC type, F, ACCESS
118E  2209     ADDWFC Byte, F, ACCESS
1190  220A     ADDWFC string, F, ACCESS
1192  220B     ADDWFC pa, F, ACCESS
1194  220C     ADDWFC dividend, F, ACCESS
1196  220D     ADDWFC dis, F, ACCESS
35:            	return dividend;
1198  C006     MOVFF Values, Values
119A  F006     NOP
119C  C007     MOVFF number, number
119E  F007     NOP
11A0  C008     MOVFF type, type
11A2  F008     NOP
11A4  C009     MOVFF Byte, Byte
11A6  F009     NOP
11A8  C00A     MOVFF string, string
11AA  F00A     NOP
11AC  C00B     MOVFF pa, pa
11AE  F00B     NOP
11B0  C00C     MOVFF dividend, dividend
11B2  F00C     NOP
11B4  C00D     MOVFF dis, dis
11B6  F00D     NOP
11B8  0012     RETURN 0
36:            }
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/aodiv.c  ----------------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
0F4E  0E00     MOVLW 0x0
0F50  6E17     MOVWF sign, ACCESS
16:            	if(divisor < 0) {
0F52  AE15     BTFSS 0x15, 7, ACCESS
0F54  D012     BRA 0xF7A
17:            		divisor = -divisor;
0F56  1E15     COMF 0x15, F, ACCESS
0F58  1E14     COMF i, F, ACCESS
0F5A  1E13     COMF c, F, ACCESS
0F5C  1E12     COMF quotient, F, ACCESS
0F5E  1E11     COMF fp, F, ACCESS
0F60  1E10     COMF counter, F, ACCESS
0F62  1E0F     COMF s, F, ACCESS
0F64  6C0E     NEGF divisor, ACCESS
0F66  0E00     MOVLW 0x0
0F68  220F     ADDWFC s, F, ACCESS
0F6A  2210     ADDWFC counter, F, ACCESS
0F6C  2211     ADDWFC fp, F, ACCESS
0F6E  2212     ADDWFC quotient, F, ACCESS
0F70  2213     ADDWFC c, F, ACCESS
0F72  2214     ADDWFC i, F, ACCESS
0F74  2215     ADDWFC 0x15, F, ACCESS
18:            		sign = 1;
0F76  0E01     MOVLW 0x1
0F78  6E17     MOVWF sign, ACCESS
19:            	}
20:            	if(dividend < 0) {
0F7A  AE0D     BTFSS dis, 7, ACCESS
0F7C  D012     BRA 0xFA2
21:            		dividend = -dividend;
0F7E  1E0D     COMF dis, F, ACCESS
0F80  1E0C     COMF dividend, F, ACCESS
0F82  1E0B     COMF pa, F, ACCESS
0F84  1E0A     COMF string, F, ACCESS
0F86  1E09     COMF Byte, F, ACCESS
0F88  1E08     COMF type, F, ACCESS
0F8A  1E07     COMF number, F, ACCESS
0F8C  6C06     NEGF Values, ACCESS
0F8E  0E00     MOVLW 0x0
0F90  2207     ADDWFC number, F, ACCESS
0F92  2208     ADDWFC type, F, ACCESS
0F94  2209     ADDWFC Byte, F, ACCESS
0F96  220A     ADDWFC string, F, ACCESS
0F98  220B     ADDWFC pa, F, ACCESS
0F9A  220C     ADDWFC dividend, F, ACCESS
0F9C  220D     ADDWFC dis, F, ACCESS
22:            		sign ^= 1;
0F9E  0E01     MOVLW 0x1
0FA0  1A17     XORWF sign, F, ACCESS
23:            	}
24:            	quotient = 0;
0FA2  EE20     LFSR 2, 0x18
0FA4  F018     NOP
0FA6  0E07     MOVLW 0x7
0FA8  6ADE     CLRF POSTINC2, ACCESS
0FAA  06E8     DECF WREG, F, ACCESS
0FAC  E2FD     BC 0xFA8
25:            	if(divisor != 0) {
0FAE  500E     MOVF divisor, W, ACCESS
0FB0  100F     IORWF s, W, ACCESS
0FB2  1010     IORWF counter, W, ACCESS
0FB4  1011     IORWF fp, W, ACCESS
0FB6  1012     IORWF quotient, W, ACCESS
0FB8  1013     IORWF c, W, ACCESS
0FBA  1014     IORWF i, W, ACCESS
0FBC  1015     IORWF 0x15, W, ACCESS
0FBE  B4D8     BTFSC STATUS, 2, ACCESS
0FC0  D046     BRA 0x104E
26:            		counter = 1;
0FC2  0E01     MOVLW 0x1
0FC4  6E16     MOVWF fp, ACCESS
27:            		while((divisor & 0x8000000000000000ULL) == 0) {
0FC6  D00A     BRA 0xFDC
28:            			divisor <<= 1;
0FC8  90D8     BCF STATUS, 0, ACCESS
0FCA  360E     RLCF divisor, F, ACCESS
0FCC  360F     RLCF s, F, ACCESS
0FCE  3610     RLCF counter, F, ACCESS
0FD0  3611     RLCF fp, F, ACCESS
0FD2  3612     RLCF quotient, F, ACCESS
0FD4  3613     RLCF c, F, ACCESS
0FD6  3614     RLCF i, F, ACCESS
0FD8  3615     RLCF 0x15, F, ACCESS
29:            			counter++;
0FDA  2A16     INCF fp, F, ACCESS
30:            		}
0FDC  AE15     BTFSS 0x15, 7, ACCESS
0FDE  D7F4     BRA 0xFC8
31:            		do {
32:            			quotient <<= 1;
0FE0  90D8     BCF STATUS, 0, ACCESS
0FE2  3618     RLCF buf, F, ACCESS
0FE4  3619     RLCF PWMduty, F, ACCESS
0FE6  361A     RLCF p, F, ACCESS
0FE8  361B     RLCF mL, F, ACCESS
0FEA  361C     RLCF 0x1C, F, ACCESS
0FEC  361D     RLCF i, F, ACCESS
0FEE  361E     RLCF counter, F, ACCESS
0FF0  361F     RLCF w, F, ACCESS
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
0FF2  500E     MOVF divisor, W, ACCESS
0FF4  5C06     SUBWF Values, W, ACCESS
0FF6  500F     MOVF s, W, ACCESS
0FF8  5807     SUBWFB number, W, ACCESS
0FFA  5010     MOVF counter, W, ACCESS
0FFC  5808     SUBWFB type, W, ACCESS
0FFE  5011     MOVF fp, W, ACCESS
1000  5809     SUBWFB Byte, W, ACCESS
1002  5012     MOVF quotient, W, ACCESS
1004  580A     SUBWFB string, W, ACCESS
1006  5013     MOVF c, W, ACCESS
1008  580B     SUBWFB pa, W, ACCESS
100A  5014     MOVF i, W, ACCESS
100C  580C     SUBWFB dividend, W, ACCESS
100E  5015     MOVF 0x15, W, ACCESS
1010  580D     SUBWFB dis, W, ACCESS
1012  A0D8     BTFSS STATUS, 0, ACCESS
1014  D011     BRA 0x1038
34:            				dividend -= divisor;
1016  500E     MOVF divisor, W, ACCESS
1018  5E06     SUBWF Values, F, ACCESS
101A  500F     MOVF s, W, ACCESS
101C  5A07     SUBWFB number, F, ACCESS
101E  5010     MOVF counter, W, ACCESS
1020  5A08     SUBWFB type, F, ACCESS
1022  5011     MOVF fp, W, ACCESS
1024  5A09     SUBWFB Byte, F, ACCESS
1026  5012     MOVF quotient, W, ACCESS
1028  5A0A     SUBWFB string, F, ACCESS
102A  5013     MOVF c, W, ACCESS
102C  5A0B     SUBWFB pa, F, ACCESS
102E  5014     MOVF i, W, ACCESS
1030  5A0C     SUBWFB dividend, F, ACCESS
1032  5015     MOVF 0x15, W, ACCESS
1034  5A0D     SUBWFB dis, F, ACCESS
35:            				quotient |= 1;
1036  8018     BSF buf, 0, ACCESS
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
1038  90D8     BCF STATUS, 0, ACCESS
103A  3215     RRCF 0x15, F, ACCESS
103C  3214     RRCF i, F, ACCESS
103E  3213     RRCF c, F, ACCESS
1040  3212     RRCF quotient, F, ACCESS
1042  3211     RRCF fp, F, ACCESS
1044  3210     RRCF counter, F, ACCESS
1046  320F     RRCF s, F, ACCESS
1048  320E     RRCF divisor, F, ACCESS
38:            		} while(--counter != 0);
104A  2E16     DECFSZ fp, F, ACCESS
104C  D7C9     BRA 0xFE0
39:            	}
40:            	if(sign)
104E  5017     MOVF sign, W, ACCESS
1050  B4D8     BTFSC STATUS, 2, ACCESS
1052  D010     BRA 0x1074
41:            		quotient = -quotient;
1054  1E1F     COMF w, F, ACCESS
1056  1E1E     COMF counter, F, ACCESS
1058  1E1D     COMF i, F, ACCESS
105A  1E1C     COMF 0x1C, F, ACCESS
105C  1E1B     COMF mL, F, ACCESS
105E  1E1A     COMF p, F, ACCESS
1060  1E19     COMF PWMduty, F, ACCESS
1062  6C18     NEGF buf, ACCESS
1064  0E00     MOVLW 0x0
1066  2219     ADDWFC PWMduty, F, ACCESS
1068  221A     ADDWFC p, F, ACCESS
106A  221B     ADDWFC mL, F, ACCESS
106C  221C     ADDWFC 0x1C, F, ACCESS
106E  221D     ADDWFC i, F, ACCESS
1070  221E     ADDWFC counter, F, ACCESS
1072  221F     ADDWFC w, F, ACCESS
42:            	return quotient;
1074  C018     MOVFF buf, Values
1076  F006     NOP
1078  C019     MOVFF PWMduty, number
107A  F007     NOP
107C  C01A     MOVFF p, type
107E  F008     NOP
1080  C01B     MOVFF mL, Byte
1082  F009     NOP
1084  C01C     MOVFF 0x1C, string
1086  F00A     NOP
1088  C01D     MOVFF i, pa
108A  F00B     NOP
108C  C01E     MOVFF counter, dividend
108E  F00C     NOP
1090  C01F     MOVFF w, dis
1092  F00D     NOP
1094  0012     RETURN 0
43:            }
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/abs.c  ------------------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
1B6E  BE19     BTFSC PWMduty, 7, ACCESS
1B70  D005     BRA 0x1B7C
1B72  5019     MOVF PWMduty, W, ACCESS
1B74  E110     BNZ 0x1B96
1B76  0418     DECF buf, W, ACCESS
1B78  B0D8     BTFSC STATUS, 0, ACCESS
1B7A  D00D     BRA 0x1B96
1B7C  C018     MOVFF buf, p
1B7E  F01A     NOP
1B80  C019     MOVFF PWMduty, mL
1B82  F01B     NOP
1B84  1E1A     COMF p, F, ACCESS
1B86  1E1B     COMF mL, F, ACCESS
1B88  4A1A     INFSNZ p, F, ACCESS
1B8A  2A1B     INCF mL, F, ACCESS
1B8C  C01A     MOVFF p, buf
1B8E  F018     NOP
1B90  C01B     MOVFF mL, PWMduty
1B92  F019     NOP
1B94  0012     RETURN 0
1B96  C018     MOVFF buf, buf
1B98  F018     NOP
1B9A  C019     MOVFF PWMduty, PWMduty
1B9C  F019     NOP
1B9E  0012     RETURN 0
4:             }
---  /Applications/microchip/xc8/v2.00/pic/sources/c99/common/Umul16.c  ---------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
1C54  5006     MOVF Values, W, ACCESS
1C56  0208     MULWF type, ACCESS
1C58  CFF3     MOVFF PROD, string
1C5A  F00A     NOP
1C5C  CFF4     MOVFF PRODH, pa
1C5E  F00B     NOP
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
1C60  5006     MOVF Values, W, ACCESS
1C62  0209     MULWF Byte, ACCESS
1C64  50F3     MOVF PROD, W, ACCESS
1C66  260B     ADDWF pa, F, ACCESS
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
1C68  5007     MOVF number, W, ACCESS
1C6A  0208     MULWF type, ACCESS
1C6C  50F3     MOVF PROD, W, ACCESS
1C6E  260B     ADDWF pa, F, ACCESS
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
1C70  C00A     MOVFF string, Values
1C72  F006     NOP
1C74  C00B     MOVFF pa, number
1C76  F007     NOP
1C78  0012     RETURN 0
53:            }
